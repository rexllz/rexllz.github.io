<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker note</title>
    <url>/2019/02/13/Docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><hr>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>后台进程（dockerd）</li>
<li>REST API Server</li>
<li>CLI接口（docker）</li>
</ul>
<hr>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul>
<li>RUN</li>
<li>FROM</li>
<li>WORKDIR</li>
<li>ADD/COPY</li>
<li>ENV</li>
<li>VOLUME/EXPOSE</li>
<li>CMD/ENTRYPOINT</li>
</ul>
<blockquote>
<p>docker build -t rex/ubuntu .</p>
</blockquote>
<p>example:</p>
<p>FROM ubuntu</p>
<p>RUN apt-get update &amp;&amp; apt-get install -y stress</p>
<p>ENTRYPOINT [“/usr/bin/stress”]</p>
<p>CMD []</p>
<p>docker run -it imageid –vm 1</p>
<hr>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><ul>
<li>docker ps</li>
<li>docker images</li>
<li>docker run -d </li>
<li>docker commit </li>
<li>docker exec -it containerid ip a</li>
<li>docker stop containerid</li>
<li>docker inspect containerid</li>
<li>docker logs containerid</li>
<li>docker rm $(docker ps -aq)</li>
</ul>
<hr>
<h2 id="Network-Space"><a href="#Network-Space" class="headerlink" title="Network Space"></a>Network Space</h2><ul>
<li>docker network ls :  bridge host none</li>
<li>docker run –name web -d -p 80:80 nginx</li>
<li>host 内外一样，端口可能冲突</li>
<li>none 孤立</li>
<li>link 不需IP地址，直接通过name访问  –link containername</li>
<li>docker network create -d overlay demo</li>
<li>docker run -d –name test1 –net demo busybox</li>
</ul>
<hr>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><ul>
<li>docker run -v mysql:/var/lib/mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=true</li>
</ul>
<h3 id="Bind-Mouting"><a href="#Bind-Mouting" class="headerlink" title="Bind Mouting"></a>Bind Mouting</h3><ul>
<li>同步映射</li>
<li>docker run -v $(pwd):/usr/share</li>
</ul>
<hr>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><pre><code class="yml">version: &quot;3&quot;

services:

  redis:
    image: redis

  web:
    build:
      context: .
      dockerfile: Dockerfile
    ports: [&quot;8080&quot;]
    environment:
      REDIS_HOST: redis

  lb:
    image: dockercloud/haproxy
    links:
      - web
    ports:
      - 80:80
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
</code></pre>
<blockquote>
<p>docker compose up</p>
</blockquote>
<blockquote>
<p>docker compose down</p>
</blockquote>
<blockquote>
<p>docker compose u[ –scale web=3 -d]</p>
</blockquote>
<ul>
<li>Services</li>
<li>Networks</li>
<li>Volumes</li>
</ul>
<hr>
<h1 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h1><h2 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h2><h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><ul>
<li>Manager&gt;2(Raft 数据同步)</li>
<li><p>Worker(Gossip network)</p>
</li>
<li><p>Service</p>
</li>
<li>Replicas</li>
</ul>
<h3 id="CMD-1"><a href="#CMD-1" class="headerlink" title="CMD"></a>CMD</h3><blockquote>
<p>docker swarm init –advertise-addr=192.168.0.23</p>
</blockquote>
<blockquote>
<p>docker service create –name demo busybox sh -c “while true;do sleep 3600;done”</p>
</blockquote>
<ul>
<li>create global ;  run local</li>
</ul>
<blockquote>
<p>docker service ls </p>
</blockquote>
<blockquote>
<p>docker service  ps demo</p>
</blockquote>
<blockquote>
<p>docker service scale demo=5</p>
</blockquote>
<h4 id="Create-wordpress-service"><a href="#Create-wordpress-service" class="headerlink" title="Create wordpress service"></a>Create wordpress service</h4><blockquote>
<p>docker network create -d overlay demo</p>
</blockquote>
<blockquote>
<p>docker service create –name mysql –env MYSQL_ROOT_PASSWORD=root –env MYSQL_DATABASE=wordpress –network demo –mount type=volume,source=mysql-data,destination=/var/lib/mysql mysql:5.7</p>
</blockquote>
<blockquote>
<p>docker service create –name wordpress -p 80:80 –env WORDPRESS_DB_PASSWORD=root –env WORDPRESS_DB_HOST=mysql –network demo wordpress</p>
</blockquote>
<h3 id="Routing-Mesh"><a href="#Routing-Mesh" class="headerlink" title="Routing Mesh"></a>Routing Mesh</h3><ul>
<li>Internal: Container之间通过overlay网络（DNS虚拟IP）</li>
<li>Ingress: 若绑定端口，则swarm节点均可访问</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><blockquote>
<p>docker stack deploy example –compose-file=docker-compose.yml</p>
</blockquote>
<blockquote>
<p>docker stack ls </p>
</blockquote>
<blockquote>
<p>docker stack service example</p>
</blockquote>
<pre><code class="yml">version: &quot;3&quot;
services:

  redis:
    image: redis:alpine
    ports:
      - &quot;6379&quot;
    networks:
      - frontend
    deploy:
      replicas: 2
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure

  db:
    image: postgres:9.4
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - backend
    deploy:
      placement:
        constraints: [node.role == manager]

  vote:
    image: dockersamples/examplevotingapp_vote:before
    ports:
      - 5000:80
    networks:
      - frontend
    depends_on:
      - redis
    deploy:
      replicas: 2
      update_config:
        parallelism: 2
      restart_policy:
        condition: on-failure

  result:
    image: dockersamples/examplevotingapp_result:before
    ports:
      - 5001:80
    networks:
      - backend
    depends_on:
      - db
    deploy:
      replicas: 1
      update_config:
        parallelism: 2
        delay: 10s
      restart_policy:
        condition: on-failure

  worker:
    image: dockersamples/examplevotingapp_worker
    networks:
      - frontend
      - backend
    deploy:
      mode: replicated
      replicas: 1
      labels: [APP=VOTING]
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 3
        window: 120s
      placement:
        constraints: [node.role == manager]

  visualizer:
    image: dockersamples/visualizer:stable
    ports:
      - &quot;8080:8080&quot;
    stop_grace_period: 1m30s
    volumes:
      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;
    deploy:
      placement:
        constraints: [node.role == manager]

networks:
  frontend:
  backend:

volumes:
  db-data:
</code></pre>
<h3 id="Docker-Secret"><a href="#Docker-Secret" class="headerlink" title="Docker Secret"></a>Docker Secret</h3><ul>
<li>存在Swarm Manager Raft database</li>
<li>可以assign给service</li>
<li>Container内部secret看似文件，实为内存中存储</li>
</ul>
<blockquote>
<p>docker secret create secret-name file-name</p>
</blockquote>
<blockquote>
<p>docker secret ls</p>
</blockquote>
<blockquote>
<p>echo “adminadmin” | docker secret creat secret-name -</p>
</blockquote>
<blockquote>
<p>docker create service –secret secret-name</p>
</blockquote>
<blockquote>
<p>/run/secrets/</p>
</blockquote>
<blockquote>
<p>yml 设置secret</p>
</blockquote>
<h3 id="Service-Update"><a href="#Service-Update" class="headerlink" title="Service Update"></a>Service Update</h3><ul>
<li>热更新</li>
</ul>
<blockquote>
<p>docker service update –image image-name:2.0 service-name</p>
</blockquote>
<blockquote>
<p>docker service update –publish-rm 8080:5000 –publish-add 8088:5000 service-name</p>
</blockquote>
<blockquote>
<p>docker stack deploy第二遍yml文件</p>
</blockquote>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>K8S</tag>
        <tag>Swarm</tag>
      </tags>
  </entry>
  <entry>
    <title>Network basic</title>
    <url>/2019/07/03/Network/</url>
    <content><![CDATA[<h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="OSI-7-Level"><a href="#OSI-7-Level" class="headerlink" title="OSI -  7 Level"></a>OSI -  7 Level</h3><ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层（TCP/UDP、端口）</li>
<li>网络层（逻辑地址IP）</li>
<li>数据链路层（帧、MAC地址）</li>
<li>物理层（比特流）</li>
</ul>
<h3 id="TCP-IP-4-Lavel"><a href="#TCP-IP-4-Lavel" class="headerlink" title="TCP/IP 4 Lavel"></a>TCP/IP 4 Lavel</h3><ul>
<li>应用层</li>
<li>传输层（传输层）TCP面向连接可靠 UDP</li>
<li>网际互连层（网络层）</li>
<li>网络接口层（物理、数据链路）地址解析协议ARP：IP-MAC</li>
</ul>
<h3 id="A-B-C类网络"><a href="#A-B-C类网络" class="headerlink" title="A\B\C类网络"></a>A\B\C类网络</h3><ul>
<li>A 第一个数网络表示网段，剩下为内网分配1.0.0.0-126.255.255.255</li>
<li>B 两个网段数字128.0.0.0-192.255.255.255</li>
<li>C 前三个网段数字192.0.0.0-223.255.255.255</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>面向连接、可靠、基于字节流的传输层协议</li>
<li>将数据流分割成报文段、数据包有序，收到需要ACK、未收到重传</li>
</ul>
<h3 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h3><ul>
<li><p>套接字、socket：IP + PORT + 协议 = 唯一标识</p>
</li>
<li><p>sequence number</p>
</li>
<li><p>ack number</p>
</li>
<li><p>offset</p>
</li>
<li><p>reserved</p>
</li>
<li><p>tcp flags：URG\ACK\PSH\RST\SYN\FIN</p>
<p>ACK:确认标志</p>
<p>RST:重置连接</p>
<p>SYN:同步序号，用于建立连接</p>
<p>FIN:finish，用于释放连接</p>
</li>
<li><p>window</p>
</li>
<li><p>check奇偶校验</p>
</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>全双工，建立连接</p>
<p><img src="/2019/07/03/Network/tcp3.jpg" alt="tcp3"></p>
<h4 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h4><p>首次握手，syn超时：</p>
<p>server收到client的syn，回复syn-ack，未收到ack</p>
<p>不断重试直到超时：linux63s</p>
<p>syn cookie机制：syn队列满后，通过tcp_syncookies参数回发syn cookie（seq）</p>
<p>攻击者不会响应</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/2019/07/03/Network/tcp4.jpg" alt="tcp4"></p>
<h4 id="Why-time-wait"><a href="#Why-time-wait" class="headerlink" title="Why time wait"></a>Why time wait</h4><ul>
<li>确保有足够时间让对方收到ACK</li>
<li>避免新旧连接混淆</li>
</ul>
<h4 id="大量close-wait"><a href="#大量close-wait" class="headerlink" title="大量close wait"></a>大量close wait</h4><p>代码中忘记关闭连接</p>
<h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><p>发送保活探测，如果未收到继续发送</p>
<p>尝试次数达到上限中断连接</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>RTT：发送一个包到收到对方回应的时间</p>
<p>RTO：重传时间间隔</p>
<ul>
<li>流量控制</li>
<li>乱序重排</li>
</ul>
<p><img src="/2019/07/03/Network/window.jpg" alt="window"></p>
<p>Sender:</p>
<p><em>1</em> sent&amp;ack    <em>2</em> sent&amp;no ack        <em>3</em> not sent&amp;ready        <em>4</em> not sent&amp;not ready</p>
<p>window: 2 and 3    </p>
<p><img src="/2019/07/03/Network/windowsend.jpg" alt="windowsend"></p>
<p>Receiver:    </p>
<p><em>1</em> received&amp;ack     <em>2</em> not received$ready to receive        <em>3</em> not ready receive</p>
<p>window: 2</p>
<p><img src="/2019/07/03/Network/windowr.jpg" alt="windowr"></p>
<ul>
<li>ack在接收端没有延时</li>
<li>确认ack推动窗口滑动</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul>
<li>报文结构简单8字节</li>
<li>面向非连接</li>
<li>不维护连接状态，服务器可同时向多个客户机传送消息</li>
<li>吞吐量大</li>
<li>面向报文，不拆分合并</li>
<li>不可靠</li>
<li>无序</li>
<li>速度快</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>超文本传输协议</li>
<li>支持client/server模式</li>
<li>简单快速、灵活，数据类型多样</li>
<li>无连接（请求后连接关闭）</li>
<li>无状态（无记忆）</li>
<li>版本1.0/<strong>1.1</strong>（长连接技术）/2.0</li>
</ul>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><h4 id="请求结构"><a href="#请求结构" class="headerlink" title="请求结构"></a>请求结构</h4><ul>
<li>请求头：请求方法、URL、协议版本</li>
<li>请求头部</li>
<li>请求正文</li>
</ul>
<h4 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h4><ul>
<li>状态行：协议版本、状态码、状态码描述</li>
<li>响应头部</li>
<li>响应正文</li>
</ul>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><ul>
<li>客户端连接web server</li>
<li>发送http request</li>
<li>server接受请求并返回http response</li>
<li>释放tcp连接</li>
</ul>
<p>浏览器输入url后的过程</p>
<ul>
<li>DNS解析</li>
<li>TCP连接</li>
<li>http request</li>
<li>http response</li>
<li>浏览器渲染页面</li>
<li>连接结束</li>
</ul>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul>
<li>1xx：请求接受，继续处理</li>
<li>2xx：成功</li>
<li>3xx：重定向，跳转处理</li>
<li>4xx：客户端错误</li>
<li>5xx：服务端错误</li>
</ul>
<h3 id="Get-amp-Post"><a href="#Get-amp-Post" class="headerlink" title="Get&amp;Post"></a>Get&amp;Post</h3><p>Get请求放在URL，Post放在报文体</p>
<p>Get幂等安全、可被缓存</p>
<h3 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h3><p>Cookie：以文本形式存在客户端，由服务器分发，存在请求头</p>
<p>Session：服务器端机制，保存状态生成session id</p>
<p>​        使用cookie和url实现</p>
<h3 id="HTTP-amp-HTTPS"><a href="#HTTP-amp-HTTPS" class="headerlink" title="HTTP&amp;HTTPS"></a>HTTP&amp;HTTPS</h3><p>增加ssl层（http与tcp之间）</p>
<p>SSL：安全套接层 3.0：TLS</p>
<ul>
<li>身份认证</li>
<li>数据加密</li>
</ul>
<p>-&gt;浏览器将支持的算法发给server</p>
<p>&lt;-server选择算法，并以证书形式发回</p>
<p>-&gt;浏览器验证证书合法性，并结合证书公钥加密发送给server</p>
<p>&lt;-server通过私钥解密，验证哈希，加密响应消息发回</p>
<ul>
<li>https需要ca证书</li>
<li>http为明文传输，https为密文传输</li>
<li>https默认443端口，http为80</li>
<li>https=http+加密+认证+完整性保护</li>
</ul>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul>
<li>Socket是对tcp/ip协议的抽象</li>
</ul>
<p><img src="/2019/07/03/Network/socket.jpg" alt="socket"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP note</title>
    <url>/2019/01/01/FTP/</url>
    <content><![CDATA[<h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><h2 id="ftp-ftps-sftp区别"><a href="#ftp-ftps-sftp区别" class="headerlink" title="ftp, ftps, sftp区别"></a>ftp, ftps, sftp区别</h2><ul>
<li>ftp</li>
</ul>
<p>FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p>
<ul>
<li>ftps</li>
</ul>
<p>一种多传输协议，相当于加密版的FTP。当你在FTP服务器上收发文件的时候，你面临两个风险。第一个风险是在上载文件的时候为文件加密。第二个风险是，这些文件在你等待接收方下载的时候将停留在FTP服务器上，这时你如何保证这些文件的安全。你的第二个选择（创建一个支持SSL的FTP服务器）能够让你的主机使用一个FTPS连接上载这些文件。这包括使用一个在FTP协议下面的SSL层加密控制和数据通道。一种替代FTPS的协议是安全文件传输协议(SFTP)。这个协议使用SSH文件传输协议加密从客户机到服务器的FTP连接。</p>
<p>FTPS是在安全套接层使用标准的FTP协议和指令的一种增强型FTP协议，为FTP协议和数据通道增加了SSL安全功能。FTPS也称作“FTP-SSL”和“FTP-over-SSL”。SSL是一个在客户机和具有SSL功能的服务器之间的安全连接中对数据进行加密和解密的协议。</p>
<p>和sftp连接方法类似，在windows中可以使用FileZilla等传输软件来连接FTPS进行上传，下载文件，建立，删除目录等操作,在FileZilla连接时，有显式和隐式TLS/SSL连接之分，连接时也有指纹提示。</p>
<ul>
<li>sftp</li>
</ul>
<p>Sftp是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。SFTP 为 SSH的一部分，是一种传输档案至 Blogger 伺服器的安全方式。其实在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。</p>
<ul>
<li>sftp vs ftps</li>
</ul>
<p>SFTP 和FTPS都是为ftp连接加密，协议非常相似。</p>
<p>一个是借助ssl协议加密，一个时借助ssh加密。</p>
<p>ssl是为http/smtp等加密设计的，ssh是为telnet/ftp等加密、建立传输通道而设计的。</p>
<p>其实ssh建立传输通道就是为了加密和传输，而且这个通道是可以用来远程登录。如果只说它们的功能，通俗的讲，ssh就像铺管子，ssl就像打包裹，铺管子和打包裹都会使数据安全，都是一个制作密钥的过程，而因为ssh是一个管子所以它很适合ftp的安全传输。</p>
<ul>
<li>ssl</li>
</ul>
<p>SSL证书是HTTP明文协议升级HTTPS加密协议的重要渠道，是网络安全传输的加密到通道。</p>
<h2 id="ftp-cmd"><a href="#ftp-cmd" class="headerlink" title="ftp cmd"></a>ftp cmd</h2><ul>
<li><p>“开始”→“运行”→输入“FTP”</p>
</li>
<li><p>open ftp.test.com</p>
</li>
<li><p>dir</p>
</li>
</ul>
<p>注意：你成功登陆后就可以用dir查看查看FTP服务器中的文件及目录，用ls命令只可以查看文件。</p>
<ul>
<li>mkdir qint</li>
</ul>
<p>注意：在FTP服务器上根目录下建立qint目录</p>
<ul>
<li>cd qint</li>
</ul>
<p>注意：进入目录qint,用“cd 你的目录名”可以进入当前目录的下一级目录，这跟DOS一样。</p>
<ul>
<li>bin</li>
</ul>
<p>注意：采用二进制传输。如果你要上传下载，这一步很重要，不先执行这个命令，上传下载会很慢。大多数系统(包括UNIX系统)只有两种模式：文本模式和二进制模式。文本传输器使用ASCII字符，并由回车键和换行符分开，而二进制不用转换或格式化就可传字符，二进制模式比文本模式更快，并且可以传输所有ASCII值，所以系统管理员一般将FTP设置成二进制模式。一般来说，我们最好都用binary方式，这样可以保证不出错。</p>
<ul>
<li>lcd d:\qint</li>
</ul>
<p>注意：定位本地默认文件夹，在前面已事先在D：盘创建</p>
<ul>
<li>!dir</li>
</ul>
<p>注意：查看本地文件夹中的文件及目录</p>
<ul>
<li>put i001.jpg</li>
</ul>
<p>注意：将当前目录(d:\qint)中的文件i001.jpg上传到FTP服务器默认目录。可以用“mput <em>.</em>”将所有文件上传到FTP服务器上。</p>
<ul>
<li>get d123.jpg</li>
</ul>
<p>注意：将FTP服务器默认目录中的文件d123.jpg下载到当前目录下(d:\qint)。可以用“mget <em>.</em>”将所有文件下载到d:\qint</p>
<ul>
<li>delete <em> . </em></li>
</ul>
<p>注意：删除服务器对应目录qint中的所有文件。</p>
<ul>
<li>cd ..</li>
</ul>
<p>注意：返回至上一级目录，即根目录。返回上一级目录用“cd ..”要注意，中间有空格。返回根目录用“cd \”。</p>
<ul>
<li>mrdir qint</li>
</ul>
<p>注意：删除目录qint。删除目录，在此目录下不能有文件及目录，不然将无法删除。</p>
<ul>
<li>bye</li>
</ul>
<p>注意：退出FTP服务器。</p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>FTP</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Concurrency Note2</title>
    <url>/2019/03/13/bingfa2/</url>
    <content><![CDATA[<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>修饰方法、类、变量</li>
<li>修饰类：不能被继承</li>
<li>修饰方法：1、锁定方法不被继承类修改     2、效率（老版本）</li>
<li>修饰变量：基本数据类型不能再修改、引用类型变量不能再指向其他，但是指向的对象本身可能会发生改变</li>
<li>我的理解是本质final锁的是栈而不是堆</li>
</ul>
<h2 id="Collections-unmodifiablexxx-Guava-Immutablexxx"><a href="#Collections-unmodifiablexxx-Guava-Immutablexxx" class="headerlink" title="Collections.unmodifiablexxx/Guava:Immutablexxx"></a>Collections.unmodifiablexxx/Guava:Immutablexxx</h2><ul>
<li>提供不可变的方法</li>
</ul>
<p><img src="/2019/03/13/bingfa2/unmodify.jpg" alt="unmodify"></p>
<p>unmodifiable源码：使所有改变map的操作抛出异常(如下)</p>
<pre><code class="java"> @Override
        public V putIfAbsent(K key, V value) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean remove(Object key, Object value) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean replace(K key, V oldValue, V newValue) {
            throw new UnsupportedOperationException();
        }

        @Override
        public V replace(K key, V value) {
            throw new UnsupportedOperationException();
        }
</code></pre>
<p>Guava:Immutablexxx    同样会抛出异常，还会提示弃用</p>
<p><img src="/2019/03/13/bingfa2/immutable.jpg" alt="immutable"></p>
<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>把对象封装到一个线程中，只对一个线程可见，即保证了安全性</p>
<ul>
<li>Ad-hoc：程序控制实现，不推荐</li>
<li>堆栈封闭：局部变量，无并发问题，因为变量在线程私有的栈中</li>
<li>ThreadLocal（有机会再好好学学）</li>
</ul>
<h1 id="线程不安全类"><a href="#线程不安全类" class="headerlink" title="线程不安全类"></a>线程不安全类</h1><h2 id="StringBuilder-amp-StringBuffer"><a href="#StringBuilder-amp-StringBuffer" class="headerlink" title="StringBuilder &amp; StringBuffer"></a>StringBuilder &amp; StringBuffer</h2><pre><code class="java">public class StringExample1 {
    public static int clientTotal = 5000;
    public static int threadTotal = 200;
//    public static StringBuilder sb = new StringBuilder();
    public static StringBuffer sb = new StringBuffer();

    public static void main(String[] args) throws Exception{
        ExecutorService executorService = Executors.newCachedThreadPool();
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i&lt;clientTotal; i++){
            executorService.execute(()-&gt;{
                try {
                    semaphore.acquire();
                    update();
                    semaphore.release();
                }catch (Exception e){
                    log.error(&quot;exception&quot;,e);
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        log.info(&quot;size:{}&quot;,sb.length());
    }

    private static void update(){
        sb.append(&quot;t&quot;);
    }
}
</code></pre>
<p>StringBuffer线程安全，观察源码(都加了synchronized关键字)</p>
<pre><code class="java">@Override
    public synchronized int length() {
        return count;
    }

    @Override
    public synchronized int capacity() {
        return value.length;
    }


    @Override
    public synchronized void ensureCapacity(int minimumCapacity) {
        super.ensureCapacity(minimumCapacity);
    }

    /**
     * @since      1.5
     */
    @Override
    public synchronized void trimToSize() {
        super.trimToSize();
    }

    /**
     * @throws IndexOutOfBoundsException {@inheritDoc}
     * @see        #length()
     */
    @Override
    public synchronized void setLength(int newLength) {
        toStringCache = null;
        super.setLength(newLength);
    }
</code></pre>
<p>由上可见，线程有损耗</p>
<h2 id="SimpleDateFormat-amp-JodaTime"><a href="#SimpleDateFormat-amp-JodaTime" class="headerlink" title="SimpleDateFormat &amp; JodaTime"></a>SimpleDateFormat &amp; JodaTime</h2>]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Concurrency Note1</title>
    <url>/2019/09/03/bingfa/</url>
    <content><![CDATA[<h1 id="并发与内存模型"><a href="#并发与内存模型" class="headerlink" title="并发与内存模型"></a>并发与内存模型</h1><p><img src="/2019/09/03/bingfa/mm.jpg" alt="mm"></p>
<h1 id="并发模拟"><a href="#并发模拟" class="headerlink" title="并发模拟"></a>并发模拟</h1><ul>
<li>postman</li>
<li>ab</li>
<li>代码实现</li>
</ul>
<p><strong>CountDownLatch</strong></p>
<p><img src="/2019/09/03/bingfa/cd.jpg" alt="cd"></p>
<p>保证所有线程执行完后进行处理</p>
<pre><code class="java">package com.hku.concurrency;
import com.hku.concurrency.annoations.NotThreadSafe;
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.*;

@Slf4j
@NotThreadSafe
public class ConcurrencyTest {
    public static int clientTotal = 5000;
    public static int threadTotal = 200;
    public static int count = 0;

    public static void main(String[] args) throws Exception{
        ExecutorService executorService = Executors.newCachedThreadPool();
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i&lt;clientTotal; i++){
            executorService.execute(()-&gt;{
                try {
                    semaphore.acquire();
                    add();
                    semaphore.release();
                }catch (Exception e){
                    log.error(&quot;exception&quot;,e);
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        log.info(&quot;count:{}&quot;,count);
    }

    private static void add(){
        count ++;
    }
}

</code></pre>
<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p><img src="/2019/09/03/bingfa/security.jpg" alt="security"></p>
<p><img src="/2019/09/03/bingfa/s3.jpg" alt="s3"></p>
<h2 id="Atomic包"><a href="#Atomic包" class="headerlink" title="Atomic包"></a>Atomic包</h2><pre><code class="java">package com.hku.concurrency.example.count;

import com.hku.concurrency.annoations.ThreadSafe;
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
@ThreadSafe
public class CountExample2 {
    public static int clientTotal = 5000;
    public static int threadTotal = 200;
    public static AtomicInteger count = new AtomicInteger(0);

    public static void main(String[] args) throws Exception{
        ExecutorService executorService = Executors.newCachedThreadPool();
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i&lt;clientTotal; i++){
            executorService.execute(()-&gt;{
                try {
                    semaphore.acquire();
                    add();
                    semaphore.release();
                }catch (Exception e){
                    log.error(&quot;exception&quot;,e);
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        log.info(&quot;count:{}&quot;,count);
    }

    private static void add(){
        count.incrementAndGet();
    }
}
</code></pre>
<pre><code class="java">/**
     * Atomically increments by one the current value.
     *
     * @return the updated value
     */
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }
</code></pre>
<pre><code class="java">/**
    * var1 当前对象
    * var2 当前对象的值
    * var4 要增加的值：1
    * var5 通过底层方法得到的当前值getIntVolatile
    * CAS:
    * compareAndSwapInt(var1, var2, var5, var5 + var4)
    * 当var1对象的当前值var2与底层的值var5相同时
    * 执行var5 + var4（增量1），并赋值给var1
*/
public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
        return var5;
    }
</code></pre>
<ul>
<li>AtomicLong vs Longadder</li>
</ul>
<p>AtomicLong 在compare过程中如果一直操作，就会陷入循环，影响性能</p>
<p>Longadder 适合高并发，将任务分散至多个节点，可能有小误差</p>
<ul>
<li>AtomicReference</li>
</ul>
<pre><code class="java">package com.hku.concurrency.example.atomic;
import com.hku.concurrency.annoations.ThreadSafe;
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.atomic.AtomicReference;
@Slf4j
@ThreadSafe
public class AtomicExample4 {
    private static AtomicReference&lt;Integer&gt; count = new AtomicReference&lt;&gt;(0);

    public static void main(String[] args) {
        count.compareAndSet(0,2);
        count.compareAndSet(0,1);
        count.compareAndSet(1,3);
        count.compareAndSet(2,4);
        count.compareAndSet(3,5);
        log.info(&quot;count:{}&quot;,count.get());
    }
}
</code></pre>
<ul>
<li>AtomicIntegerFieldUpdater</li>
</ul>
<p>挂钩volatile非static字段</p>
<pre><code class="java">package com.hku.concurrency.example.atomic;
import com.hku.concurrency.annoations.ThreadSafe;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
@Slf4j
@ThreadSafe
public class AtomicExample5 {

    private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater =
        AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, &quot;count&quot;);
    @Getter
    public volatile int count = 100;
    private static AtomicExample5 atomicExample5 = new AtomicExample5();
    public static void main(String[] args) {
        if (updater.compareAndSet(atomicExample5,100,120))
        log.info(&quot;success1:{}&quot;,atomicExample5.getCount());
        if (updater.compareAndSet(atomicExample5,100,120))
            log.info(&quot;success2:{}&quot;,atomicExample5.getCount());
        else log.info(&quot;failed:{}&quot;,atomicExample5.getCount());
    }
}
</code></pre>
<ul>
<li>AtomicStampReference</li>
</ul>
<p>ABA问题，修改后又修改回去，cas失效</p>
<p>CAS方法增加了stamp版本判断</p>
<pre><code class="java">/**
     * Atomically sets the value of both the reference and stamp
     * to the given update values if the
     * current reference is {@code ==} to the expected reference
     * and the current stamp is equal to the expected stamp.
     *
     * @param expectedReference the expected value of the reference
     * @param newReference the new value for the reference
     * @param expectedStamp the expected value of the stamp
     * @param newStamp the new value for the stamp
     * @return {@code true} if successful
     */
    public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) {
        Pair&lt;V&gt; current = pair;
        return
            expectedReference == current.reference &amp;&amp;
            expectedStamp == current.stamp &amp;&amp;
            ((newReference == current.reference &amp;&amp;
              newStamp == current.stamp) ||
             casPair(current, Pair.of(newReference, newStamp)));
    }
</code></pre>
<ul>
<li>AtomicBoolean</li>
</ul>
<pre><code class="java">package com.hku.concurrency.example.atomic;
import com.hku.concurrency.annoations.ThreadSafe;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

@Slf4j
@ThreadSafe
public class AtomicExample6 {
    private static AtomicBoolean atomicBoolean = new AtomicBoolean(false);
    public static int clientTotal = 5000;
    public static int threadTotal = 200;
    public static void main(String[] args) throws Exception{
        ExecutorService executorService = Executors.newCachedThreadPool();
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i&lt;clientTotal; i++){
            executorService.execute(()-&gt;{
                try {
                    semaphore.acquire();
                    test();
                    semaphore.release();
                }catch (Exception e){
                    log.error(&quot;exception&quot;,e);
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        log.info(&quot;atomicBoolean:{}&quot;,atomicBoolean.get());
    }
    private static void test(){
        if (atomicBoolean.compareAndSet(false,true))log.info(&quot;execute&quot;);
    }
}
</code></pre>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><img src="/2019/09/03/bingfa/lock.jpg" alt="lock"></p>
<ul>
<li>同步锁</li>
</ul>
<p><img src="/2019/09/03/bingfa/syn.jpg" alt="syn"></p>
<pre><code class="java">package com.hku.concurrency.example.sync;
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
@Slf4j
public class SynchronizedExample1 {
    //修饰代码块
    public void test1(){
        synchronized (this){
            for (int i = 0; i&lt;10; i++){
                log.info(&quot;test1-{}&quot;,i);
            }
        }
    }
    //修饰方法
    public synchronized void test2(){
        for (int i = 0; i&lt;10; i++){
            log.info(&quot;test2-{}&quot;,i);
        }
    }
    public static void main(String[] args) {
        SynchronizedExample1 synchronizedExample1 = new SynchronizedExample1();
        ExecutorService executorService = Executors.newCachedThreadPool();
        //启用线程池，可使两个线程同时启动
        executorService.execute(()-&gt;{
            synchronizedExample1.test1();
        });
        executorService.execute(()-&gt;{
            synchronizedExample1.test1();
        });
    }
}
</code></pre>
<p>上式可保证有序输出</p>
<pre><code class="java"> public static void main(String[] args) {
        SynchronizedExample1 synchronizedExample1 = new SynchronizedExample1();
        SynchronizedExample1 synchronizedExample2 = new SynchronizedExample1();
        ExecutorService executorService = Executors.newCachedThreadPool();
        //启用线程池，可使两个线程同时启动
        executorService.execute(()-&gt;{
            synchronizedExample1.test1(1);
        });
        executorService.execute(()-&gt;{
            synchronizedExample2.test1(2);
        });
    }
</code></pre>
<ul>
<li>修饰块和方法时，作用于调用的对象，不同的调用对象之间不影响</li>
</ul>
<p><img src="/2019/09/03/bingfa/synlog.jpg" alt="synlog"></p>
<ul>
<li>修饰静态方法</li>
</ul>
<pre><code class="java"> //修饰静态方法
    public static synchronized void test2(int t){
        for (int i = 0; i&lt;10; i++){
            log.info(&quot;test2-{}-{}&quot;,t,i);
        }
    }
    public static void main(String[] args) {
        SynchronizedExample2 synchronizedExample1 = new SynchronizedExample2();
        SynchronizedExample2 synchronizedExample2 = new SynchronizedExample2();
        ExecutorService executorService = Executors.newCachedThreadPool();
        //启用线程池，可使两个线程同时启动
        executorService.execute(()-&gt;{
            synchronizedExample1.test2(1);
        });
        executorService.execute(()-&gt;{
            synchronizedExample2.test2(2);
        });
    }
</code></pre>
<p><img src="/2019/09/03/bingfa/synlog1.jpg" alt="synlog1"></p>
<p>作用于所有对象</p>
<ul>
<li>修饰类</li>
</ul>
<pre><code class="java">//修饰class
public void test1(int k){
        synchronized (SynchronizedExample2.class) {
            for (int i = 0; i &lt; 10; i++) {
                log.info(&quot;test1-example{}-{}&quot;, k, i);
            }
        }
    }
    public static void main(String[] args) {
        SynchronizedExample2 synchronizedExample1 = new SynchronizedExample2();
        SynchronizedExample2 synchronizedExample2 = new SynchronizedExample2();
        ExecutorService executorService = Executors.newCachedThreadPool();
        //启用线程池，可使两个线程同时启动
        executorService.execute(()-&gt;{
            synchronizedExample1.test1(1);
        });
        executorService.execute(()-&gt;{
            synchronizedExample2.test1(2);
        });
    }
</code></pre>
<p>结果与上图相同</p>
<p><img src="/2019/09/03/bingfa/3lock.jpg" alt="3lock"></p>
<h1 id="线程可见性"><a href="#线程可见性" class="headerlink" title="线程可见性"></a>线程可见性</h1><ul>
<li>共享变量在线程间的可见性</li>
</ul>
<p><strong>不可见的原因</strong></p>
<ul>
<li>线程交叉进行</li>
<li>重排序+线程交叉执行</li>
<li>共享变量更新后的值没有在主内存和工作内存中及时更新</li>
</ul>
<h2 id="Synchronized-1"><a href="#Synchronized-1" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><img src="/2019/09/03/bingfa/jmmsyn.jpg" alt="jmmsyn"></p>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p><img src="/2019/09/03/bingfa/volatile.jpg" alt="volatile"></p>
<p><img src="/2019/09/03/bingfa/v1.jpg" alt="v1"></p>
<p><img src="/2019/09/03/bingfa/v2.jpg" alt="v2"></p>
<p>直接使用volatile修饰变量并不线程安全，不具有原子性</p>
<p>使用条件：</p>
<ul>
<li>对变量写操作不依赖当前值</li>
<li>该变量赋值过程不包含其他变量</li>
<li>适合作为状态标识</li>
</ul>
<h1 id="线程有序性"><a href="#线程有序性" class="headerlink" title="线程有序性"></a>线程有序性</h1><p>JMM会对指令重排序，虽然不会影响单线程的执行，但是会影响多线程并发得到正确性</p>
<ul>
<li><p>JVM会默认保证一定的有序性，根据happens-before原则</p>
</li>
<li><p>程序次序原则：单线程内按顺序执行（看起来），只会重排无依赖的指令</p>
</li>
<li>锁定原则：unlock先于lock操作</li>
<li>volatile变量原则：对一个变量的写先于之后对此变量的读</li>
<li>传递原则：A先于B，B先于C，那么A先于C</li>
<li>线程启动原则：start先于其他动作</li>
<li>线程中断原则：interrupt后才可检测到中断发生</li>
<li>线程终结原则：所有行为先于线程终止检测</li>
<li>对象终结原则：初始化先于finalize方法</li>
</ul>
<h1 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h1><h2 id="不安全的情况"><a href="#不安全的情况" class="headerlink" title="不安全的情况"></a>不安全的情况</h2><p>直接发布可能带来的不安全性：被其他线程改变</p>
<pre><code class="java">package com.hku.concurrency.example.publish;

import com.hku.concurrency.annoations.NotThreadSafe;
import lombok.extern.slf4j.Slf4j;
import java.util.Arrays;
@Slf4j
@NotThreadSafe
public class UnsafePublish {
    private String [] status = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;};
    public String[] getStatus() {
        return status;
    }

    public static void main(String[] args) {
        UnsafePublish unsafePublish =new UnsafePublish();
        log.info(&quot;status:{}&quot;, Arrays.toString(unsafePublish.status));
        unsafePublish.getStatus()[0] = &quot;e&quot;;
        log.info(&quot;status:{}&quot;,Arrays.toString(unsafePublish.status));
    }
}
</code></pre>
<p>构造完成之前，便发布使其可见</p>
<pre><code class="java">package com.hku.concurrency.example.publish;
import com.hku.concurrency.annoations.NotRecommend;
import com.hku.concurrency.annoations.NotThreadSafe;
import lombok.extern.slf4j.Slf4j;
@Slf4j
@NotThreadSafe
@NotRecommend
public class Escape {
    private int escapeIt = 0;
    public Escape(){
        new InnerClass();
    }
    private class InnerClass{
        public InnerClass(){
            log.info(&quot;{}&quot;,Escape.this.escapeIt);
        }
    }
    //对象溢出，在该对象构造完成之前，就已经对他发布，使其对外可见
    public static void main(String[] args) {
        new Escape();
    }
}
</code></pre>
<h2 id="安全的发布对象"><a href="#安全的发布对象" class="headerlink" title="安全的发布对象"></a>安全的发布对象</h2><p><img src="/2019/09/03/bingfa/publish.jpg" alt="publish"></p>
<h2 id="单例模式的发布"><a href="#单例模式的发布" class="headerlink" title="单例模式的发布"></a>单例模式的发布</h2><pre><code class="java">package com.hku.concurrency.example.singleton;

import com.hku.concurrency.annoations.NotRecommend;
import com.hku.concurrency.annoations.NotThreadSafe;
import lombok.extern.slf4j.Slf4j;
/**
 * 懒汉模式
 * 多线程有问题
 * 多个线程都检测到空值，导致拿到不同的实例
 * Synchronized修饰getInstance可安全，但是性能降低
 */
@Slf4j
@NotRecommend
@NotThreadSafe
public class SingletonExample1 {
    //private constructor
    private SingletonExample1(){
    }
    //singleton instance
    private static SingletonExample1 instance = null;
    //static factory method
    public static SingletonExample1 getInstance(){
        if(instance == null){
            instance = new SingletonExample1();
        }
        return instance;
    }
}
</code></pre>
<pre><code class="java">package com.hku.concurrency.example.singleton;

import com.hku.concurrency.annoations.NotRecommend;
import com.hku.concurrency.annoations.NotThreadSafe;
import com.hku.concurrency.annoations.ThreadSafe;
import lombok.extern.slf4j.Slf4j;
/**
 * 饿汉模式
 * 单例实例在类装载时创建
 * 可能有资源浪费（如果实例没有使用）
 */
@Slf4j
@ThreadSafe
public class SingletonExample2 {
    //private constructor
    private SingletonExample2(){
    }
    //singleton instance
    private static SingletonExample2 instance = new SingletonExample2();
    //static factory method
    public static SingletonExample2 getInstance(){
        return instance;
    }
}
</code></pre>
<pre><code class="java">package com.hku.concurrency.example.singleton;

import com.hku.concurrency.annoations.NotRecommend;
import com.hku.concurrency.annoations.NotThreadSafe;
import lombok.extern.slf4j.Slf4j;
/**
 * 懒汉模式-双重同步锁单例模式
 * 多线程有问题
 */
@Slf4j
@NotThreadSafe
public class SingletonExample3 {
    //private constructor
    private SingletonExample3(){
    }
    //1、 memory = allocate()
    //2、 ctorInstance()初始化
    //3、 instance = memory使实例指向内存

    //JVM优化后，指令重排

    //1、 memory = allocate()
    //3、 instance = memory使实例指向内存
    //2、 ctorInstance()初始化

    //A还没有初始化，就被return
    //singleton instance
    private static SingletonExample3 instance = null;
    //static factory method
    public static SingletonExample3 getInstance(){
        if(instance == null){//双重检测                 //B
            synchronized (SingletonExample3.class) {//同步锁
                if(instance == null) {
                    instance = new SingletonExample3();//A-3
                }
            }
        }
        return instance;
    }
}
</code></pre>
<p>限制指令重排序，通过volatile：</p>
<pre><code class="java">package com.hku.concurrency.example.singleton;

import com.hku.concurrency.annoations.NotRecommend;
import com.hku.concurrency.annoations.NotThreadSafe;
import lombok.extern.slf4j.Slf4j;
/**
 * 懒汉模式-双重同步锁单例模式+volatile
 */
@Slf4j
@ThreadSafe
public class SingletonExample3 {
    //private constructor
    private SingletonExample3(){
    }
    //1、 memory = allocate()
    //2、 ctorInstance()初始化
    //3、 instance = memory使实例指向内存

    //JVM优化后，指令重排(volatile限制重排)

    //1、 memory = allocate()
    //3、 instance = memory使实例指向内存
    //2、 ctorInstance()初始化

    //A还没有初始化，就被return
    //singleton instance
    private volatile static SingletonExample3 instance = null;
    //static factory method
    public static SingletonExample3 getInstance(){
        if(instance == null){//双重检测                 //B
            synchronized (SingletonExample3.class) {//同步锁
                if(instance == null) {
                    instance = new SingletonExample3();//A-3
                }
            }
        }
        return instance;
    }
}
</code></pre>
<pre><code class="java">package com.hku.concurrency.example.singleton;

import com.hku.concurrency.annoations.NotThreadSafe;
import com.hku.concurrency.annoations.Recommend;
import com.hku.concurrency.annoations.ThreadSafe;
import lombok.extern.slf4j.Slf4j;
/**
 * 枚举模式
 * 安全且无资源浪费
 */
@Slf4j
@ThreadSafe
@Recommend
public class SingletonExample4 {
    //private constructor
    private SingletonExample4(){
    }
    public static SingletonExample4 getInstance(){
        return Singleton.INSTANCE.getInstance();
    }
    private enum Singleton{
        INSTANCE;
        private SingletonExample4 singleton;
        //JVM保证这个方法只被调用一次
        Singleton(){
            singleton = new SingletonExample4();
        }
        public SingletonExample4 getInstance(){
            return singleton;
        }
    }
}
</code></pre>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Cluster Final Note</title>
    <url>/2019/05/01/clusterFinal/</url>
    <content><![CDATA[<h1 id="Lecture-1-Introduction"><a href="#Lecture-1-Introduction" class="headerlink" title="Lecture 1: Introduction"></a>Lecture 1: Introduction</h1><h2 id="What-are-Clouds"><a href="#What-are-Clouds" class="headerlink" title="What are Clouds?"></a>What are Clouds?</h2><p>An emerging computing paradigm where data and services reside in massively scalable data centers and can be ubiquitously accessed from any connected devices over the Internet.</p>
<ul>
<li><p>SaaS：Software-as-a-Service</p>
<p>A provider licenses an application to customers for use as a service on demand. (Gmail/Hotmail, Web hosting, etc.)</p>
</li>
<li><p>PaaS：Platform-as-a-Service</p>
<p>Provide the software platform where systems run on. The sizing of the hardware resources demanded by the execution of the services is made in a transparent manner</p>
</li>
<li><p>IaaS： Infrastructure-as-a-Service</p>
<p>Through virtualization, split, assign and dynamically resize the resources to build ad-hoc systems as demanded by customers, or the service providers (SPs).</p>
</li>
<li><p>Containers as a Service (Caas):</p>
<p>Docker Cloud, Amazon Amazon Elastic Container Service (ECS).</p>
</li>
<li><p>Functions as a Service (FaaS):</p>
<p>AWS Lambda, Google Cloud Functions, Azure Functions, etc</p>
</li>
</ul>
<p><img src="/2019/05/01/clusterFinal/aas.jpg" alt="aas"></p>
<p><img src="/2019/05/01/clusterFinal/caas.jpg" alt="caas"></p>
<h2 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a>Virtualization</h2><p><img src="/2019/05/01/clusterFinal/vmm.jpg" alt="vmm"></p>
<h2 id="Cloud-Model"><a href="#Cloud-Model" class="headerlink" title="Cloud Model"></a>Cloud Model</h2><ul>
<li><p>Public Cloud</p>
<p>Cloud infrastructure is available to the general public, owned by organization selling cloud services </p>
</li>
<li><p>Private Cloud</p>
<p>Cloud infrastructure for single organization only, may be managed by the org or a 3rd party (Virtual Private Cloud)</p>
</li>
<li><p>Community Cloud</p>
<p>Cloud infrastructure shared by several organizations that have shared concerns, managed by org or 3rd party (e.g., Amazon)</p>
</li>
<li><p>Hybrid Cloud</p>
<p>Combo of &gt;=2 clouds bound by standard or proprietary technology</p>
</li>
</ul>
<h3 id="Public-Clouds"><a href="#Public-Clouds" class="headerlink" title="Public Clouds"></a>Public Clouds</h3><ul>
<li>Large scale infrastructure available on a rental basis</li>
<li>Fully customer self-service</li>
<li>Accountability is e-commerce based</li>
</ul>
<h3 id="Private-Clouds"><a href="#Private-Clouds" class="headerlink" title="Private Clouds"></a>Private Clouds</h3><p>A cloud infrastructure operated solely for a single organization, whether managed internally or by a third-party and hosted internally or externally.</p>
<ul>
<li>More expensive, but more secure (behind a firewall) when<br>compared to public clouds.</li>
</ul>
<h3 id="Community-Clouds"><a href="#Community-Clouds" class="headerlink" title="Community Clouds"></a>Community Clouds</h3><p>A community cloud is a multi-tenant infrastructure that is shared among several organizations from a specific community with common concerns</p>
<ul>
<li>High Security</li>
<li>High Availability</li>
<li>High Performance</li>
</ul>
<h3 id="Hybrid-Cloud"><a href="#Hybrid-Cloud" class="headerlink" title="Hybrid Cloud"></a>Hybrid Cloud</h3><p>An integrated cloud service utilizing both private and public clouds to perform distinct functions within the same organization</p>
<ul>
<li>Take advantage of the scalability and cost-effectiveness of the public cloud, while keeping sensitive data in the secure environment of a private cloud without exposing to the public cloud</li>
</ul>
<h2 id="Costs-for-Moving-to-the-Cloud"><a href="#Costs-for-Moving-to-the-Cloud" class="headerlink" title="Costs for Moving to the Cloud"></a>Costs for Moving to the Cloud</h2><h3 id="Transparency"><a href="#Transparency" class="headerlink" title="Transparency"></a>Transparency</h3><p>Must add Internet gateways for apps previously only on LAN</p>
<p><img src="/2019/05/01/clusterFinal/transparency.jpg" alt="transparency"></p>
<h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p>Must configure firewall rules to limit access</p>
<p><img src="/2019/05/01/clusterFinal/firewall.jpg" alt="firewall"></p>
<h3 id="Flexible-Resource-Mgmt"><a href="#Flexible-Resource-Mgmt" class="headerlink" title="Flexible Resource Mgmt"></a>Flexible Resource Mgmt</h3><p>any future change must deal with transparency and security issues all over again!</p>
<h1 id="Lecture-2-Cloud-Service-Model"><a href="#Lecture-2-Cloud-Service-Model" class="headerlink" title="Lecture 2: Cloud Service Model"></a>Lecture 2: Cloud Service Model</h1><h2 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h2><p>A model of software deployment where an application is hosted as a service provided to customers across the Internet.</p>
<ul>
<li>Apps</li>
<li>Cloud Storage</li>
<li>Cloud-Based Photo Editors</li>
<li>Cloud Gaming</li>
<li>SaaS E-commerce Platforms</li>
<li>Business &amp; Financial Services</li>
<li>Robotics as a Service (RaaS)</li>
</ul>
<h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><p>Cloud providers offer an Internet-based platform to developers who want to create services but don’t want to build their own cloud (infrastructure)</p>
<ul>
<li>Elastic Beanstalk</li>
<li>Google App Engine</li>
</ul>
<h2 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h2><p>Delivers basic storage and compute capabilities as standardized services over the network</p>
<ul>
<li><p>Amazon EC2</p>
</li>
<li><p>Elastic IP</p>
<p>Elastic IP addresses are static IP addresses designed for dynamic cloud computing.</p>
</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><strong>Advantage</strong></p>
<ul>
<li>Reduce hardware and software investment</li>
<li>Improved performance</li>
<li>Reduced software costs</li>
<li>Instant software updates</li>
</ul>
<p><strong>Disadvantage</strong></p>
<ul>
<li><p>Requires a constant Internet connection</p>
</li>
<li><p>Does not work well with low-speed connections</p>
</li>
<li><p>Can be slow:</p>
<ol>
<li>Virtualization overhead</li>
<li>Extra Network latency</li>
</ol>
</li>
<li><p>Vender Lock-In</p>
<p>Software developed in Google can not be easily moved to Amazon</p>
</li>
<li><p>Service Stability</p>
<p>Potential problems: outage, overheat, network disconnection, h/w damage, software errors</p>
</li>
<li><p>Data lost and Privacy Issue</p>
</li>
<li><p>Cost to move enterprise software to Cloud could be high</p>
</li>
</ul>
<h1 id="Lecture-3-HDFS-amp-MapReduce-Programming-Model"><a href="#Lecture-3-HDFS-amp-MapReduce-Programming-Model" class="headerlink" title="Lecture 3: HDFS &amp; MapReduce Programming Model"></a>Lecture 3: HDFS &amp; MapReduce Programming Model</h1><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>An open-source software framework for storage and large scale processing of data-sets on clusters of commodity hardware.</p>
<ul>
<li>Hadoop Common - contains libraries and utilities needed by other Hadoop modules</li>
<li>Hadoop Distributed File System (HDFS) - a distributed filesystem for storing data</li>
<li>Hadoop MapReduce - a programming model for large scale data processing</li>
<li>Hadoop YARN - resource-management and task scheduling</li>
<li>Hadoop Ozone (new in Hadoop 3.2.0): a distributed keyvalue store for Hadoop (similar to Amazon S3)</li>
</ul>
<h3 id="Hadoop-1-x"><a href="#Hadoop-1-x" class="headerlink" title="Hadoop 1.x"></a>Hadoop 1.x</h3><ul>
<li><p>Job Tracker @ master node</p>
<p>Keeps track of all the MapReduce jobs that are running on various nodes</p>
</li>
<li><p>Name Node @ master node</p>
<p>Stores metadata : file/chunk namespaces, file-to-chunk mapping, location of each chunk’s replicas. All in memory!Oversees and coordinates the data storage function</p>
</li>
<li><p>Task Tracker @ each slave node</p>
<p>a slave to the Job Tracker, Launches child processes (JVMs) to execute the map or reduce tasks</p>
</li>
<li><p>Data Node @ each slave node</p>
<p>a slave to the Name Node, stores data on the local file system (e.g., Linux ext3/ext4)</p>
</li>
</ul>
<p><img src="/2019/05/01/clusterFinal/hd1.jpg" alt="hd1"></p>
<p><img src="/2019/05/01/clusterFinal/hd11.jpg" alt="hd11"></p>
<h3 id="Hadoop-2-x"><a href="#Hadoop-2-x" class="headerlink" title="Hadoop 2.x"></a>Hadoop 2.x</h3><p>In Hadoop 2.x, the JobTracker and TaskTracker no longer exist and have been replaced by 3 components:</p>
<ul>
<li><p>ResourceManager</p>
</li>
<li><p>NodeManager</p>
<p>a worker daemon that can launch ApplicationMaster and task Containers (running mappers or reducers).</p>
</li>
<li><p>ApplicationMaster</p>
<p>A supervisory task that requests the resources needed for executing tasks based on “containers”, responsible for tracking task status and monitoring for progress.</p>
</li>
</ul>
<p>Master Node(s): Typically one machine in the cluster is designated as the NameNode (NN) and another machine as the ResourceManager (RM), exclusively.</p>
<p>Slave Nodes: The rest of the machines in the cluster act as both DataNode (DN) and NodeManager (NM). These are the slaves.</p>
<p><img src="/2019/05/01/clusterFinal/hd2.jpg" alt="hd2"></p>
<p>Users can bundle their Map Reduce code in a jar file and execute it using this command: yarn jar</p>
<h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><ul>
<li><p>Files stored as blocks</p>
<p>an HDFS file is chopped up into 64 MB/128MB blocks, each block will reside on a different data node</p>
</li>
<li><p>Reliability through replication</p>
<p>Each block is replicated across 3+ data nodes</p>
<p>Stored as local files on Linux filesystem</p>
</li>
<li><p>Single master to coordinate access, keep metadata</p>
<p>Simple centralized master per Hadoop cluster</p>
<p>Manages metadata (doesn’t store the actual data chunks)</p>
<p>Periodic heartbeat messages to checkup on slave servers</p>
</li>
<li><p>Files in HDFS are write-once and have strictly one writer at any time</p>
</li>
<li><p>Emphasis is on high throughput of data access rather than low latency of data access</p>
</li>
</ul>
<p><strong>Writing files to HDFS</strong></p>
<p>For each block, Client consults Name Node.</p>
<p>Client writes block directly to one Data Node.</p>
<p><img src="/2019/05/01/clusterFinal/write.jpg" alt="write"></p>
<p><strong>Data Replication</strong></p>
<p>Find it in /opt/hadoop-2.7.5/etc/hadoop/hdfs-site.xml</p>
<pre><code class="xml">&lt;configuration&gt;
&lt;property&gt;
&lt;name&gt;dfs.replication&lt;/name&gt;
&lt;value&gt;2&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;dfs.blocksize&lt;/name&gt;
&lt;value&gt;64m&lt;/value&gt;
&lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="Top-of-Rack-Switch-ToR-Switch"><a href="#Top-of-Rack-Switch-ToR-Switch" class="headerlink" title="Top-of-Rack Switch (ToR Switch)"></a>Top-of-Rack Switch (ToR Switch)</h3><p>In the top-of-rack design, servers connect to one Ethernet switch or two (e.g., Gigabit Ethernet switch or 10GbE switch) installed inside the rack.</p>
<p><img src="/2019/05/01/clusterFinal/tor.jpg" alt="tor"></p>
<p><img src="/2019/05/01/clusterFinal/tor2.jpg" alt="tor2"></p>
<p><strong>Replica Placement Policy</strong></p>
<ul>
<li><p>1st one on the same node as the client</p>
</li>
<li><p>2nd on a node in a different rack (off-rack)</p>
</li>
<li><p>3rd on the same rack as the 2nd one, but on a different node</p>
</li>
</ul>
<p>why? Tradeoff between reliability and write bandwidth and read bandwidth</p>
<ul>
<li><p>Network performance issue:</p>
<p>Communication in-rack a higher bandwidth, lower latency (good for performance)</p>
<p>Keep bulky flows in-rack when possible</p>
</li>
<li><p>Data loss prevention</p>
<p>Never lose all data even the entire rack fails</p>
</li>
</ul>
<p>Why not put them in THREE nodes located at three different racks?</p>
<ul>
<li>Seem Good: This maximizes redundancy (better fault tolerance).<br>But at the cost of higher bandwidth consumption over ToR switches (2 crossings)    </li>
</ul>
<p>Rack failure &lt;&lt; node failure.</p>
<p>The Name Node ensures that each block always has the intended number of replicas, also makes sure not all replicas of a block are located on one single rack.</p>
<p>Under- or over-replicated detection upon receiving a block report from a Data Node.</p>
<p>Over replicated a chooses a replica to remove.</p>
<ul>
<li>Prefer not to reduce the number of racks that host replicas</li>
<li>Prefer to remove a replica from the Data Node with the least amount of available disk space</li>
</ul>
<h3 id="Anatomy-of-a-Block-Write-amp-Read"><a href="#Anatomy-of-a-Block-Write-amp-Read" class="headerlink" title="Anatomy of a Block Write&amp;Read"></a>Anatomy of a Block Write&amp;Read</h3><p><strong>File Write</strong></p>
<p><img src="/2019/05/01/clusterFinal/write2.jpg" alt="write2"></p>
<p><strong>Pipelined Write</strong></p>
<p><img src="/2019/05/01/clusterFinal/write3.jpg" alt="write3"></p>
<p>When completed, each Data Node reports to Name Node “block received” with block info.</p>
<p>The initial node of the subsequent blocks of File.txt will vary for each block à Spreading around the hot spots of in-rack and crossrack traffic.</p>
<p><strong>Reading files from HDFS</strong></p>
<ul>
<li>Client receives Data Node list for each block</li>
<li>Client picks first Data Node for each block</li>
<li>Client reads blocks sequentially</li>
</ul>
<h3 id="Heartbeats-amp-Block-Reports"><a href="#Heartbeats-amp-Block-Reports" class="headerlink" title="Heartbeats &amp; Block Reports"></a>Heartbeats &amp; Block Reports</h3><p>Data Node sends Heartbeats to Name Node</p>
<p>Every 10th heartbeat is a Block report. Name Node builds metadata from Block reports</p>
<p><img src="/2019/05/01/clusterFinal/heartbeat.jpg" alt="heartbeat"></p>
<p><strong>Re-replicating Missing Replicas</strong></p>
<p>Missing heartbeats signify lost Nodes.</p>
<ul>
<li>Name Node consults metadata, finds affected data.</li>
<li>Name Node consults Rack Awareness script.</li>
<li>Name Node tells a Data Node to re-replicate.</li>
</ul>
<p><img src="/2019/05/01/clusterFinal/miss.jpg" alt="miss"></p>
<h3 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h3><p>If Name Node is down, HDFS is down.</p>
<p>Solution: add a 2nd Name Node</p>
<p>Hadoop 2.x used a single active Name Node and a single Standby Name Node.</p>
<ul>
<li>Connects to 1st Name Node every hour.</li>
<li>Housekeeping, backup of Name Node metadata.</li>
<li>Saved metadata can rebuild a failed Name Node.</li>
</ul>
<p><img src="/2019/05/01/clusterFinal/2nn.jpg" alt="2nn"></p>
<h3 id="Basic-HDFS-Commands"><a href="#Basic-HDFS-Commands" class="headerlink" title="Basic HDFS Commands"></a>Basic HDFS Commands</h3><p><img src="/2019/05/01/clusterFinal/cl.jpg" alt="cl"></p>
<p><img src="/2019/05/01/clusterFinal/cl2.jpg" alt="cl2"></p>
<p><img src="/2019/05/01/clusterFinal/cl3.jpg" alt="cl3"></p>
<h2 id="MapReduce-Programming-Model"><a href="#MapReduce-Programming-Model" class="headerlink" title="MapReduce Programming Model"></a>MapReduce Programming Model</h2><ul>
<li><p>Map: take one operation, apply to many data tuples.</p>
<p>run in parallel, creating different intermediate values from different input data sets.</p>
</li>
<li><p>Reduce: take result, aggregate them.</p>
<p>run in parallel, each working on a different output key</p>
</li>
</ul>
<p>MapReduce runtime system does the rest for you, including</p>
<p>(1) Fault-tolerance, (2) I/O scheduling, (3) Job status monitoring</p>
<p><img src="/2019/05/01/clusterFinal/mapreduce.jpg" alt="mapreduce"></p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Hadoop 1.0: Job Tracker first consults the Name Node to learn which Data Nodes have blocks of File.txt.</p>
<p>Job Tracker delivers Java (Map) code to Nodes with the data block.</p>
<p><img src="/2019/05/01/clusterFinal/map.jpg" alt="map"></p>
<ul>
<li><p>Map Tasks deliver output data over the network.</p>
</li>
<li><p>Reduce Task: data output is written to HDFS (disk I/O)</p>
</li>
</ul>
<p><img src="/2019/05/01/clusterFinal/reduce.jpg" alt="reduce"></p>
<p><img src="/2019/05/01/clusterFinal/wc.jpg" alt="wc"></p>
<p><strong>Scheduling Policy</strong></p>
<p>Schedule a map task on a machine that contains a replica of corresponding input data</p>
<p>Or schedule a map task near the replica of that task’s input data (e.g, at the same rack)</p>
<p><strong>What if data isn’t local?</strong></p>
<p>Why it happens? All the nodes with local data already have too many other tasks running and cannot accept anymore. Name Node suggests other nodes without data in the same rack to run the Map</p>
<ul>
<li><p>Data local map task: the map task is running local to the machine that contains the actual data.</p>
</li>
<li><p>Rack local map task: while the data isn’t local to the node running the map task, it is still on the same rack.</p>
</li>
</ul>
<p>If data local map tasks are more the performance will be improved much.</p>
<p><img src="/2019/05/01/clusterFinal/local.jpg" alt="local"></p>
<p><img src="/2019/05/01/clusterFinal/log.jpg" alt="log"></p>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><ul>
<li>Shuffle/Copy: moving map outputs to the reducers</li>
</ul>
<p>Each reducer fetches the relevant partition of the output of all the mappers via HTTP.  Note: This causes network traffic !</p>
<ul>
<li>Sort</li>
</ul>
<p>The framework merge sorts Reducer inputs by keys (since different Mappers may have output the same key).</p>
<p>Automatically sorted before they are presented to the Reducer.</p>
<ul>
<li>Reduce</li>
</ul>
<p>Perform the actual Reduce function that you wrote. The reduce output is normally stored in HDFS for reliability. The output of all Reducers is not re-sorted.</p>
<p>Shuffle Phase : Guarantees that the keys are ordered and all the values with a particular key are presented to the same reducer.</p>
<p><img src="/2019/05/01/clusterFinal/shuffle.jpg" alt="shuffle"></p>
<p><img src="/2019/05/01/clusterFinal/flow.jpg" alt="flow"></p>
<h3 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h3><p>The Partitioner partitions the Mapper output, based on the number of Reducers and any custom partitioning logic (you can define it).</p>
<p><img src="/2019/05/01/clusterFinal/partition.jpg" alt="partition"></p>
<p><img src="/2019/05/01/clusterFinal/part2.jpg" alt="part2"></p>
<p><img src="/2019/05/01/clusterFinal/spill.jpg" alt="spill"></p>
<p>Large “Spilled Records“ means High I/O overhead</p>
<h3 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h3><p><img src="/2019/05/01/clusterFinal/timeline.jpg" alt="timeline"></p>
<p><strong>When to Start Reducers</strong></p>
<p>mapreduce.job.reduce.slowstart.completed.maps</p>
<ul>
<li>= 1.00 : will wait for ALL the mappers to finish before starting the reducers à Underutilized network bandwidth problem.</li>
<li>= 0.0 : will start the reducers right away à Reducer “Slot Hoarding” problem (Container activated, but not doing work).</li>
<li>Default = 0.05, reducer tasks start when 5% of map tasks are complete</li>
</ul>
<p>The reduce phase has 3 steps: shuffle, sort, reduce. Even you start Reducer earlier, it only starts partition download from the Mapper nodes (i.e., shuffle phase) ––Reduce op is NOT performed yet!</p>
<p><strong>Specifying the number of Mappers and Reducers</strong></p>
<ul>
<li><p>Usually no need to set the number of map tasks for the job </p>
<p>– Default: 1 mapper for 1 block (128MB).</p>
<p>The user specified number is just a “hint” to the MapReduce framework.</p>
</li>
<li><p>NOTE 2: the number of reducers needs to be specified by the user. </p>
</li>
</ul>
<p>M map tasks, R reduce tasks:</p>
<ul>
<li>Make M and R much larger than the number of nodes in cluster </li>
<li>One block (64MB) per map is common</li>
<li>Other suggestion: set the number of mappers and reducers to the number of cores available minus 1 for each machine.</li>
<li>Usually R is smaller than M</li>
</ul>
<h3 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h3><ul>
<li><p>If a task crashes, Retry on another node.</p>
<p>OK for a map because it has no dependencies.</p>
<p>OK for reduce because map’s outputs are saved on disk.</p>
</li>
<li><p>If a node crashes</p>
<p>OK. Re-launch its current tasks on other nodes.</p>
<p>Re-run any maps the node previously ran.</p>
<p>Necessary because their output files (saved in disk) were lost along with the crashed node.</p>
</li>
<li><p>If a task is going slowly (“straggler”):</p>
<p>Launch second copy of task on another node (This is called “speculative execution”). </p>
<p>You have to set:</p>
<p>mapreduce.map.speculative true</p>
<p>mapreduce.reduce.speculative true</p>
<p>Stragglers occur frequently due to failing hardware, software bugs, misconfiguration, etc.</p>
<p>Single straggler may noticeably slow down a job.</p>
</li>
</ul>
<h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p>Mapper:</p>
<ul>
<li>Process a key/value pair to generate intermediate key/value pairs</li>
<li>The Mapper outputs are sorted and then partitioned per Reducer.</li>
<li>The total # of partitions is the same as the # of reduce tasks.</li>
<li>Notifies Master of this partially completed work.</li>
<li>Map tasks output is written to the local disk, not to HDFS.</li>
</ul>
<p>Reducer:</p>
<ul>
<li>Reducer uses the HTTP protocol to retrieve its own partition from the Mapper nodes.</li>
<li>Reducer reduces a set of intermediate values which share a key to a smaller set of values.</li>
<li>Users can control which keys (and hence records) go to which Reducer by implementing a custom Partitioner.</li>
</ul>
<h2 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h2><p>YARN supports non-MapReduce workloads.</p>
<p><img src="/2019/05/01/clusterFinal/yarn.jpg" alt="yarn"></p>
<h3 id="The-YARN-Scheduler"><a href="#The-YARN-Scheduler" class="headerlink" title="The YARN Scheduler"></a>The YARN Scheduler</h3><p>Treats each server as a collection of containers<br>– Container : fixed CPU + fixed memory + (disk, network)<br>3 main components:</p>
<ul>
<li><p>Global Resource Manager (RM)</p>
<p>The ultimate authority that arbitrates resources among all the<br>applications in the system</p>
</li>
<li><p>Per-server Node Manager (NM)</p>
<p>The “worker” daemon in YARN; launch the applications’ containers, monitor resource usage and report to ResourceManager.</p>
</li>
<li><p>Per-application (job) Application Master (AM)</p>
<p>Negotiating resources from the RM and working with the NodeManager(s) to execute and monitor the tasks\</p>
</li>
</ul>
<p><strong>What is a Container in YARN</strong></p>
<p>A container is a JVM process. In simple terms, container is a place where a YARN task is run.</p>
<ul>
<li>supervised by the node manager (launch, monitor)</li>
<li>scheduled by the resource manager</li>
<li>tasks that can run inside a container: Map/Reduce, Spark, Hbase, Hive,  ….</li>
<li>Note: Container location is determined by the resource manager.</li>
<li>Each container has a unique Container Id.</li>
<li>It has a specific amount of Resource allocated</li>
</ul>
<p><img src="/2019/05/01/clusterFinal/hd2modify.jpg" alt="hd2modify"></p>
<p><img src="/2019/05/01/clusterFinal/am.jpg" alt="am"></p>
<h3 id="Yarn-Job-Schedulers"><a href="#Yarn-Job-Schedulers" class="headerlink" title="Yarn (Job) Schedulers"></a>Yarn (Job) Schedulers</h3><p><img src="/2019/05/01/clusterFinal/scheduler.jpg" alt="scheduler"></p>
<p><strong>Job Execution on YARN: Control Flow</strong></p>
<p><img src="/2019/05/01/clusterFinal/yarnflow.jpg" alt="yarnflow"></p>
<p><img src="/2019/05/01/clusterFinal/flow1.jpg" alt="flow1"></p>
<p><img src="/2019/05/01/clusterFinal/flowdetail.jpg" alt="flowdetail"></p>
<h3 id="Memory-Setting-in-Yarn"><a href="#Memory-Setting-in-Yarn" class="headerlink" title="Memory Setting in Yarn"></a>Memory Setting in Yarn</h3><p><img src="/2019/05/01/clusterFinal/memory.jpg" alt="memory"></p>
<p><strong>Java Heap Size &amp; GC</strong></p>
<p>Garbage Collect (GC) time. The closer a Java application gets to full heap utilization, the more often the JVM has to run Full Garbage Collections, blocking any other work and using large amounts of CPU.</p>
<ul>
<li><p>Physical RAM limit for each Map and Reduce task</p>
</li>
<li><p>The JVM heap size limit for each task</p>
</li>
<li>The amount of virtual memory each task will get</li>
</ul>
<p>To execute a map or reduce task, YARN will run a JVM within the container. If a YARN container grows beyond its heap size setting, the task will fail.</p>
<p>The Java heap settings should be smaller than the container memory limit because we need reserve memory for Java code.</p>
<p><img src="/2019/05/01/clusterFinal/mm.jpg" alt="mm"></p>
<p><strong>vpmemo</strong></p>
<p><img src="/2019/05/01/clusterFinal/vpmm.jpg" alt="vpmm"></p>
<p><img src="/2019/05/01/clusterFinal/checker.jpg" alt="checker"></p>
<p><img src="/2019/05/01/clusterFinal/errorc.jpg" alt="errorc"></p>
<p><img src="/2019/05/01/clusterFinal/vocres.jpg" alt="vocres"></p>
<p><img src="/2019/05/01/clusterFinal/vcset.jpg" alt="vcset"></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/2019/05/01/clusterFinal/optimize1.jpg" alt="optimize1"></p>
<p><img src="/2019/05/01/clusterFinal/optimize2.jpg" alt="optimize2"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>MapReduce</tag>
        <tag>Hadoop</tag>
        <tag>Yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>Database Basic</title>
    <url>/2019/03/04/database/</url>
    <content><![CDATA[<h1 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h1><h2 id="如何设计一个关系型数据库"><a href="#如何设计一个关系型数据库" class="headerlink" title="如何设计一个关系型数据库"></a>如何设计一个关系型数据库</h2><p><img src="/2019/03/04/database/design.jpg" alt="design"></p>
<ul>
<li>实例与os文件系统相对应</li>
<li>io时间长，io一次将块和页至于内存，相近数据访问概率高</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>数据量很大时，避免全表扫描</li>
<li>类似字典</li>
<li>提升查询速度</li>
<li>主键，唯一键，普通键作为索引</li>
</ul>
<h3 id="如何生成索引"><a href="#如何生成索引" class="headerlink" title="如何生成索引"></a>如何生成索引</h3><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><ul>
<li>左小右大</li>
<li>对半搜索，O(logn)</li>
</ul>
<p><img src="/2019/03/04/database/twotree.jpg" alt="twotree"></p>
<ul>
<li>查找速度快</li>
<li>可能会很深，导致IO增多，速度降低（每深一层一次IO）</li>
</ul>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><ul>
<li><p>平衡多路查找树</p>
<p><img src="/2019/03/04/database/btree.jpg" alt="btree"></p>
</li>
<li><p>平衡</p>
</li>
</ul>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+-Tree"></a>B+-Tree</h4><p><img src="/2019/03/04/database/bplustree.jpg" alt="bplustree"></p>
<p>B+TREE更有优势</p>
<ul>
<li>磁盘读写代价低</li>
<li>查询效率稳定（所有查询路径相同）</li>
<li>有利于数据库的扫描，范围查询（叶子相连）</li>
</ul>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p><img src="/2019/03/04/database/hash.jpg" alt="hash"></p>
<ul>
<li>只能满足=，不满足IN（hash运算前后关系不确定）</li>
<li>无法避免排序运算</li>
<li>不能利用部分索引</li>
<li>不能避免行扫描</li>
<li>大量hash相等，性能低下，变为线性</li>
</ul>
<h4 id="BitMap索引"><a href="#BitMap索引" class="headerlink" title="BitMap索引"></a>BitMap索引</h4><p><img src="/2019/03/04/database/bitmap.jpg" alt="bitmap"></p>
<ul>
<li>锁力度大</li>
<li>应用范围小，关键字有限</li>
</ul>
<h3 id="密集索引-amp-稀疏索引"><a href="#密集索引-amp-稀疏索引" class="headerlink" title="密集索引&amp;稀疏索引"></a>密集索引&amp;稀疏索引</h3><ul>
<li>密集索引：每个搜索码值对应一个索引</li>
<li>稀疏索引：只为索引码的某些值建立索引项</li>
</ul>
<p><img src="/2019/03/04/database/mijixishu.jpg" alt="mijixishu"></p>
<p>代表：（mysql两个引擎）</p>
<ul>
<li>InnoDB：密集索引（数据索引存储在.ibd文件）</li>
<li>MyISAM：稀疏索引（数据索引分开存储.MYI.MYD）</li>
</ul>
<p><img src="/2019/03/04/database/innodb.jpg" alt="innodb"></p>
<p>检索过程：</p>
<p><img src="/2019/03/04/database/jiansuo.jpg" alt="jiansuo"></p>
<h3 id="如何调优sql"><a href="#如何调优sql" class="headerlink" title="如何调优sql"></a>如何调优sql</h3><ul>
<li>根据慢日志定位慢查询sql</li>
</ul>
<blockquote>
<p>show variables like ‘%quer%’;        //查看相关变量</p>
</blockquote>
<p><img src="/2019/03/04/database/slowlog.jpg" alt="slowlog"></p>
<blockquote>
<p>show status like ‘%slow_queries’;        //慢查询数量</p>
</blockquote>
<blockquote>
<p>set global slow_query_log = on;</p>
<p>set global long_query_time = 1;    //需要重连</p>
</blockquote>
<ul>
<li>Explain分析sql</li>
</ul>
<p>加在执行语句前，查看结果项</p>
<p>type：index，all需要优化</p>
<p>extra：Using filesort/Using temporary</p>
<ul>
<li>修改sql尽量让sql走索引</li>
</ul>
<h3 id="mysql联合索引最左匹配原则"><a href="#mysql联合索引最左匹配原则" class="headerlink" title="mysql联合索引最左匹配原则"></a>mysql联合索引最左匹配原则</h3><p>index（a，b）</p>
<p>只用b select 不走索引</p>
<p><img src="/2019/03/04/database/unionindex.jpg" alt="unionindex"></p>
<h3 id="索引越多越好吗"><a href="#索引越多越好吗" class="headerlink" title="索引越多越好吗"></a>索引越多越好吗</h3><ul>
<li>数据量小不需要建立索引</li>
<li>数据变更需要维护索引，维护成本变高</li>
<li>更多索引占用更多空间</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h3><h4 id="按粒度划分"><a href="#按粒度划分" class="headerlink" title="按粒度划分"></a>按粒度划分</h4><ul>
<li>表级锁</li>
<li>行级锁</li>
<li>页级锁</li>
</ul>
<h4 id="按锁级别划分"><a href="#按锁级别划分" class="headerlink" title="按锁级别划分"></a>按锁级别划分</h4><ul>
<li>共享锁</li>
<li>排他锁</li>
</ul>
<h4 id="按枷锁方式划分"><a href="#按枷锁方式划分" class="headerlink" title="按枷锁方式划分"></a>按枷锁方式划分</h4><ul>
<li>自动锁</li>
<li>显式锁</li>
</ul>
<h4 id="按操作划分"><a href="#按操作划分" class="headerlink" title="按操作划分"></a>按操作划分</h4><ul>
<li>DML锁（对数据操作）</li>
<li>DDL锁（对表结构操作）</li>
</ul>
<h4 id="按使用方式划分"><a href="#按使用方式划分" class="headerlink" title="按使用方式划分"></a>按使用方式划分</h4><ul>
<li>乐观锁（基于数据版本）</li>
<li>悲观锁（对外界修改保守态度）</li>
</ul>
<h3 id="MyISAM-amp-InnoDB锁的区别"><a href="#MyISAM-amp-InnoDB锁的区别" class="headerlink" title="MyISAM&amp;InnoDB锁的区别"></a>MyISAM&amp;InnoDB锁的区别</h3><ul>
<li>MyISAM默认表级锁，不支持行级锁</li>
</ul>
<p>对一个表进行操作时，会将表锁，其他session不能操作</p>
<p>读锁（共享锁）不释放，无法增加写锁</p>
<p>读锁（共享锁）不释放，可以增加读锁</p>
<p>写锁（排他锁）不释放，无法增加读锁</p>
<p>写锁不释放，无法增加写锁</p>
<blockquote>
<p>lock tables table_name read;</p>
<p>unlock tables;</p>
</blockquote>
<ul>
<li>InnoDB默认行级锁，也支持表级锁</li>
</ul>
<p>InnoDB采用二段锁</p>
<p>行级锁只锁一行数据</p>
<p>但是不走索引时，整张表都会被锁住</p>
<h4 id="MyISAM适合的场景"><a href="#MyISAM适合的场景" class="headerlink" title="MyISAM适合的场景"></a>MyISAM适合的场景</h4><ul>
<li>频繁执行全表count语句（保存行数变量）</li>
<li>对数据增删改频率低，查询频率高（增删改锁表）</li>
<li>没有事务</li>
</ul>
<h4 id="InnoDB适合的场景"><a href="#InnoDB适合的场景" class="headerlink" title="InnoDB适合的场景"></a>InnoDB适合的场景</h4><ul>
<li>数据增删改查都频繁（行级锁）</li>
<li>可靠性要求高</li>
<li>支持事务</li>
</ul>
<h3 id="数据库事务四大特性"><a href="#数据库事务四大特性" class="headerlink" title="数据库事务四大特性"></a>数据库事务四大特性</h3><p>ACID</p>
<ul>
<li>原子性（Atomic）操作一体化</li>
<li>一致性（Consistency）总体一致eg转账</li>
<li>隔离性（Isolation）并发互不影响</li>
<li>持久性（Durability）可恢复，储存持久</li>
</ul>
<h3 id="事务隔离级别以及各级别下并发访问"><a href="#事务隔离级别以及各级别下并发访问" class="headerlink" title="事务隔离级别以及各级别下并发访问"></a>事务隔离级别以及各级别下并发访问</h3><h4 id="事务并发访问可能引起的问题"><a href="#事务并发访问可能引起的问题" class="headerlink" title="事务并发访问可能引起的问题"></a>事务并发访问可能引起的问题</h4><ul>
<li>更新丢失</li>
</ul>
<p>一个事务的更新覆盖了另一个事务的更新</p>
<p><img src="/2019/03/04/database/updatelost.jpg" alt="updatelost"></p>
<p>（mysql所有事务隔离级别已经避免）</p>
<ul>
<li>Dirty Read</li>
</ul>
<p>一个事务读到另一个事务未提交的更新数据（回滚发生问题）</p>
<blockquote>
<p>select @@tx_isolation;        //查看事务隔离级别</p>
<p>set session transaction isolation level read uncommitted;    //设置隔离级别</p>
</blockquote>
<p>（READ-COMMITTED事务隔离级别以上可避免）</p>
<ul>
<li>不可重复读</li>
</ul>
<p>A多次读取数据，B在过程中更新数据，导致事务A读取数据不一致</p>
<p>（REPEATABLE-READ事务隔离级别以上可避免）InnoDB default</p>
<ul>
<li>幻读</li>
</ul>
<p>事务A读取与搜索条件匹配的若干行，事务B插入或删除行的方式修改了A的结果集，导致事务A像出现幻觉</p>
<p>（SERIALIZABLE事务隔离级别以上可避免）Top Level</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="/2019/03/04/database/level.jpg" alt="level"></p>
<p>事务隔离级别越高，串行程度越高，并行化越低，效率越低</p>
<p>Oracle默认为READ-COMMITTED，MySQL默认为REPEATABLE-READ</p>
<h4 id="InnoDB可重复读隔离级别下避免幻读"><a href="#InnoDB可重复读隔离级别下避免幻读" class="headerlink" title="InnoDB可重复读隔离级别下避免幻读"></a>InnoDB可重复读隔离级别下避免幻读</h4><h5 id="表象：快照读（非阻塞读）——伪MVCC（多版本并发控制）"><a href="#表象：快照读（非阻塞读）——伪MVCC（多版本并发控制）" class="headerlink" title="表象：快照读（非阻塞读）——伪MVCC（多版本并发控制）"></a>表象：快照读（非阻塞读）——伪MVCC（多版本并发控制）</h5><ul>
<li>当前读：select…lock in share mode, select…for update</li>
</ul>
<p>update, delete, insert（）</p>
<p>加了锁的增删改查，读取最新版本，并且锁住避免其他事务修改当前记录</p>
<p><img src="/2019/03/04/database/dangqian.jpg" alt="dangqian"></p>
<ul>
<li>快照读：不加锁（SERIALIZABLE事务隔离级别不成立）</li>
</ul>
<p>可能读到的是历史版本数据</p>
<h5 id="内在：next-key锁（行锁-gap锁）"><a href="#内在：next-key锁（行锁-gap锁）" class="headerlink" title="内在：next-key锁（行锁+gap锁）"></a>内在：next-key锁（行锁+gap锁）</h5><p>RR级别以上支持gap锁，防止两次当前读出现幻读</p>
<p>不锁内容本身，锁周围数据</p>
<p>对主键和唯一键索引时：</p>
<ul>
<li>where条件全部命中，不会加gap锁，只加记录锁</li>
</ul>
<p><img src="/2019/03/04/database/recordlock.jpg" alt="recordlock"></p>
<ul>
<li>where条件部分命中或全不命中，加gap锁</li>
</ul>
<p>gap锁用在非唯一索引或不走索引的当前读中</p>
<p>1、非唯一索引</p>
<p><img src="/2019/03/04/database/gaplock1.jpg" alt="gaplock1"></p>
<p>(6,9], (9,11] 被锁住（不仅id在范围内，而是范围内所有数据，可能id是20也会被锁住）</p>
<p>官方定义：</p>
<p><img src="/2019/03/04/database/gaplock2.jpg" alt="gaplock2"></p>
<p>2、不走索引</p>
<p><img src="/2019/03/04/database/gaplock3.jpg" alt="gaplock3"></p>
<p>对所有gap上锁</p>
<h3 id="RC、RR级别下InnoDB的非阻塞读的实现"><a href="#RC、RR级别下InnoDB的非阻塞读的实现" class="headerlink" title="RC、RR级别下InnoDB的非阻塞读的实现"></a>RC、RR级别下InnoDB的非阻塞读的实现</h3><ul>
<li>数据行里DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID字段</li>
</ul>
<p>DB_TRX_ID：最后一次对本行数据做修改的事务ID</p>
<p>DB_ROLL_PTR：回滚指针，undo日志记录</p>
<p>DB_ROW_ID：行号</p>
<ul>
<li>undo log，提交后丢弃</li>
<li>update undo log，回滚，快照都需要此log</li>
</ul>
<p><img src="/2019/03/04/database/undolog.jpg" alt="undolog"></p>
<ul>
<li>read view，能看到的数据，根据算法处理</li>
</ul>
<h2 id="关键语法"><a href="#关键语法" class="headerlink" title="关键语法"></a>关键语法</h2><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><ul>
<li>SELECT子句中的列名必须为分组列或列函数</li>
<li>列函数对于GROUP BY子句定义的每个组返回一个结果</li>
</ul>
<p><img src="/2019/03/04/database/groupby.jpg" alt="groupby"></p>
<p>1、查询所有同学的学号、选课数、总成绩</p>
<pre><code class="sql">select student_id,count(course_id),sum(score)

from score

group by student_id
</code></pre>
<p>GROUP BY会缓存临时数据表</p>
<p>2、查询所有同学的学号、姓名、选课数、总成绩</p>
<pre><code class="sql">select s.student_id,stu.name,count(s.course_id),sum(s.score)
from
    score s,
    student stu
where
s.student_id = stu.student_id
group by s.student_id;
</code></pre>
<h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul>
<li>通常与GROUP BY子句一起使用</li>
<li>WHERE过滤行，HAVING过滤组</li>
<li>出现顺序：WHERE&gt;GROUP BY&gt;HAVING</li>
</ul>
<p>3、查询平均成绩大于60的同学的学号和平均成绩</p>
<pre><code class="sql">select student_id,avg(score)
from score
group by student_id
having avg(score)&gt;60
</code></pre>
<p>4、查询没有学全所有课的同学的学号、姓名</p>
<pre><code class="sql">select stu.student_id,stu.name
from
student stu,
score s
where stu.student_id = s.student_id
group by s.student_id
having count(*) &lt;
(select count(*) from course)
</code></pre>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>Lock</tag>
        <tag>MySQL</tag>
        <tag>MyISAM</tag>
        <tag>InnoDB</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang Advanced Features</title>
    <url>/2019/06/23/goad/</url>
    <content><![CDATA[<h1 id="面向函数编程"><a href="#面向函数编程" class="headerlink" title="面向函数编程"></a>面向函数编程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>变量、参数、返回值可以是函数</p>
<p>实现累加，维持了sum自由变量，函数返回的是整体闭包</p>
<p><img src="/2019/06/23/goad/g0.jpg" alt="g0"></p>
<pre><code class="go">package main

import &quot;fmt&quot;

func adder() func(int) int {
    sum := 0
    return func(v int) int {
        sum += v
        return sum
    }
}


func main() {
    // a := adder() is trivial and also works.
    a := adder()
    for i := 0; i &lt; 10; i++ {
        fmt.Printf(&quot;0 + 1 + ... + %d = %d\n&quot;,i, a(i))
    }
}
</code></pre>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre><code class="go">package fib

// 1, 1, 2, 3, 5, 8, 13, ...
func Fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        a, b = b, a+b
        return a
    }
}
</code></pre>
<h2 id="为函数实现接口"><a href="#为函数实现接口" class="headerlink" title="为函数实现接口"></a>为函数实现接口</h2><pre><code class="go">package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;strings&quot;

    &quot;imooc.com/ccmouse/learngo/functional/fib&quot;
)

type intGen func() int  //type struct is a function return int

func (g intGen) Read(
    p []byte) (n int, err error) {
    next := g()
    if next &gt; 10000 {
        return 0, io.EOF
    }
    s := fmt.Sprintf(&quot;%d\n&quot;, next)

    // TODO: incorrect if p is too small!
    return strings.NewReader(s).Read(p)
}

func printFileContents(reader io.Reader) {
    scanner := bufio.NewScanner(reader)

    for scanner.Scan() {
        fmt.Println(scanner.Text())
    }
}

func main() {
    var f intGen = fib.Fibonacci()
    printFileContents(f)
}

</code></pre>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>常规遍历，不能改动遍历时的操作</p>
<pre><code class="go">func (node *Node) Traverse() {
    if node == nil {
        return
    }

    node.Left.Traverse()
    node.Print()
    node.Right.Traverse()
}
</code></pre>
<p>使用函数式编程遍历</p>
<pre><code class="go">package tree

import &quot;fmt&quot;

func (node *Node) Traverse() {
    node.TraverseFunc(func(n *Node) {
        n.Print()
    })
    fmt.Println()
}

func (node *Node) TraverseFunc(f func(*Node)) {
    if node == nil {
        return
    }

    node.Left.TraverseFunc(f)
    f(node)
    node.Right.TraverseFunc(f)
}
</code></pre>
<h1 id="错误处理与资源管理"><a href="#错误处理与资源管理" class="headerlink" title="错误处理与资源管理"></a>错误处理与资源管理</h1><h2 id="defer调用"><a href="#defer调用" class="headerlink" title="defer调用"></a>defer调用</h2><p>确保调用在函数结束时发生，defer本身是栈结构，先进后出，同时确保会执行</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;

    &quot;bufio&quot;

    &quot;imooc.com/ccmouse/learngo/functional/fib&quot;
)

func tryDefer() {
    for i := 0; i &lt; 100; i++ {
        defer fmt.Println(i)
        if i == 30 {
            // Uncomment panic to see
            // how it works with defer
            // panic(&quot;printed too many&quot;)
        }
    }
}

func writeFile(filename string) {
    file, err := os.OpenFile(filename,
        os.O_EXCL|os.O_CREATE|os.O_WRONLY, 0666)

    if err != nil {
        if pathError, ok := err.(*os.PathError); !ok {
            panic(err)
        } else {
            fmt.Printf(&quot;%s, %s, %s\n&quot;,
                pathError.Op,
                pathError.Path,
                pathError.Err)
        }
        return
    }
    defer file.Close()

    writer := bufio.NewWriter(file)
    defer writer.Flush()

    f := fib.Fibonacci()
    for i := 0; i &lt; 20; i++ {
        fmt.Fprintln(writer, f())
    }
}

func main() {
    tryDefer()
    writeFile(&quot;fib.txt&quot;)
}
</code></pre>
<p>参数在defer语句中计算</p>
<p>error会使程序挂掉（panic）</p>
<p><img src="/2019/06/23/goad/g1.jpg" alt="g1"></p>
<h2 id="统一错误处理"><a href="#统一错误处理" class="headerlink" title="统一错误处理"></a>统一错误处理</h2><p>实现一个简单的webserver</p>
<pre><code class="go">package main

import (
    &quot;log&quot;
    &quot;net/http&quot;
    _ &quot;net/http/pprof&quot;
    &quot;os&quot;

    &quot;/filelisting&quot;
)

type appHandler func(writer http.ResponseWriter,
    request *http.Request) error

func errWrapper(
    handler appHandler) func(
    http.ResponseWriter, *http.Request) {
    return func(writer http.ResponseWriter,
        request *http.Request) {
        // panic
        defer func() {
            if r := recover(); r != nil {
                log.Printf(&quot;Panic: %v&quot;, r)
                http.Error(writer,
                    http.StatusText(http.StatusInternalServerError),
                    http.StatusInternalServerError)
            }
        }()

        err := handler(writer, request)

        if err != nil {
            log.Printf(&quot;Error occurred &quot;+
                &quot;handling request: %s&quot;,
                err.Error())

            // user error
            if userErr, ok := err.(userError); ok {
                http.Error(writer,
                    userErr.Message(),
                    http.StatusBadRequest)
                return
            }

            // system error
            code := http.StatusOK
            switch {
            case os.IsNotExist(err):
                code = http.StatusNotFound
            case os.IsPermission(err):
                code = http.StatusForbidden
            default:
                code = http.StatusInternalServerError
            }
            http.Error(writer,
                http.StatusText(code), code)
        }
    }
}

type userError interface {
    error
    Message() string
}

func main() {
    http.HandleFunc(&quot;/&quot;,
        errWrapper(filelisting.HandleFileList))

    err := http.ListenAndServe(&quot;:8888&quot;, nil)
    if err != nil {
        panic(err)
    }
}
</code></pre>
<pre><code class="go">package filelisting

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

const prefix = &quot;/list/&quot;

type userError string

func (e userError) Error() string {
    return e.Message()
}

func (e userError) Message() string {
    return string(e)
}

func HandleFileList(writer http.ResponseWriter,
    request *http.Request) error {
    fmt.Println()
    if strings.Index(
        request.URL.Path, prefix) != 0 {
        return userError(
            fmt.Sprintf(&quot;path %s must start &quot;+
                &quot;with %s&quot;,
                request.URL.Path, prefix))
    }
    path := request.URL.Path[len(prefix):]
    file, err := os.Open(path)
    if err != nil {
        return err
    }
    defer file.Close()

    all, err := ioutil.ReadAll(file)
    if err != nil {
        return err
    }

    writer.Write(all)
    return nil
}
</code></pre>
<p>通过errWrapper统一处理</p>
<h2 id="panic-amp-recover"><a href="#panic-amp-recover" class="headerlink" title="panic&amp;recover"></a>panic&amp;recover</h2><p>panic致命错误，谨慎使用</p>
<p>停止当前函数执行（如果没有recover），但是会用到defer</p>
<p> recover，仅在defer调用中使用，可以获取panic，如果无法处理，可以重新panic</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func tryRecover() {
    defer func() {
        r := recover()
        if r == nil {
            fmt.Println(&quot;Nothing to recover. &quot; +
                &quot;Please try uncomment errors &quot; +
                &quot;below.&quot;)
            return
        }
        if err, ok := r.(error); ok {
            fmt.Println(&quot;Error occurred:&quot;, err)
        } else {
            panic(fmt.Sprintf(
                &quot;I don&#39;t know what to do: %v&quot;, r))
        }
    }()
    // define and use the unkonw func
    // Uncomment each block to see different panic
    // scenarios.
    // Normal error
    //panic(errors.New(&quot;this is an error&quot;))

    // Division by zero
    //b := 0
    //a := 5 / b
    //fmt.Println(a)

    // Causes re-panic
    panic(123)
}

func main() {
    tryRecover()
}

</code></pre>
<h1 id="测试与性能调优"><a href="#测试与性能调优" class="headerlink" title="测试与性能调优"></a>测试与性能调优</h1><h2 id="表格测试"><a href="#表格测试" class="headerlink" title="表格测试"></a>表格测试</h2><p>传统测试存在的问题：</p>
<ul>
<li>测试数据和测试逻辑混在一起</li>
<li>出错信息不明确</li>
<li>一旦一步出错，测试便结束</li>
</ul>
<p><img src="/2019/06/23/goad/g2.jpg" alt="g2"></p>
<p>表格驱动测试：</p>
<ul>
<li>分离的数据和逻辑</li>
<li>明确的出错信息</li>
<li>可以部分失败</li>
<li>十分适合golang</li>
</ul>
<p><img src="/2019/06/23/goad/g3.jpg" alt="g3"></p>
<pre><code class="go">package main

import &quot;testing&quot;

func TestTriangle(t *testing.T) {
    tests := []struct{ a, b, c int }{
        {3, 4, 5},
        {5, 12, 13},
        {8, 15, 17},
        {12, 35, 37},
        {30000, 40000, 50000},
    }

    for _, tt := range tests {
        if actual := calcTriangle(tt.a, tt.b); actual != tt.c {
            t.Errorf(&quot;calcTriangle(%d, %d); &quot;+
                &quot;got %d; expected %d&quot;,
                tt.a, tt.b, actual, tt.c)
        }
    }
}
</code></pre>
<h2 id="代码覆盖率和性能"><a href="#代码覆盖率和性能" class="headerlink" title="代码覆盖率和性能"></a>代码覆盖率和性能</h2><p>命令行测试指令：</p>
<blockquote>
<p>go test .</p>
</blockquote>
<p>golang还可以查看代码覆盖率</p>
<blockquote>
<p>go test -coverprofile=c.out</p>
</blockquote>
<blockquote>
<p>go test -bench .</p>
</blockquote>
<p>查找性能瓶颈：</p>
<blockquote>
<p>go test -bench . -cpuprofile cpu.out</p>
</blockquote>
<blockquote>
<p>go tool pprof cpu.out</p>
<p>web</p>
</blockquote>
<p><img src="/2019/06/23/goad/g4.jpg" alt="g4"></p>
<h2 id="httpserver测试demo"><a href="#httpserver测试demo" class="headerlink" title="httpserver测试demo"></a>httpserver测试demo</h2><pre><code class="go">package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;net/http/httptest&quot;
    &quot;os&quot;
    &quot;strings&quot;
    &quot;testing&quot;
)

func errPanic(_ http.ResponseWriter,
    _ *http.Request) error {
    panic(123)
}

type testingUserError string

func (e testingUserError) Error() string {
    return e.Message()
}

func (e testingUserError) Message() string {
    return string(e)
}

func errUserError(_ http.ResponseWriter,
    _ *http.Request) error {
    return testingUserError(&quot;user error&quot;)
}

func errNotFound(_ http.ResponseWriter,
    _ *http.Request) error {
    return os.ErrNotExist
}

func errNoPermission(_ http.ResponseWriter,
    _ *http.Request) error {
    return os.ErrPermission
}

func errUnknown(_ http.ResponseWriter,
    _ *http.Request) error {
    return errors.New(&quot;unknown error&quot;)
}

func noError(writer http.ResponseWriter,
    _ *http.Request) error {
    fmt.Fprintln(writer, &quot;no error&quot;)
    return nil
}

var tests = []struct {
    h       appHandler
    code    int
    message string
}{
    {errPanic, 500, &quot;Internal Server Error&quot;},
    {errUserError, 400, &quot;user error&quot;},
    {errNotFound, 404, &quot;Not Found&quot;},
    {errNoPermission, 403, &quot;Forbidden&quot;},
    {errUnknown, 500, &quot;Internal Server Error&quot;},
    {noError, 200, &quot;no error&quot;},
}

func TestErrWrapper(t *testing.T) {
    for _, tt := range tests {
        f := errWrapper(tt.h)
        response := httptest.NewRecorder()
        request := httptest.NewRequest(
            http.MethodGet,
            &quot;http://www.imooc.com&quot;, nil)
        f(response, request)

        verifyResponse(response.Result(),
            tt.code, tt.message, t)
    }
}

func TestErrWrapperInServer(t *testing.T) {
    for _, tt := range tests {
        f := errWrapper(tt.h)
        server := httptest.NewServer(
            http.HandlerFunc(f))
        resp, _ := http.Get(server.URL)

        verifyResponse(
            resp, tt.code, tt.message, t)
    }
}

func verifyResponse(resp *http.Response,
    expectedCode int, expectedMsg string,
    t *testing.T) {
    b, _ := ioutil.ReadAll(resp.Body)
    body := strings.Trim(string(b), &quot;\n&quot;)
    if resp.StatusCode != expectedCode ||
        body != expectedMsg {
        t.Errorf(&quot;expect (%d, %s); &quot;+
            &quot;got (%d, %s)&quot;,
            expectedCode, expectedMsg,
            resp.StatusCode, body)
    }
}
</code></pre>
<h2 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h2><blockquote>
<p>go doc</p>
</blockquote>
<blockquote>
<p>godoc -http :6060</p>
</blockquote>
<p>注释没有语法，相应位置随便写即可，自动识别</p>
<p>测试时加入example，注释output可以自动识别</p>
<p><img src="/2019/06/23/goad/g5.jpg" alt="g5"></p>
<p><img src="/2019/06/23/goad/g6.jpg" alt="g6"></p>
<h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><p>原生支持并发编程</p>
<h2 id="go-demo"><a href="#go-demo" class="headerlink" title="go demo"></a>go demo</h2><p>增加关键字go即可并发执行</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    for i := 0; i &lt; 1000; i++ {
        go func(i int) {
            for {
                fmt.Printf(&quot;Hello from &quot;+
                    &quot;goroutine %d\n&quot;, i)
            }
        }(i)
    }
    time.Sleep(time.Minute)
}

</code></pre>
<p>注意：传入参数i较为安全，否择数据冲突</p>
<p>无论线程多少，都可以支持，go原生支持了协程概念（其他语言需要实现NIO等）</p>
<h2 id="协程Coroutine"><a href="#协程Coroutine" class="headerlink" title="协程Coroutine"></a>协程Coroutine</h2><ul>
<li>轻量级线程</li>
<li>非抢占式多任务处理、由协程主动交出控制权</li>
<li>是编译器/解释器/虚拟机层面的多任务，非OS层</li>
<li>多个协程可以在一个或者多个线程上运行，由golang调度</li>
</ul>
<p>必须手动交出控制权（IO无须），否择死循环</p>
<blockquote>
<p>runtime.Gosched()</p>
</blockquote>
<p><img src="/2019/06/23/goad/g7.jpg" alt="g7"></p>
<p>JVM不支持协程</p>
<p><img src="/2019/06/23/goad/g8.jpg" alt="g8"></p>
<p>go关键字会将函数交给goroutine调度器</p>
<p>可以适用go -race查看冲突</p>
<p>goroutine可能的切换点：</p>
<ul>
<li>IO/select</li>
<li>runtime.Gosched()</li>
<li>channel</li>
<li>函数调用（有时）</li>
<li>等待锁</li>
<li>仅为可能性参考，不保证</li>
</ul>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>goroutine之间的双向通道为channel</p>
<p>通道（channel）是用来传递数据的一个数据结构。</p>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 <code>&lt;-</code> 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p>
<pre><code class="go">ch &lt;- v    // 把 v 发送到通道 ch
v := &lt;-ch  // 从 ch 接收数据
           // 并把值赋给 v
</code></pre>
<p><img src="/2019/06/23/goad/g9.png" alt="g9"></p>
<p>chan也可以作为传参和返回值</p>
<h2 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h2><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p>
<pre><code class="go">ch := make(chan int, 100)
</code></pre>
<p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p>
<pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    // 这里我们定义了一个可以存储整数类型的带缓冲通道
        // 缓冲区大小为2
        ch := make(chan int, 2)

        // 因为 ch 是带缓冲的通道，我们可以同时发送两个数据
        // 而不用立刻需要去同步读取数据
        ch &lt;- 1
        ch &lt;- 2

        // 获取这两个数据
        fmt.Println(&lt;-ch)
        fmt.Println(&lt;-ch)
}
</code></pre>
<h2 id="Go-遍历通道与关闭通道"><a href="#Go-遍历通道与关闭通道" class="headerlink" title="Go 遍历通道与关闭通道"></a>Go 遍历通道与关闭通道</h2><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p>
<pre><code class="go">v, ok := &lt;-ch
</code></pre>
<p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 <strong>close()</strong> 函数来关闭。</p>
<pre><code class="go">package main

import (
        &quot;fmt&quot;
)

func fibonacci(n int, c chan int) {
        x, y := 0, 1
        for i := 0; i &lt; n; i++ {
                c &lt;- x
                x, y = y, x+y
        }
        close(c)
}

func main() {
        c := make(chan int, 10)
        go fibonacci(cap(c), c)
        // range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个
        // 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据
        // 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不
        // 会结束，从而在接收第 11 个数据的时候就阻塞了。
        for i := range c {
                fmt.Println(i)
        }
}
</code></pre>
<p>执行输出结果为：</p>
<pre><code class="go">0
1
1
2
3
5
8
13
21
34
</code></pre>
<p>Demo:</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func worker(id int, c chan int) {
    for n := range c {
        fmt.Printf(&quot;Worker %d received %c\n&quot;,
            id, n)
    }
}
//can only send data to chan
func createWorker(id int) chan&lt;- int {
    c := make(chan int)
    go worker(id, c)
    return c
}

func chanDemo() {
    //only can receive data from chan
    var channels [10]chan&lt;- int
    for i := 0; i &lt; 10; i++ {
        channels[i] = createWorker(i)
    }

    for i := 0; i &lt; 10; i++ {
        channels[i] &lt;- &#39;a&#39; + i
    }

    for i := 0; i &lt; 10; i++ {
        channels[i] &lt;- &#39;A&#39; + i
    }

    time.Sleep(time.Millisecond)
}

func bufferedChannel() {
    c := make(chan int, 3)
    //add buffer 3 to chan
    go worker(0, c)
    c &lt;- &#39;a&#39;
    c &lt;- &#39;b&#39;
    c &lt;- &#39;c&#39;
    c &lt;- &#39;d&#39;
    //over 3 died lock
    time.Sleep(time.Millisecond)
}

func channelClose() {
    c := make(chan int)
    go worker(0, c)
    c &lt;- &#39;a&#39;
    c &lt;- &#39;b&#39;
    c &lt;- &#39;c&#39;
    c &lt;- &#39;d&#39;
    close(c)
    //can close or not
    time.Sleep(time.Millisecond)
}

func main() {
    fmt.Println(&quot;Channel as first-class citizen&quot;)
    chanDemo()
    fmt.Println(&quot;Buffered channel&quot;)
    bufferedChannel()
    fmt.Println(&quot;Channel close and range&quot;)
    channelClose()
}
</code></pre>
<p>传输并发任务是否完成的信号，定义新的chan done，替代sleep</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func doWork(id int,
    w worker) {
    for n := range w.in {
        fmt.Printf(&quot;Worker %d received %c\n&quot;,
            id, n)
        w.done()
    }
}

type worker struct {
    in   chan int
    done func()
}

func createWorker(
    id int, wg *sync.WaitGroup) worker {
    w := worker{
        in: make(chan int),
        done: func() {
            wg.Done()
        },
    }
    go doWork(id, w)
    return w
}

func chanDemo() {
    var wg sync.WaitGroup

    var workers [10]worker
    for i := 0; i &lt; 10; i++ {
        workers[i] = createWorker(i, &amp;wg)
    }

    wg.Add(20)
    for i, worker := range workers {
        worker.in &lt;- &#39;a&#39; + i
    }
    for i, worker := range workers {
        worker.in &lt;- &#39;A&#39; + i
    }

    wg.Wait()
}

func main() {
    chanDemo()
}
</code></pre>
<p>通过通信来共享内存，而非通过共享内存而通信（CSP），使用waitgroup确保任务完成</p>
<h2 id="select调度"><a href="#select调度" class="headerlink" title="select调度"></a>select调度</h2><p>优先接受先到达的数据</p>
<p><img src="/2019/06/23/goad/g10.jpg" alt="g10"></p>
<h1 id="http库"><a href="#http库" class="headerlink" title="http库"></a>http库</h1><p>client demo:</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;net/http/httputil&quot;
)

func main() {
    request, err := http.NewRequest(
        http.MethodGet,
        &quot;http://www.imooc.com&quot;, nil)
    request.Header.Add(&quot;User-Agent&quot;,
        &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1&quot;)

    client := http.Client{
        CheckRedirect: func(
            req *http.Request,
            via []*http.Request) error {
            fmt.Println(&quot;Redirect:&quot;, req)
            return nil
        },
    }
    resp, err := client.Do(request)
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    s, err := httputil.DumpResponse(resp, true)
    if err != nil {
        panic(err)
    }

    fmt.Printf(&quot;%s\n&quot;, s)
}
</code></pre>
<h1 id="广度优先遍历与迷宫问题"><a href="#广度优先遍历与迷宫问题" class="headerlink" title="广度优先遍历与迷宫问题"></a>广度优先遍历与迷宫问题</h1><p>迷宫问题，1墙0路，两端为出入口，寻找最短路径</p>
<p><img src="/2019/06/23/goad/g11.jpg" alt="g11"></p>
<p><img src="/2019/06/23/goad/g12.jpg" alt="g12"></p>
<p>终止条件：</p>
<ul>
<li>到达终点</li>
<li>前进队列为空（死路）</li>
</ul>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func readMaze(filename string) [][]int {
    file, err := os.Open(filename)
    if err != nil {
        panic(err)
    }

    var row, col int
    fmt.Fscanf(file, &quot;%d %d&quot;, &amp;row, &amp;col)

    maze := make([][]int, row)
    for i := range maze {
        maze[i] = make([]int, col)
        for j := range maze[i] {
            fmt.Fscanf(file, &quot;%d&quot;, &amp;maze[i][j])
        }
    }

    return maze
}

type point struct {
    i, j int
}

var dirs = [4]point{
    {-1, 0}, {0, -1}, {1, 0}, {0, 1}}

func (p point) add(r point) point {
    return point{p.i + r.i, p.j + r.j}
}

func (p point) at(grid [][]int) (int, bool) {
    if p.i &lt; 0 || p.i &gt;= len(grid) {
        return 0, false
    }

    if p.j &lt; 0 || p.j &gt;= len(grid[p.i]) {
        return 0, false
    }

    return grid[p.i][p.j], true
}

func walk(maze [][]int,
    start, end point) [][]int {
    steps := make([][]int, len(maze))
    for i := range steps {
        steps[i] = make([]int, len(maze[i]))
    }

    Q := []point{start}

    for len(Q) &gt; 0 {
        cur := Q[0]
        Q = Q[1:]

        if cur == end {
            break
        }

        for _, dir := range dirs {
            next := cur.add(dir)

            val, ok := next.at(maze)
            if !ok || val == 1 {
                continue
            }

            val, ok = next.at(steps)
            if !ok || val != 0 {
                continue
            }

            if next == start {
                continue
            }

            curSteps, _ := cur.at(steps)
            steps[next.i][next.j] =
                curSteps + 1

            Q = append(Q, next)
        }
    }

    return steps
}

func main() {
    maze := readMaze(&quot;maze/maze.in&quot;)

    steps := walk(maze, point{0, 0},
        point{len(maze) - 1, len(maze[0]) - 1})

    for _, row := range steps {
        for _, val := range row {
            fmt.Printf(&quot;%3d&quot;, val)
        }
        fmt.Println()
    }

    // TODO: construct path from steps
}
</code></pre>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Practice</title>
    <url>/2019/07/03/algo/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a>283. Move Zeroes</h2><p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
</code></pre><p>copy-array:</p>
<pre><code class="java">class Solution {
    public void moveZeroes(int[] nums) {
        int len = nums.length;
        int[] tmp = new int[len];
        int k = 0;
        for(int i = 0; i&lt;len; i++){
            if(nums[i]!=0){
                tmp[k]=nums[i];
                k++;
            }
        }
        for(int i = 0; i&lt;k; i++){
            nums[i]=tmp[i];
        }
        for(int i = k; i&lt;len; i++){
            nums[i]=0;
        }  
    }
}
</code></pre>
<pre><code class="java">class Solution {
    public void moveZeroes(int[] nums) {
        int len = nums.length;
        int index = 0;
        for(int i = 0; i&lt;len; i++){
            if(nums[i]!=0){
                nums[index] = nums[i];
                index++;
            }else continue;
        }
        while(index&lt;len)nums[index++]=0;
    }
}
</code></pre>
<h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h2><p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn&#39;t matter what you leave beyond the returned length.
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn&#39;t matter what values are set beyond the returned length.
</code></pre><p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<pre><code>// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre><pre><code class="java">class Solution {
    public int removeElement(int[] nums, int val) {
        int len = nums.length;
        int j = 0;
        for(int i = 0; i&lt;len; i++){
            if(nums[i]!=val)nums[j++]=nums[i];
        }
        return j;
    }
}
</code></pre>
<h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h2><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn&#39;t matter what you leave beyond the returned length.
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn&#39;t matter what values are set beyond the returned length.
</code></pre><p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<pre><code>// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre><pre><code class="java">class Solution {
    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        int k = 0;
        for(int i = 0; i&lt;len; i++){
            if(nums[i]!=nums[k])nums[++k]=nums[i];
        }
        return k+1;
    }
}
</code></pre>
<h2 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80. Remove Duplicates from Sorted Array II"></a>80. Remove Duplicates from Sorted Array II</h2><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that duplicates appeared at most <em>twice</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn&#39;t matter what you leave beyond the returned length.
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn&#39;t matter what values are set beyond the returned length.
</code></pre><p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<pre><code>// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre><pre><code class="java">class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) {return 0;}
        int pointer = 0, flag = 0;
        for (int i = 1; i &lt; nums.length; i++) {
        if (nums[i] == nums[i - 1] &amp;&amp; flag == 0) {
            flag = 1;
            pointer++;
        } else if (nums[i] != nums[i - 1]) {
            flag = 0;
            pointer++;
        }
        nums[pointer] = nums[i];
      }
    return pointer + 1;
    }
}
</code></pre>
<h2 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a>75. Sort Colors</h2><p>Given an array with <em>n</em> objects colored red, white or blue, sort them <strong>in-place</strong> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
</code></pre><p><strong>Follow up:</strong></p>
<ul>
<li>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</li>
<li>Could you come up with a one-pass algorithm using only constant space?</li>
</ul>
<p>count sort</p>
<pre><code class="java">class Solution {
    public void sortColors(int[] nums) {
        int[] count = new int[3];
        int len = nums.length;
        for(int i = 0; i&lt;3; i++)count[i]=0;
        for(int i = 0; i&lt;len; i++){
            if(nums[i]==0)count[0]++;
            else if(nums[i]==1)count[1]++;
            else count[2]++;
        }
        int index = 0;
        while(count[0]&gt;0){
            nums[index]=0;
            index++;
            count[0]--;
        }
        while(count[1]&gt;0){
            nums[index]=1;
            index++;
            count[1]--;
        }
        while(count[2]&gt;0){
            nums[index]=2;
            index++;
            count[2]--;
        }
    }
}
</code></pre>
<p>3-way quick sort</p>
<pre><code class="java">class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        int index1 = -1, index2 = len;
        for(int i = 0; i&lt;index2; ){
            if(nums[i]==1){
                i++;
            }else if(nums[i]==2){
                index2--;
                swap(nums,index2,i);
            }else{
                index1++;
                swap(nums,index1,i);
                i++;
            }
        }      
    }
    public void swap(int[] nums, int a, int b){
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}
</code></pre>
<h2 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. Merge Sorted Array</h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
</code></pre><pre><code class="java">class Solution {
     public void merge(int A[], int m, int B[], int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while(i &gt;= 0 &amp;&amp; j &gt;= 0) {
            A[k--] = A[i] &gt; B[j] ? A[i--] : B[j--];
        }
        while(j &gt;= 0) {
            A[k--] = B[j--];
        }
    }
}
</code></pre>
<h2 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h2><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [3,2,1,5,6,4] and k = 2
Output: 5
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
</code></pre><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<pre><code class="java">class Solution {
    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int t = 0;
        while(t&lt;k){
            for(int i = t+1; i&lt;len; i++){
            if(nums[i]&gt;nums[t]){
                swap(nums,i,t);
                }
            }
            t++;
        }
        return nums[k-1];
    }
    public void swap(int[] arr, int a, int b){
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
</code></pre>
<pre><code class="java">public class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue&lt;Integer&gt; largeK = new PriorityQueue&lt;Integer&gt;(k + 1);
        for(int el : nums) {
            largeK.add(el);
            if (largeK.size() &gt; k) {
                largeK.poll();
            }
        }
        return largeK.poll();
    }
}
</code></pre>
<h1 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h1><h2 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a>349. Intersection of Two Arrays</h2><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
</code></pre><p><strong>Note:</strong></p>
<ul>
<li>Each element in the result must be unique.</li>
<li>The result can be in any order.</li>
</ul>
<pre><code class="java">class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();
        HashSet&lt;Integer&gt; set1 = new HashSet&lt;&gt;();
        for(int i = 0; i&lt;nums1.length; i++){
            set.add(nums1[i]);
        }
        for(int i = 0; i&lt;nums2.length; i++){
            if(set.contains(nums2[i]))set1.add(nums2[i]);
        }
        int size = set1.size();
        int[] out = new int[size];
        int i = 0;
        for(Integer x : set1)out[i++]=x;
        return out;
    }
}
</code></pre>
<h2 id="350-Intersection-of-Two-Arrays-II"><a href="#350-Intersection-of-Two-Arrays-II" class="headerlink" title="350. Intersection of Two Arrays II"></a>350. Intersection of Two Arrays II</h2><p>Given two arrays, write a function to compute their intersection.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
</code></pre><p><strong>Note:</strong></p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong>Follow up:</strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if <em>nums1</em>‘s size is small compared to <em>nums2</em>‘s size? Which algorithm is better?</li>
<li>What if elements of <em>nums2</em> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<pre><code class="java">class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        int start = 0;
        for(int i = 0; i&lt;nums1.length; i++){
            map.put(nums1[i],map.getOrDefault(nums1[i],0)+1);
        }
        for(int i = 0; i&lt;nums2.length; i++){
            if(map.containsKey(nums2[i]) &amp;&amp; map.get(nums2[i])&gt;0){
                nums1[start]=nums2[i];
                start++;
                map.put((nums2[i]),map.get(nums2[i])-1);
            }else continue;    
        }
        return Arrays.copyOfRange(nums1,0,start);
    }
}
</code></pre>
<h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a>202. Happy Number</h2><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p><strong>Example:</strong> </p>
<pre><code>Input: 19
Output: true
Explanation: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
</code></pre><pre><code class="java">class Solution {
    public boolean isHappy(int n) {
        int res = 0;
        int result = n;
        boolean flag = true;
        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();
        while(result!=1){
            while(result/10&gt;0 || result%10!=0){
                res = res + (result%10)*(result%10);
                result /= 10;
            }
            if(set.contains(res)){
                flag = false;
                break;
            }
            result = res;
            res = 0;
            set.add(result);
        }
        return flag;
    }
}
</code></pre>
<h2 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a>454. 4Sum II</h2><p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p>
<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>
<p><strong>Example:</strong></p>
<pre><code>Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
</code></pre><pre><code class="java">class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        int len = A.length;
        int res = 0;
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for(int i = 0; i&lt;len; i++){
            for(int j = 0; j&lt;len; j++){
                if(!map.containsKey(A[i]+B[j])){
                    map.put(A[i]+B[j], 1);
                }else{
                    map.put(A[i]+B[j], map.get(A[i]+B[j])+1);
                }
            }
        }
        for(int i = 0; i&lt;len; i++)
            for(int j = 0; j&lt;len; j++){
                if(map.containsKey(0 - C[i] - D[j])){
                    res += map.get(0 - C[i] - D[j]);
                }
            }
        return res;
    }
}
</code></pre>
<h2 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h2><p>Given an array of strings, group anagrams together.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
Output:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
</code></pre><p><strong>Note:</strong></p>
<ul>
<li>All inputs will be in lowercase.</li>
<li>The order of your output does not matter.</li>
</ul>
<pre><code class="java">class Solution {
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;List&lt;String&gt;&gt;();
        HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();
        for(String str : strs){
            char[] cs = str.toCharArray();
            Arrays.sort(cs);
            String ketstr = String.valueOf(cs);
            if(!map.containsKey(ketstr))
                map.put(ketstr, new ArrayList&lt;String&gt;());
            map.get(ketstr).add(str);
        }
        for(String key : map.keySet()){
            list.add(map.get(key));
        }
        return list;
        return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());
    }
}
</code></pre>
<h2 id="447-Number-of-Boomerangs"><a href="#447-Number-of-Boomerangs" class="headerlink" title="447. Number of Boomerangs"></a>447. Number of Boomerangs</h2><p>Given <em>n</em> points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code> and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<strong>the order of the tuple matters</strong>).</p>
<p>Find the number of boomerangs. You may assume that <em>n</em> will be at most <strong>500</strong> and coordinates of points are all in the range <strong>[-10000, 10000]</strong> (inclusive).</p>
<p><strong>Example:</strong></p>
<pre><code>Input:
[[0,0],[1,0],[2,0]]

Output:
2

Explanation:
The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
</code></pre><pre><code class="java">class Solution {
    public int numberOfBoomerangs(int[][] points) {
        int len = points.length;
        int count = 0;
        double dis = 0;
        for(int i = 0; i&lt;len; i++){
            HashMap&lt;Double, Integer&gt; map = new HashMap&lt;Double, Integer&gt;();
            for(int j = 0; j&lt;len; j++){
                if(i != j){
                    dis = Math.pow(points[i][0] - points[j][0], 2) + 
                    Math.pow(points[i][1] - points[j][1], 2);
                    if(!map.containsKey(dis))map.put(dis, 1);
                    else map.put(dis, map.get(dis)+1);
                }
            }
            for(Double x : map.keySet()){
                if(map.get(x) == 1)continue;
                int sum = map.get(x)*(map.get(x)-1);
                count += sum;
            }
        }
        return count;
    }
}
</code></pre>
<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h2><p>Reverse a singly linked list.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre><p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode head) {

        if(head == null || head.next == null)
            return head;
        ListNode nextNode = head.next;
        ListNode newHead = reverseList(head.next);
        nextNode.next = head;
        head.next = null;
        return newHead;
    }
}
</code></pre>
<h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203. Remove Linked List Elements"></a>203. Remove Linked List Elements</h2><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p>
<p><strong>Example:</strong></p>
<pre><code>Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
Output: 1-&gt;2-&gt;3-&gt;4-&gt;5
</code></pre><pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head==null)return null;
        head.next = removeElements(head.next,val);
        if(head.val==val)return head.next;
        else return head;   
    }    
}
</code></pre>
<pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy;
        while(pre.next!=null){
            if(pre.next.val==val)pre.next=pre.next.next;
            else pre = pre.next;
        }
        return dummy.next;
    }    
}
</code></pre>
<h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre><pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null)return l2;
        if(l2==null)return l1;
        ListNode dummy = new ListNode(-1);
        ListNode pre = dummy;
        while(l1 != null &amp;&amp; l2 != null){
            if(l1.val &gt; l2.val){
                pre.next = l2;
                l2 = l2.next;
            }else {
                pre.next = l1;
                l1 = l1.next;
            }
            pre = pre.next;
        }
        while(l1 != null){
            pre.next = l1;
            l1 = l1.next;
            pre = pre.next;
        }
        while(l2 != null){
            pre.next = l2;
            l2 = l2.next;
            pre = pre.next;
        }
        /**
        if (l1 != null) {
            pre.next = l1;
        }
        if (l2 != null) {
            pre.next = l2;
        }
        **/
        return dummy.next;
    }     
}
</code></pre>
<pre><code class="java">public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null)return l2;
        if(l2 == null)return l1;
        if(l1.val &gt; l2.val){
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
        else {
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }
    }
}
</code></pre>
<h2 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p><strong>Example:</strong></p>
<pre><code>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.
</code></pre><pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode start = head.next;
        head.next = swapPairs(head.next.next);
        start.next = head;
        return start;
    }
}
</code></pre>
<pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy; 
        while(pre.next != null &amp;&amp; pre.next.next != null){
            ListNode cur = pre.next;
            ListNode fast = cur.next;
            cur.next = fast.next;
            fast.next = cur;
            pre.next = fast;
            pre = pre.next.next;
        }
        return dummy.next;
    }
}
</code></pre>
<h2 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147. Insertion Sort List"></a>147. Insertion Sort List</h2><p>Sort a linked list using insertion sort.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"><br>A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.<br>With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list</p>
<p><strong>Algorithm of Insertion Sort:</strong></p>
<ol>
<li>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</li>
<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</li>
<li>It repeats until no input elements remain.</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: -1-&gt;5-&gt;3-&gt;4-&gt;0
Output: -1-&gt;0-&gt;3-&gt;4-&gt;5
</code></pre><pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode insertionSortList(ListNode head) {
        if( head == null ){
            return head;
        }
        ListNode helper = new ListNode(0); //new starter of the sorted list
        ListNode cur = head; //the node will be inserted
        ListNode pre = helper; //insert node between pre and pre.next
        ListNode next = null; //the next node will be inserted
        //not the end of input list
        while( cur != null ){
            next = cur.next;
            //find the right place to insert
            while( pre.next != null &amp;&amp; pre.next.val &lt; cur.val ){
                pre = pre.next;
            }
            //insert between pre and pre.next
            cur.next = pre.next;
            pre.next = cur;
            pre = helper;
            cur = next;
        }
        return helper.next;
    }
}
</code></pre>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h2><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;()&quot;
Output: true
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;()[]{}&quot;
Output: true
</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;(]&quot;
Output: false
</code></pre><p><strong>Example 4:</strong></p>
<pre><code>Input: &quot;([)]&quot;
Output: false
</code></pre><p><strong>Example 5:</strong></p>
<pre><code>Input: &quot;{[]}&quot;
Output: true
</code></pre><pre><code class="java">public class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for(int i = 0; i &lt; s.length(); i++) {
            char a = s.charAt(i);
            if(a == &#39;(&#39; || a == &#39;[&#39; || a == &#39;{&#39;) stack.push(a);
            else if(stack.empty()) return false;
            else if(a == &#39;)&#39; &amp;&amp; stack.pop() != &#39;(&#39;) return false;
            else if(a == &#39;]&#39; &amp;&amp; stack.pop() != &#39;[&#39;) return false;
            else if(a == &#39;}&#39; &amp;&amp; stack.pop() != &#39;{&#39;) return false;
        }
        return stack.empty();
    }
}
</code></pre>
<h2 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a>150. Evaluate Reverse Polish Notation</h2><p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank" rel="noopener">Reverse Polish Notation</a>.</p>
<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Division between two integers should truncate toward zero.</li>
<li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
Output: 9
Explanation: ((2 + 1) * 3) = 9
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]
Output: 6
Explanation: (4 + (13 / 5)) = 6
</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]
Output: 22
Explanation: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</code></pre><pre><code class="java">public class Solution {
    public int evalRPN(String[] tokens) {
        int a,b;
        Stack&lt;Integer&gt; S = new Stack&lt;Integer&gt;();
        for (String s : tokens) {
            if(s.equals(&quot;+&quot;)) {
                S.add(S.pop()+S.pop());
            }
            else if(s.equals(&quot;/&quot;)) {
                b = S.pop();
                a = S.pop();
                S.add(a / b);
            }
            else if(s.equals(&quot;*&quot;)) {
                S.add(S.pop() * S.pop());
            }
            else if(s.equals(&quot;-&quot;)) {
                b = S.pop();
                a = S.pop();
                S.add(a - b);
            }
            else {
                S.add(Integer.parseInt(s));
            }
        }    
        return S.pop();
    }
}
</code></pre>
<h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a>71. Simplify Path</h2><p>Given an <strong>absolute path</strong> for a file (Unix-style), simplify it. Or in other words, convert it to the <strong>canonical path</strong>.</p>
<p>In a UNIX-style file system, a period <code>.</code> refers to the current directory. Furthermore, a double period <code>..</code> moves the directory up a level. For more information, see: <a href="https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/" target="_blank" rel="noopener">Absolute path vs relative path in Linux/Unix</a></p>
<p>Note that the returned canonical path must always begin with a slash <code>/</code>, and there must be only a single slash <code>/</code> between two directory names. The last directory name (if it exists) <strong>must not</strong> end with a trailing <code>/</code>. Also, the canonical path must be the <strong>shortest</strong> string representing the absolute path.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;/home/&quot;
Output: &quot;/home&quot;
Explanation: Note that there is no trailing slash after the last directory name.
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;/../&quot;
Output: &quot;/&quot;
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.
</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;/home//foo/&quot;
Output: &quot;/home/foo&quot;
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.
</code></pre><p><strong>Example 4:</strong></p>
<pre><code>Input: &quot;/a/./b/../../c/&quot;
Output: &quot;/c&quot;
</code></pre><p><strong>Example 5:</strong></p>
<pre><code>Input: &quot;/a/../../b/../c//.//&quot;
Output: &quot;/c&quot;
</code></pre><p><strong>Example 6:</strong></p>
<pre><code>Input: &quot;/a//b////c/d//././/..&quot;
Output: &quot;/a/b/c&quot;
</code></pre><pre><code class="java">public String simplifyPath(String path) {
    Stack&lt;String&gt; stack = new Stack&lt;&gt;();
    String[] p = path.split(&quot;/&quot;);
    for (int i = 0; i &lt; p.length; i++) {
        if (!stack.empty() &amp;&amp; p[i].equals(&quot;..&quot;))
            stack.pop();
        else if (!p[i].equals(&quot;.&quot;) &amp;&amp; !p[i].equals(&quot;&quot;) &amp;&amp; !p[i].equals(&quot;..&quot;))
            stack.push(p[i]);
    }
    List&lt;String&gt; list = new ArrayList(stack);
    return &quot;/&quot;+String.join(&quot;/&quot;, list);
}
</code></pre>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h2><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>return its level order traversal as:</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre><pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;();

        if(root == null) return wrapList;

        queue.offer(root);
        while(!queue.isEmpty()){
            int levelNum = queue.size();
            List&lt;Integer&gt; subList = new LinkedList&lt;Integer&gt;();
            for(int i=0; i&lt;levelNum; i++) {
                if(queue.peek().left != null) queue.offer(queue.peek().left);
                if(queue.peek().right != null) queue.offer(queue.peek().right);
                subList.add(queue.poll().val);
            }
            wrapList.add(subList);
        }
        return wrapList;
    }
}
</code></pre>
<h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h2><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>return its zigzag level order traversal as:</p>
<pre><code>[
  [3],
  [20,9],
  [15,7]
]
</code></pre><pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    if(root == null){ return result;}
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
    queue.add(root);
    boolean reverseOrder = false;
    while(!queue.isEmpty()){
        int size = queue.size();
        List&lt;Integer&gt; levelResult = new ArrayList&lt;Integer&gt;();
        for(int i = 0; i &lt; size; i++){
            TreeNode temp = queue.remove();
            levelResult.add(temp.val);
            if(temp.left != null){ queue.add(temp.left);}
            if(temp.right != null){ queue.add(temp.right);}
        }
        if(reverseOrder){
            Collections.reverse(levelResult);
        }
        result.add(levelResult);
        reverseOrder = !reverseOrder;
    }
    return result;
}
}
</code></pre>
<h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a>199. Binary Tree Right Side View</h2><p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:

   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---
</code></pre><pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        if(root == null)return list;
        queue.offer(root);
        while(!queue.isEmpty()){
            int num = queue.size();
            for(int i = 0; i&lt;num; i++){
                if(queue.peek().left!=null)queue.offer(queue.peek().left);
                if(queue.peek().right!=null)queue.offer(queue.peek().right);
                if(i == num-1)list.add(queue.poll().val);
                else queue.poll();
            }
        }
        return list;
    }
}
</code></pre>
<h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a>347. Top K Frequent Elements</h2><p>Given a non-empty array of integers, return the <strong>k</strong> most frequent elements.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [1], k = 1
Output: [1]
</code></pre><p><strong>Note:</strong></p>
<ul>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li>
</ul>
<pre><code class="java">class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {

        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();

        // count frequency
        for(int n : nums){
            map.put(n, map.getOrDefault(n, 0) + 1);
        }

        // create priority queue, ordering map entries with respect to the frequency
        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = 
        new PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;()
        {
           @Override
           public int compare(Map.Entry&lt;Integer, Integer&gt; entry1, Map.Entry&lt;Integer, Integer&gt; entry2)
             {
                return entry2.getValue() - entry1.getValue();
             }
        });
        /*PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; maxHeap = 
        new PriorityQueue&lt;&gt;((a,b)-&gt;(b.getValue()-a.getValue()));
        */


        // insert in the queue
        for(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()){
            queue.offer(entry);
        }

        // poll the top k
        List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();
        for(int i = 0; i &lt; k; i ++){
            // Map.Entry&lt;Integer, Integer&gt; entry = queue.poll();
            list.add(queue.poll().getKey());
        }
        return list;
    } 
}
</code></pre>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>return its depth = 3.</p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null)return 0;

        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
}
</code></pre>
<h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>return its minimum depth = 2.</p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null)return 0;
        if(root.left == null &amp;&amp; root.right == null)return 1;
        else if(root.left == null) return minDepth(root.right)+1;
        else if(root.right == null) return minDepth(root.left)+1;
        else
        return Math.min(minDepth(root.left),minDepth(root.right)) + 1;
    }
}
</code></pre>
<h2 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h2><p>Invert a binary tree.</p>
<p><strong>Example:</strong></p>
<p>Input:</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>Output:</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><p><strong>Trivia:</strong><br>This problem was inspired by <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="noopener">this original tweet</a> by <a href="https://twitter.com/mxcl" target="_blank" rel="noopener">Max Howell</a>:</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
</blockquote>
<p>很逗哈哈</p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {

        if(root == null)return root;
        TreeNode tmp = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(tmp);
        return root;
    }
}
</code></pre>
<h2 id="Symmetric-Tree"><a href="#Symmetric-Tree" class="headerlink" title="Symmetric Tree"></a>Symmetric Tree</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre><p><strong>Note:</strong><br>Bonus points if you could solve it both recursively and iteratively.</p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
    return root==null || isSymmetricHelp(root.left, root.right);
    }

    private boolean isSymmetricHelp(TreeNode left, TreeNode right){
        if(left==null || right==null)
            return left==right;
        if(left.val!=right.val)
            return false;
        return 
            isSymmetricHelp(left.left, right.right) &amp;&amp; 
            isSymmetricHelp(left.right, right.left);
    }
}
</code></pre>
<h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a>222. Count Complete Tree Nodes</h2><p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p>
<p><strong>Note:</strong></p>
<p><strong>Definition of a complete binary tree from Wikipedia:</strong><br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: 
    1
   / \
  2   3
 / \  /
4  5 6

Output: 6
</code></pre><pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null)return 0;
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
</code></pre>
<h2 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. Balanced Binary Tree</h2><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>Return true.</p>
<p><strong>Example 2:</strong></p>
<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>
<pre><code>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
</code></pre><p>Return false.</p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    private boolean result = true;

    public boolean isBalanced(TreeNode root) {
        maxDepth(root);
        return result;
    }

    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        if (Math.abs(l - r) &gt; 1)
            result = false;
        return 1 + Math.max(l, r);
    }
}
</code></pre>
<h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a>112. Path Sum</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null)return false;
        sum = sum - root.val;
        if(root.left == null &amp;&amp; root.right == null)
            return sum == 0;
        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);
    }
}
</code></pre>
<h2 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a>404. Sum of Left Leaves</h2><p>Find the sum of all left leaves in a given binary tree.</p>
<p><strong>Example:</strong></p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
</code></pre><pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null)return 0;
        if(root.left == null)return sumOfLeftLeaves(root.right);
        TreeNode next = root.left;
        if(next.left == null &amp;&amp; next.right == null)
            return next.val + sumOfLeftLeaves(root.right);
        return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
    }
}
</code></pre>
<h2 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a>257. Binary Tree Paths</h2><p>Given a binary tree, return all root-to-leaf paths.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<pre><code>Input:

   1
 /   \
2     3
 \
  5

Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3
</code></pre><pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List&lt;String&gt; binaryTreePaths(TreeNode root) {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        if(root == null)return list;
        treePath(root, &quot;&quot;, list);
        return list;
    }

    public void treePath(TreeNode root, String path, List&lt;String&gt; list){
        if(root.left == null &amp;&amp; root.right == null)
            list.add(path + root.val);
        else if(root.left == null)
            treePath(root.right, path + root.val + &quot;-&gt;&quot;, list);
        else if(root.right == null)
            treePath(root.left, path + root.val + &quot;-&gt;&quot;, list);
        else {
            treePath(root.right, path + root.val + &quot;-&gt;&quot;, list);
            treePath(root.left, path + root.val + &quot;-&gt;&quot;, list);
        }
    }
}
</code></pre>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a>131. Palindrome Partitioning</h2><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of <em>s</em>.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: &quot;aab&quot;
Output:
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
</code></pre><pre><code class="java">class Solution {
    public List&lt;List&lt;String&gt;&gt; partition(String s) {
        List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();
        boolean[][] dp = new boolean[s.length()][s.length()];
        for(int i = 0; i &lt; s.length(); i++) {
            for(int j = 0; j &lt;= i; j++) {
                if(s.charAt(i) == s.charAt(j) &amp;&amp; (i - j &lt;= 2 || dp[j+1][i-1])) {
                    dp[j][i] = true;
                }
            }
        }
        helper(res, new ArrayList&lt;&gt;(), dp, s, 0);
        return res;
    }

    private void helper(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path, boolean[][] dp, String s, int pos) {
        if(pos == s.length()) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }

        for(int i = pos; i &lt; s.length(); i++) {
            if(dp[pos][i]) {
                path.add(s.substring(pos,i+1));
                helper(res, path, dp, s, i+1);
                path.remove(path.size()-1);
            }
        }
    }
}
</code></pre>
<pre><code class="java">public class Solution {
    public List&lt;List&lt;String&gt;&gt; partition(String s) {
        List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;List&lt;String&gt;&gt;();
        if(s.length()==0)return res;
        recur(res,new ArrayList&lt;String&gt;(),s);
        return res;
    }

    public void recur(List&lt;List&lt;String&gt;&gt; res,List&lt;String&gt; temp, String s){
        if(s.length()==0){
            res.add(new ArrayList&lt;String&gt;(temp));
            return;
        }
        for(int i=0;i&lt;s.length();i++){
            if(isPalin(s.substring(0,i+1))){
                temp.add(s.substring(0,i+1));
                recur(res,temp,s.substring(i+1));
                temp.remove(temp.size()-1);
            }
        }
    }

    public boolean isPalin(String s){
        for(int i=0;i&lt;s.length()/2;i++){
            if(s.charAt(i)!=s.charAt(s.length()-1-i))return false;
        }
        return true;
    }
}
</code></pre>
<h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();
        rec(list, nums, arr);
        return list;
    }

    public void rec(List&lt;List&lt;Integer&gt;&gt; list, int[] nums, List&lt;Integer&gt; arr){
        if(arr.size() == nums.length){
            list.add(new ArrayList&lt;&gt;(arr));
            // list.add(arr);
            return;
        }  
        for(int i = 0; i&lt;nums.length; i++){
            if(arr.contains(nums[i]))continue;
            arr.add(nums[i]);
            rec(list, nums, arr);
            arr.remove(arr.size()-1);
        }
    }
}
</code></pre>
<h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h2><p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 … <em>n</em>.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</code></pre><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {
        List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        rec(lists, list, 1, n, k);
        return lists;
    }
    public static void rec(List&lt;List&lt;Integer&gt;&gt; lists, List&lt;Integer&gt; list, int start, int n, int k){
        if(k == 0){
            lists.add(new ArrayList&lt;Integer&gt;(list));
            return;
        }
        for(int i = start; i &lt;= n; i++){
            list.add(i);
            rec(lists, list, i+1, n, k-1);
            list.remove(list.size()-1);
        }
    } 
}
</code></pre>
<h2 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h2><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        rec(lists, list, nums, 0);
        return lists;
    }
    public static void rec(List&lt;List&lt;Integer&gt;&gt; lists, List&lt;Integer&gt; list, int[] nums, int start){
        lists.add(new ArrayList&lt;Integer&gt;(list));
        for(int i = start; i&lt;nums.length; i++){
            list.add(nums[i]);
            rec(lists, list, nums, i+1);
            list.remove(list.size()-1);
        }
    }
}
</code></pre>
<h2 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h2><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p>
<p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</code></pre><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        Arrays.sort(nums);
        rec(lists, list, nums, 0);
        return lists;
    }
    public static void rec(List&lt;List&lt;Integer&gt;&gt; lists, List&lt;Integer&gt; list, int[] nums, int start){
        if(!lists.contains(new ArrayList&lt;Integer&gt;(list)))
            lists.add(new ArrayList&lt;Integer&gt;(list));
        for(int i = start; i&lt;nums.length; i++){
            list.add(nums[i]);
            rec(lists, list, nums, i+1);
            list.remove(list.size()-1);
        }
    }
}
</code></pre>
<h2 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p><strong>Example:</strong></p>
<pre><code>board =
[
  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],
  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],
  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]
]

Given word = &quot;ABCCED&quot;, return true.
Given word = &quot;SEE&quot;, return true.
Given word = &quot;ABCB&quot;, return false.
</code></pre><pre><code class="java">class Solution {
    public boolean exist(char[][] board, String word) {
        for(int i = 0; i&lt;board.length; i++){
            for(int j = 0; j&lt;board[0].length; j++){
                if(search(board, word, i, j, 0))
                    return true;
            }
        }
        return false;
    }
    public static boolean search(char[][] board, String word, int x, int y, int pos){
        int high = board.length;
        int width = board[0].length;

        if(x &gt;= high || x &lt; 0 || y &gt;= width || y &lt; 0)
            return false;
        if(pos == word.length()-1)
           return board[x][y] == word.charAt(pos);
        if(!(board[x][y] == word.charAt(pos)))
            return false;

        char save = board[x][y];
        board[x][y] = &#39;1&#39;;
        boolean res =    
            search(board, word, x - 1, y, pos + 1) || 
            search(board, word, x, y - 1, pos + 1) ||
            search(board, word, x + 1, y, pos + 1) ||
            search(board, word, x, y + 1, pos + 1);
        board[x][y] = save;
        return res;
    }
}
</code></pre>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h2><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</code></pre><pre><code class="java">class Solution {
    public int climbStairs(int n) {
        if(n==1)return 1;
        if(n==2)return 2;
        return climbStairs(n-1)+climbStairs(n-2);
    }
}
</code></pre>
<p>递归实现</p>
<pre><code class="java">class Solution {
    public int climbStairs(int n) {
        if(n==1)return 1;
        if(n==2)return 2;
        int[] tmp = new int[n];
        tmp[0]=1;
        tmp[1]=2;
        for(int i = 2; i&lt;n; i++){
            tmp[i]=tmp[i-1]+tmp[i-2];
        }
        return tmp[n-1];
    }
}
</code></pre>
<p>动态规划实现</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="/2019/07/03/algo/dp0.jpg" alt="dp0"></p>
<p>贪心算法无法得到最优解</p>
<p><img src="/2019/07/03/algo/dp1.jpg" alt="dp1"></p>
<p>递归解决</p>
<pre><code class="java">public static int maxbag(int[] w, int[] v, int index, int c){
        if(index &lt; 0 || c &lt;=0)return 0;
        int res = maxbag(w,v,index-1,c);
        if(c&gt;=w[index])
            res = Math.max(res, v[index]+maxbag(w,v,index-1,c-w[index]));
        return res;
    }

    public static void main(String[] args) {
        int[] w = new int[]{1,2,5};
        int[] v = new int[]{4,5,5};
        int index = w.length;
        int max = maxbag(w,v,index-1,1);
        System.out.println(max);
    }
</code></pre>
<p>记忆化</p>
<pre><code class="java">    private static int[][] memo;

    public static int maxbag(int[] w, int[] v, int index, int c){

        if(index &lt; 0 || c &lt;=0)return 0;
        if(memo[index][c]!=-1)return memo[index][c];
        int res = maxbag(w,v,index-1,c);
        if(c&gt;=w[index])
            res = Math.max(res, v[index]+maxbag(w,v,index-1,c-w[index]));
        memo[index][c] = res;
        return res;
    }

    public static void main(String[] args) {
        int[] w = new int[]{1,2,5};
        int[] v = new int[]{4,5,5};
        int index = w.length;
        int c = 8;
        memo= new int[index][c+1];
        for (int i = 0; i&lt;index; i++)
            for(int j = 0; j&lt;c+1; j++)
                memo[i][j] = -1;
        int max = maxbag(w,v,index-1,c);
        System.out.println(max);
    }
</code></pre>
<p>动态规划</p>
<pre><code class="java">public static void main(String[] args) {
        int[] w = new int[]{1,2,5};
        int[] v = new int[]{4,5,5};
        int index = w.length;
        int c = 8;
        int[][] memo= new int[index][c+1];

        for (int j = 0; j&lt;=c; j++)
            memo[0][j] = j&gt;=w[0] ? v[0] : 0;
        for (int i = 1; i&lt;index; i++)
            for (int j = 0; j&lt;=c; j++){
                memo[i][j] = memo[i-1][j];
                if(j&gt;=w[i]) memo[i][j] = Math.max(memo[i][j],v[i]+memo[i-1][j-w[i]]);
            }
        System.out.println(memo[index-1][c]);
}
</code></pre>
<h2 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a>416. Partition Equal Subset Sum</h2><p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p><strong>Note:</strong></p>
<ol>
<li>Each of the array element will not exceed 100.</li>
<li>The array size will not exceed 200.</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.
</code></pre><p>动态规划</p>
<pre><code class="java">class Solution {
    public boolean canPartition(int[] nums) {

        int len = nums.length;
        int sum = 0;
        for(int i = 0; i&lt;len; i++)sum += nums[i];
        if(sum%2!=0)return false;
        sum /= 2;

        boolean[][] memo = new boolean[len][sum+1];
        for(int j = 0; j&lt;=sum; j++) memo[0][j] = (nums[0]==j ? true : false);
        for(int i = 1; i&lt;len; i++)
            for(int j = 0; j&lt;=sum; j++){
                memo[i][j] = memo[i-1][j];
                if(j&gt;=nums[i])
                memo[i][j] = memo[i-1][j] || memo[i-1][j-nums[i]]; 
            }
        return memo[len-1][sum];       
    }
}
</code></pre>
<p>递归</p>
<pre><code class="java">class Solution {
    public boolean canPartition(int[] nums) {

        int len = nums.length;
        int sum = 0;
        for(int i = 0; i&lt;len; i++)sum += nums[i];
        if(sum%2!=0)return false;
        sum /= 2;
        return asPart(nums, len-1, sum);
    }

    public boolean asPart(int[] nums,int index, int sum){
        if(sum==0)return true;
        if(sum&lt;0)return false;
        if(index &lt;= 0)return false;
        return 
            asPart(nums, index-1, sum) || asPart(nums, index-1, sum-nums[index]); 
    }    
}
</code></pre>
<p>记忆化递归</p>
<pre><code class="java">class Solution {
    private static int[][] memo;
    public boolean canPartition(int[] nums) {

        int len = nums.length;
        int sum = 0;
        for(int i = 0; i&lt;len; i++)sum += nums[i];
        if(sum%2!=0)return false;
        sum /= 2;
        memo = new int[len][sum+1];
        for(int i = 0; i&lt;len; i++)
            for(int j = 0; j&lt;=sum; j++)
                memo[i][j]=-1;
        return asPart(nums, len-1, sum);
    }

    public boolean asPart(int[] nums,int index, int sum){
        if(sum==0)return true;
        if(sum&lt;0)return false;
        if(index &lt;= 0)return false;
        if(memo[index][sum]!=-1)return memo[index][sum]==1;
        memo[index][sum] = 
            asPart(nums,index-1,sum)||asPart(nums,index-1,sum-nums[index])?1:0;
        return memo[index][sum]==1; 
    }    
}
</code></pre>
<h2 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h2><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: coins = [2], amount = 3
Output: -1
</code></pre><p><strong>Note</strong>:<br>You may assume that you have an infinite number of each kind of coin.</p>
<pre><code class="java">class Solution {
    public int coinChange(int[] coins, int amount) {
        int min = Integer.MAX_VALUE;
        int total = 1;
        int[] dp = new int[amount + 1];
        dp[0] = 0;
        while (total &lt;= amount) {
            min = Integer.MAX_VALUE;
            for (int i = 0; i &lt; coins.length; i++) {
                int diff = total - coins[i];
                if (diff &gt; 0 &amp;&amp; dp[diff] &gt; 0 || diff == 0) {
                    min = Math.min(min, dp[diff] + 1);
                }
            }
            dp[total++] = (min == Integer.MAX_VALUE ? -1 : min);
        }
        return dp[amount];
    }
}
</code></pre>
<p>总量和元素的内外循环，要看清界定条件，比如所有同一总量结果比较，或者所有同一元素结果比较。</p>
<h2 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h2><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
</code></pre><p><strong>Note:</strong></p>
<ul>
<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>
<li>Your algorithm should run in O(<em>n2</em>) complexity.</li>
</ul>
<p><strong>Follow up:</strong> Could you improve it to O(<em>n</em> log <em>n</em>) time complexity?</p>
<pre><code class="java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if(len&lt;1)return 0;
        int[] dp = new int[len];
        for(int i = 0; i&lt;len; i++)dp[i]=1;
        for(int i = 1; i&lt;len; i++){
            for(int j = 0; j&lt;i; j++){
                if(nums[i]&gt;nums[j])dp[i]=Math.max(dp[j]+1,dp[i]);
            }
        }
        int max = 0;
        for(int x : dp)
            max = Math.max(max,x);
        return max;
    }
}
</code></pre>
<h2 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h2><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: n = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
</code></pre><pre><code class="java">public class Solution {
    public int numSquares(int n) {
       int[] dp = new int[n + 1];
       Arrays.fill(dp, Integer.MAX_VALUE);
       dp[0] = 0;
       for(int i = 0; i &lt;= n; i++){
           for(int j = 1; i + j * j &lt;= n; j++){
               dp[i  + j * j] = Math.min(dp[i + j * j], dp[i] + 1);
            }
       }
       return dp[n];
    }
}
</code></pre>
<h1 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h1><h2 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a>455. Assign Cookies</h2><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<p><strong>Note:</strong><br>You may assume the greed factor is always positive.<br>You cannot assign more than one cookie to one child.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1,2,3], [1,1]

Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [1,2], [1,2,3]

Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.
</code></pre><pre><code class="java">class Solution {
    public int findContentChildren(int[] g, int[] s) {
        int leng = g.length-1; //children
        int lens = s.length-1; //cookies
        Arrays.sort(g);
        Arrays.sort(s);
        int out = 0;
        while(lens&gt;-1&amp;&amp;leng&gt;-1){
            if(s[lens]&gt;=g[leng]){
                lens--;
                out++;
                leng--;
            }
            else leng--;
        }
        return out;      
    }
}
</code></pre>
<h2 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a>435. Non-overlapping Intervals</h2><p>Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<p><strong>Note:</strong></p>
<ol>
<li>You may assume the interval’s end point is always bigger than its start point.</li>
<li>Intervals like [1,2] and [2,3] have borders “touching” but they don’t overlap each other.</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [ [1,2], [2,3], [3,4], [1,3] ]

Output: 1

Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [ [1,2], [1,2], [1,2] ]

Output: 2

Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: [ [1,2], [2,3] ]

Output: 0

Explanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.
</code></pre><p>DP：</p>
<pre><code class="java">/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
class Solution {
    public int eraseOverlapIntervals(Interval[] intervals) {
        if(intervals.length&lt;=1)return 0;
        Arrays.sort(intervals, new Comparator&lt;Interval&gt;() {
            @Override
            public int compare(Interval o1, Interval o2) {
                if(o1.start != o2.start)
                return o1.start - o2.start;
                return o1.end - o2.end;
            }
        });
        int[] dp = new int[intervals.length];
        for(int i = 0; i&lt;dp.length; i++) dp[i]=1;
        for(int i = 1; i&lt;intervals.length; i++){
            for(int j = 0; j&lt;i; j++){
                if(intervals[i].start&gt;=intervals[j].end)
                    dp[i] = Math.max(dp[j]+1,dp[i]);
            }
        }
        int max = 0;
        for(int x : dp)max = Math.max(max,x);
        return intervals.length-max;          
    }
}
</code></pre>
<p>Greedy </p>
<pre><code class="java">public class Solution {
    public int eraseOverlapIntervals(Interval[] intervals) {
        if(intervals.length &lt;= 0) return 0;
        Arrays.sort(intervals, (Interval a,Interval b) -&gt; a.end - b.end);
        int border = intervals[0].end;
        int erase = 0;
        for(int i = 1; i &lt; intervals.length; i++) {
            if(intervals[i].start &lt; border) erase++;
            else {
                border = intervals[i].end;
            }
        }
        return erase;
    }
}
</code></pre>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop basic concept</title>
    <url>/2019/02/01/hadoop/</url>
    <content><![CDATA[<h1 id="HADOOP"><a href="#HADOOP" class="headerlink" title="HADOOP"></a>HADOOP</h1><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>master/slave architecture</li>
</ul>
<ul>
<li>an HDFS cluster has one master(NameNode/NN)  -  N slaves(DataNode/DN)</li>
<li>一个文件拆分成多个block，分散存储</li>
<li>NN：负责客户端请求响应，元数据管理（文件名称、副本系数、DN地址）</li>
<li>DN：存储对应Block，心跳信息，健康状况</li>
<li>一个文件的Block只有最后一个可能大小不同</li>
<li>Files in HDFS are write-once  and have strictly one writer at any time</li>
</ul>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li><p>CDH download <a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/</a> + filename</p>
</li>
<li><p>JDK</p>
</li>
<li><p>SSH 免密</p>
</li>
<li><p>下载hadoop解压</p>
</li>
<li><p>修改java_home, core-site.xml, hdfs-site.xml, slave</p>
</li>
<li><pre><code>$ bin/hdfs namenode -format
</code></pre></li>
<li><pre><code> $ sbin/start-dfs.sh
</code></pre><h3 id="shell操作"><a href="#shell操作" class="headerlink" title="shell操作"></a>shell操作</h3></li>
<li><p>hadoop fs -command</p>
</li>
<li>hdfs dfs -command</li>
<li>添加hadoop/bin到环境变量~/.bash_profile     source</li>
</ul>
<h3 id="Java-API操作"><a href="#Java-API操作" class="headerlink" title="Java API操作"></a>Java API操作</h3><ul>
<li>maven导入对应版本依赖</li>
</ul>
<h2 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h2><h3 id="YARN架构"><a href="#YARN架构" class="headerlink" title="YARN架构"></a>YARN架构</h3><ul>
<li><p>ResourceManager: RM</p>
<p>同一时间一个集群只有一个（有备份）</p>
<p>处理客户端请求：提交作业，杀死作业</p>
<p>监控NM，挂了重新处理</p>
</li>
<li><p>NodeManager: NM</p>
<p>集群中有多个，负责本身节点资源管理</p>
<p>定时向RM汇报本节点资源使用情况</p>
<p>接受并处理来自RM的命令：启动Container</p>
<p>处理来自AM的命令</p>
</li>
<li><p>ApplicationMaster: AM</p>
<p>每个应用程序对应一个：MapReduce, Spark，负责应用程序管理</p>
<p>为应用程序向RM申请资源（core, memory），分配给内部Task</p>
<p>需要与NM通信：启动，停止task，task运行于container中</p>
</li>
<li><p>Container</p>
<p>封装CPU，Memory等资源的容器</p>
</li>
<li><p>Client</p>
<p>提交、查看、杀死作业</p>
</li>
</ul>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><ul>
<li>Input</li>
<li>Splitting</li>
<li>Mapping</li>
<li>Shuffling</li>
<li>Reducing</li>
<li>Final Result</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>Split：交由MapReduce作业处理的最小计算单元</p>
<p>默认与HDFS blocksize（最小存储单元）对应</p>
</li>
<li><p>InputFormat：将输入的数据进行分片（split）</p>
<p>TextInputFormat：处理文本格式数据</p>
</li>
<li><p>OutputFormat：结果数据</p>
</li>
<li><p>Combiner：本地的Reduce，减少MapTask输出数据量</p>
</li>
<li><p>Partitioner：规定MapTask输出的数据交由哪个ReduceTask处理</p>
</li>
</ul>
<h3 id="MapReduce1-x架构"><a href="#MapReduce1-x架构" class="headerlink" title="MapReduce1.x架构"></a>MapReduce1.x架构</h3><ul>
<li><p>JobTracker：JT</p>
<p>作业管理者</p>
<p>将作业分解成多个任务：Task（MapTask，ReduceTaask）</p>
<p>将任务分派给TaskTracker运行</p>
<p>作业的监控、容错处理（Task作业挂了，重新指派）</p>
<p>接受TT心跳</p>
</li>
<li><p>TaskTracker：TT</p>
<p>任务执行者</p>
<p>与JT交互</p>
</li>
<li><p>MapTask</p>
<p>解析数据，交给自己的map方法</p>
<p>将map输出结果写到本地磁盘（如果没有Reduce，则写入HDFS）</p>
</li>
<li><p>ReduceTask</p>
<p>将MapTask输出的数据进行读取</p>
<p>按照数据进行分组传给自己的reduce方法处理</p>
<p>输出结果到HDFS</p>
</li>
</ul>
<h3 id="MapReduce2-x架构"><a href="#MapReduce2-x架构" class="headerlink" title="MapReduce2.x架构"></a>MapReduce2.x架构</h3><ul>
<li>同YARN</li>
</ul>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="日志数据内容"><a href="#日志数据内容" class="headerlink" title="日志数据内容"></a>日志数据内容</h3><ul>
<li>访问系统属性</li>
<li>访问特征：URL，停留时间</li>
<li>访问信息：session_id，ip</li>
<li>Nginx记录</li>
</ul>
<h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><ul>
<li><p>数据采集</p>
<p>Flume：web日志写入HDFS</p>
</li>
<li><p>数据清洗</p>
<p>剔除脏数据：Spark，Hive，MapReduce</p>
</li>
<li><p>数据处理</p>
<p>Spark，Hive，MapReduce</p>
</li>
<li><p>处理结果入库</p>
<p>RDBMS，NoSQL</p>
</li>
<li><p>数据可视化</p>
<p>图形化展示，渲染：ECharts、HUE、Zeppelin</p>
</li>
</ul>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MapReduce</tag>
        <tag>Hadoop</tag>
        <tag>Yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang Basic</title>
    <url>/2019/06/15/golang/</url>
    <content><![CDATA[<h1 id="Golang语法"><a href="#Golang语法" class="headerlink" title="Golang语法"></a>Golang语法</h1><ul>
<li>无对象、无继承多态、无泛型</li>
<li>有接口，函数式编程，CSP并发模型</li>
</ul>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul>
<li><p>(u)int,(u)int8,(u)int16,(u)int32,(u)int64</p>
<p>有符号、无符号整数，默认长度同os</p>
</li>
<li><p>uintptr            指针</p>
</li>
<li>bool，string，byte</li>
<li>rune字符型，相当于32位char</li>
<li>float32，float64</li>
<li>complex64，complex128复数</li>
</ul>
<p>强制转换方法相同</p>
<p>常量类型：const</p>
<p>枚举类型，iota：自增</p>
<pre><code class="go">func enums()  {
    const
    (
        cpp = iota
        java
        python
        php
    )
    fmt.Println(cpp, java, python, php)
}

0 1 2 3
</code></pre>
<pre><code class="go">const (
        b = 1&lt;&lt;(10*iota)
        kb
        mb
        gb
        tb
        pb
    )
    fmt.Println(b,kb,mb,gb,tb,pb)

1 1024 1048576 1073741824 1099511627776 1125899906842624
</code></pre>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>go语言函数可以返回两个值</p>
<p>条件语句 if 条件没有括号，条件可以定义变量</p>
<pre><code class="go">import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    )
func main() {

    const filename  = &quot;abc.txt&quot;
    contents, err := ioutil.ReadFile(filename)
    if err!= nil {
        fmt.Println(err)
    }else {
        fmt.Println(&quot;%s\n&quot;,contents)
    }
}
</code></pre>
<pre><code class="go">import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
)
func main() {

    const filename  = &quot;abc.txt&quot;
    if contents, err := ioutil.ReadFile(filename) ; err != nil{
        fmt.Println(err)
    }else {
        fmt.Println(contents)
    }
}
</code></pre>
<p>switch,没有break</p>
<p><img src="/2019/06/15/golang/g1.jpg" alt="g1"></p>
<p>switch后可以没有表达式，在case中加入条件</p>
<p><img src="/2019/06/15/golang/g2.jpg" alt="g2"></p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>golang没有while</p>
<p>for循环</p>
<pre><code class="go">func convert2bin(n int)  string{
    result := &quot;&quot;
    for ; n &gt; 0 ; n /= 2  {
        lsb := n % 2
        result = strconv.Itoa(lsb) + result
    }
    return result
}
</code></pre>
<p><img src="/2019/06/15/golang/g3.jpg" alt="g3"></p>
<p>死循环</p>
<pre><code class="go">for{
    fmt.Println(&quot;abc&quot;)
}
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以返回多个值</p>
<pre><code class="go">func div(a,b int) (int, int) {
    return a/b, a%b
}
</code></pre>
<pre><code class="go">func divp(a,b int) (q,r int) {
    q = a/b
    r = a%b
    return 
}
</code></pre>
<p>定义的值必须用到，如果不想用则使用 _</p>
<p>返回error，方便处理</p>
<p><img src="/2019/06/15/golang/g4.jpg" alt="g4"></p>
<p>函数式编程，参数可以是函数</p>
<p><img src="/2019/06/15/golang/g5.jpg" alt="g5"></p>
<p>其他用法：可变参数列表</p>
<p><img src="/2019/06/15/golang/g6.jpg" alt="g6"></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针不能运算</p>
<p><img src="/2019/06/15/golang/g7.jpg" alt="g7"></p>
<p>go语言只有值传递，没有引用传递</p>
<p>交换ab：</p>
<pre><code class="go">func swap(a, b int){
    b, a = a, b
}
swap(a,b)
func swap(a, b *int){
    *b, *a = *a, *b
}
swap(&amp;a,&amp;b)
func swap(a, b int)(int, int){
return b,a
}
a, b = swap(a,b)
</code></pre>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>定义数组</p>
<pre><code class="go">package main

import &quot;fmt&quot;
func main() {
    var arr1 [3]int
    var arr2 = [3]int {1,2,3}
    arr3 := [...]int {1,2,3,4,5}

    fmt.Println(arr1,arr2,arr3)
}

[0 0 0] [1 2 3] [1 2 3 4 5]
</code></pre>
<pre><code class="go">import &quot;fmt&quot;

func main() {
    var grid [4][5]int
    fmt.Println(grid)
}

[[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]]
</code></pre>
<p>遍历数组</p>
<pre><code class="go">func main() {
    arr3 := [...]int {1,2,3,4,5}
    for i := 0;i&lt;len(arr3) ;i++  {
        fmt.Println(arr3[i])
    }
}
</code></pre>
<p>使用range遍历</p>
<pre><code class="go">import &quot;fmt&quot;

func main() {
    arr3 := [...]int {1,2,3,4,5}
    for i := range arr3  {
        fmt.Println(arr3[i])
    }
}
</code></pre>
<p><img src="/2019/06/15/golang/g8.jpg" alt="g8"></p>
<pre><code class="go">func main() {
    arr3 := [...]int {1,2,3,4,5}
    for i := range arr3  {
        fmt.Println(i)
    }
    for _,v := range arr3  {
        fmt.Println(v)
    }
}
</code></pre>
<p>数组是值类型，不会改变数组本身</p>
<p>go语言一般不直接使用数组</p>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p><img src="/2019/06/15/golang/g9.jpg" alt="g9"></p>
<p>slice是原本array的一个view，array改变后，slice也跟着改变</p>
<pre><code class="go">import &quot;fmt&quot;

func updateSlice(s []int) {
    s[0] = 100
}

func main() {
    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}

    fmt.Println(&quot;arr[2:6] =&quot;, arr[2:6])
    fmt.Println(&quot;arr[:6] =&quot;, arr[:6])
    s1 := arr[2:]
    fmt.Println(&quot;s1 =&quot;, s1)
    s2 := arr[:]
    fmt.Println(&quot;s2 =&quot;, s2)

    fmt.Println(&quot;After updateSlice(s1)&quot;)
    updateSlice(s1)
    fmt.Println(s1)
    fmt.Println(arr)

    fmt.Println(&quot;After updateSlice(s2)&quot;)
    updateSlice(s2)
    fmt.Println(s2)
    fmt.Println(arr)

    fmt.Println(&quot;Reslice&quot;)
    fmt.Println(s2)
    s2 = s2[:5]
    fmt.Println(s2)
    s2 = s2[2:]
    fmt.Println(s2)

    fmt.Println(&quot;Extending slice&quot;)
    arr[0], arr[2] = 0, 2
    fmt.Println(&quot;arr =&quot;, arr)
    s1 = arr[2:6]
    s2 = s1[3:5] // [s1[3], s1[4]]
    fmt.Printf(&quot;s1=%v, len(s1)=%d, cap(s1)=%d\n&quot;,
        s1, len(s1), cap(s1))
    fmt.Printf(&quot;s2=%v, len(s2)=%d, cap(s2)=%d\n&quot;,
        s2, len(s2), cap(s2))

    s3 := append(s2, 10)
    s4 := append(s3, 11)
    s5 := append(s4, 12)
    fmt.Println(&quot;s3, s4, s5 =&quot;, s3, s4, s5)
    // s4 and s5 no longer view arr.
    fmt.Println(&quot;arr =&quot;, arr)

    // Uncomment to run sliceOps demo.
    // If we see undefined: sliceOps
    // please try go run slices.go sliceops.go
    fmt.Println(&quot;Uncomment to see sliceOps demo&quot;)
    // sliceOps()
}

</code></pre>
<p><img src="/2019/06/15/golang/g11.jpg" alt="g11"></p>
<p>reslice</p>
<p><img src="/2019/06/15/golang/g10.jpg" alt="g10"></p>
<p>slice结构</p>
<p><img src="/2019/06/15/golang/g12.jpg" alt="g12"></p>
<p>s[i]超过len会报错越界，向后扩展不能超过cap</p>
<p>slice可以向后扩展，不能向前扩展</p>
<p>slice末尾追加元素，依次追加，但是原始arr到cap不再增加，会自动生成一个更大的数组</p>
<p><img src="/2019/06/15/golang/g13.jpg" alt="g13"></p>
<p>内建函数make，代表len，cap</p>
<pre><code class="go">s2 := make([]int, 16)
s3 := make([]int, 10, 32)
</code></pre>
<pre><code class="go">package main

import &quot;fmt&quot;

func printSlice(s []int) {
    fmt.Printf(&quot;%v, len=%d, cap=%d\n&quot;,
        s, len(s), cap(s))
}

func sliceOps() {
    fmt.Println(&quot;Creating slice&quot;)
    var s []int // Zero value for slice is nil

    for i := 0; i &lt; 100; i++ {
        printSlice(s)
        s = append(s, 2*i+1)
    }
    fmt.Println(s)

    s1 := []int{2, 4, 6, 8}
    printSlice(s1)

    s2 := make([]int, 16)
    s3 := make([]int, 10, 32)
    printSlice(s2)
    printSlice(s3)

    fmt.Println(&quot;Copying slice&quot;)
    copy(s2, s1)
    printSlice(s2)

    fmt.Println(&quot;Deleting elements from slice&quot;)
    s2 = append(s2[:3], s2[4:]...)
    printSlice(s2)

    fmt.Println(&quot;Popping from front&quot;)
    front := s2[0]
    s2 = s2[1:]

    fmt.Println(front)
    printSlice(s2)

    fmt.Println(&quot;Popping from back&quot;)
    tail := s2[len(s2)-1]
    s2 = s2[:len(s2)-1]

    fmt.Println(tail)
    printSlice(s2)
}
</code></pre>
<p><img src="/2019/06/15/golang/g14.jpg" alt="g14"></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre><code class="go">package main

import &quot;fmt&quot;

func main() {
    m := map[string]string{
        &quot;name&quot;:    &quot;ccmouse&quot;,
        &quot;course&quot;:  &quot;golang&quot;,
        &quot;site&quot;:    &quot;imooc&quot;,
        &quot;quality&quot;: &quot;notbad&quot;,
    }

    m2 := make(map[string]int) // m2 == empty map

    var m3 map[string]int // m3 == nil

    fmt.Println(&quot;m, m2, m3:&quot;)
    fmt.Println(m, m2, m3)

    fmt.Println(&quot;Traversing map m&quot;)
    for k, v := range m {
        fmt.Println(k, v)
    }

    fmt.Println(&quot;Getting values&quot;)
    courseName := m[&quot;course&quot;]
    fmt.Println(`m[&quot;course&quot;] =`, courseName)
    if causeName, ok := m[&quot;cause&quot;]; ok {
        fmt.Println(causeName)
    } else {
        fmt.Println(&quot;key &#39;cause&#39; does not exist&quot;)
    }

    fmt.Println(&quot;Deleting values&quot;)
    name, ok := m[&quot;name&quot;]
    fmt.Printf(&quot;m[%q] before delete: %q, %v\n&quot;,
        &quot;name&quot;, name, ok)

    delete(m, &quot;name&quot;)
    name, ok = m[&quot;name&quot;]
    fmt.Printf(&quot;m[%q] after delete: %q, %v\n&quot;,
        &quot;name&quot;, name, ok)
}
</code></pre>
<p><img src="/2019/06/15/golang/g15.jpg" alt="g15"></p>
<p>遍历map是无序的</p>
<p>去拿不存在的key，得到zero value空值</p>
<p>可以用causeName, ok := m[“cause”]判断是否存在</p>
<p>map使用哈希表，可以比较相等</p>
<p>除了slice、map、function的内建类型都可以作为key</p>
<p>struct类型也可以作为key</p>
<h2 id="寻找最长不重复子串"><a href="#寻找最长不重复子串" class="headerlink" title="寻找最长不重复子串"></a>寻找最长不重复子串</h2><p>abcabcbb        -&gt;        abc</p>
<p><img src="/2019/06/15/golang/g16.jpg" alt="g16"></p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func lengthOfNonRepeatingSubStr(s string) int {
    lastOccurred := make(map[rune]int)
    start := 0
    maxLength := 0

    for i, ch := range []rune(s) {
        if lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start {
            start = lastI + 1
        }
        if i-start+1 &gt; maxLength {
            maxLength = i - start + 1
        }
        lastOccurred[ch] = i
    }

    return maxLength
}

func main() {
    fmt.Println(
        lengthOfNonRepeatingSubStr(&quot;abcabcbb&quot;))
    fmt.Println(
        lengthOfNonRepeatingSubStr(&quot;bbbbb&quot;))
    fmt.Println(
        lengthOfNonRepeatingSubStr(&quot;pwwkew&quot;))
    fmt.Println(
        lengthOfNonRepeatingSubStr(&quot;&quot;))
    fmt.Println(
        lengthOfNonRepeatingSubStr(&quot;b&quot;))
    fmt.Println(
        lengthOfNonRepeatingSubStr(&quot;abcdef&quot;))
    fmt.Println(
        lengthOfNonRepeatingSubStr(&quot;这里是慕课网&quot;))
    fmt.Println(
        lengthOfNonRepeatingSubStr(&quot;一二三二一&quot;))
    fmt.Println(
        lengthOfNonRepeatingSubStr(
            &quot;黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花&quot;))
}
</code></pre>
<p>中文使用byte会出现问题，因而进行改进</p>
<p>国际化支持:</p>
<p>for i, ch := range []rune(s)</p>
<p>使用range遍历pos，rune对，但是pos不连续</p>
<p>真正的字符数量utf8.RuneCountInString可获得</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="值接受和指针接受"><a href="#值接受和指针接受" class="headerlink" title="值接受和指针接受"></a>值接受和指针接受</h2><p>go对象仅支持封装、不支持继承多态</p>
<pre><code class="go">package tree

import &quot;fmt&quot;

type Node struct {
    Value       int
    Left, Right *Node
}

func (node Node) Print() {
    fmt.Print(node.Value, &quot; &quot;)
}

func (node *Node) SetValue(value int) {
    if node == nil {
        fmt.Println(&quot;Setting Value to nil &quot; +
            &quot;node. Ignored.&quot;)
        return
    }
    node.Value = value
}

func CreateNode(value int) *Node {
    return &amp;Node{Value: value}
}
</code></pre>
<pre><code class="go">package tree

import &quot;fmt&quot;

func (node *Node) Traverse() {
    node.TraverseFunc(func(n *Node) {
        n.Print()
    })
    fmt.Println()
}

func (node *Node) TraverseFunc(f func(*Node)) {
    if node == nil {
        return
    }

    node.Left.TraverseFunc(f)
    f(node)
    node.Right.TraverseFunc(f)
}

func (node *Node) TraverseWithChannel() chan *Node {
    out := make(chan *Node)
    go func() {
        node.TraverseFunc(func(node *Node) {
            out &lt;- node
        })
        close(out)
    }()
    return out
}
</code></pre>
<p>无论是指针函数还是值函数，调用上都没有区别</p>
<p>值接受者是go语言特有的</p>
<p>使用指针接受者的情况：</p>
<ul>
<li>改变内容必须使用指针接收者</li>
<li>结构过大考虑使用指针接收者</li>
<li>如果有指针接收者，最好都采用指针接收者</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>一般采用驼峰规则</p>
<p>首字母大写表示public，首字母小写表示private</p>
<p>包：</p>
<ul>
<li>每个目录一个包</li>
<li>main包包含可执行入口</li>
<li>为结构定义的方法必须在同一个包内，可以在不同的文件</li>
</ul>
<p>如何扩充系统的类或者别人的类：</p>
<ul>
<li>定义别名</li>
<li>使用组合</li>
</ul>
<p>使用组合：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;

    &quot;imooc.com/ccmouse/learngo/tree&quot;
)

type myTreeNode struct {
    node *tree.Node
}

func (myNode *myTreeNode) postOrder() {
    if myNode == nil || myNode.node == nil {
        return
    }

    left := myTreeNode{myNode.node.Left}
    right := myTreeNode{myNode.node.Right}

    left.postOrder()
    right.postOrder()
    myNode.node.Print()
}

func main() {
    var root tree.Node

    root = tree.Node{Value: 3}
    root.Left = &amp;tree.Node{}
    root.Right = &amp;tree.Node{5, nil, nil}
    root.Right.Left = new(tree.Node)
    root.Left.Right = tree.CreateNode(2)
    root.Right.Left.SetValue(4)

    fmt.Print(&quot;In-order traversal: &quot;)
    root.Traverse()

    fmt.Print(&quot;My own post-order traversal: &quot;)
    myRoot := myTreeNode{&amp;root}
    myRoot.postOrder()
    fmt.Println()

    nodeCount := 0
    root.TraverseFunc(func(node *tree.Node) {
        nodeCount++
    })
    fmt.Println(&quot;Node count:&quot;, nodeCount)

    c := root.TraverseWithChannel()
    maxNodeValue := 0
    for node := range c {
        if node.Value &gt; maxNodeValue {
            maxNodeValue = node.Value
        }
    }
    fmt.Println(&quot;Max node value:&quot;, maxNodeValue)
}
</code></pre>
<p>通过别名方法：</p>
<pre><code class="go">package queue

// A FIFO queue.
type Queue []int

// Pushes the element into the queue.
//         e.g. q.Push(123)
func (q *Queue) Push(v int) {
    *q = append(*q, v)
}

// Pops element from head.
func (q *Queue) Pop() int {
    head := (*q)[0]
    *q = (*q)[1:]
    return head
}

// Returns if the queue is empty or not.
func (q *Queue) IsEmpty() bool {
    return len(*q) == 0
}
</code></pre>
<h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>src    源代码</p>
<p>pkg    中间包</p>
<p>bin    可执行文件</p>
<p>建议所有项目和第三方库放在一个GOPATH下</p>
<p>可以通过go get 获取第三方库</p>
<p>墙内通过镜像拉取：</p>
<blockquote>
<p>go get -v github.com/gpmgo/gopm</p>
</blockquote>
<blockquote>
<p>gopm update</p>
</blockquote>
<blockquote>
<p>gopm get -g -v uri</p>
</blockquote>
<blockquote>
<p>go build / install</p>
</blockquote>
<blockquote>
<p>go run </p>
</blockquote>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>duck typing 描述事物外部行为而非内部结构</p>
<h2 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a>接口的定义和实现</h2><p>接口的定义：接口由使用者定义（与传统相反）</p>
<p>只要实现了相应方法，就被判定为实现了接口，不需要声明实现了哪个接口</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

type Phone interface {
    call()
}

type NokiaPhone struct {
}

func (nokiaPhone NokiaPhone) call() {
    fmt.Println(&quot;I am Nokia, I can call you!&quot;)
}

type IPhone struct {
}

func (iPhone IPhone) call() {
    fmt.Println(&quot;I am iPhone, I can call you!&quot;)
}

func main() {
    var phone Phone

    phone = new(NokiaPhone)
    phone.call()

    phone = new(IPhone)
    phone.call()

}
</code></pre>
<h2 id="接口值类型"><a href="#接口值类型" class="headerlink" title="接口值类型"></a>接口值类型</h2><p>接口变量可以是实现者类型+实现者的值</p>
<p>或者实现者类型+实现者的指针</p>
<p><img src="/2019/06/15/golang/g17.jpg" alt="g17"></p>
<p>所以不需要使用接口的指针</p>
<p>interface{}代表支持任何类型</p>
<pre><code class="go">type  Queue []interface{}
</code></pre>
<p>interface强制类型转换</p>
<pre><code class="go">func (q *Queue) Pop() int {
    head := (*q)[0]
    *q = (*q)[1:]
    return head.(int)
}
</code></pre>
<h2 id="接口的组合"><a href="#接口的组合" class="headerlink" title="接口的组合"></a>接口的组合</h2><pre><code class="go">package main
type Retriever interface {
    Get(url string) string
}

type Poster interface {
    Post(url string,
        form map[string]string) string
}

const url = &quot;http://www.imooc.com&quot;

func download(r Retriever) string {
    return r.Get(url)
}

func post(poster Poster) {
    poster.Post(url,
        map[string]string{
            &quot;name&quot;:   &quot;ccmouse&quot;,
            &quot;course&quot;: &quot;golang&quot;,
        })
}

type RetrieverPoster interface {
    Retriever
    Poster
}

func session(s RetrieverPoster) string {
    s.Post(url, map[string]string{
        &quot;contents&quot;: &quot;another faked imooc.com&quot;,
    })
    return s.Get(url)
}

func main() {
    var r Retriever

    mockRetriever := mock.Retriever{
        Contents: &quot;this is a fake imooc.com&quot;}
    r = &amp;mockRetriever
    inspect(r)

    r = &amp;real.Retriever{
        UserAgent: &quot;Mozilla/5.0&quot;,
        TimeOut:   time.Minute,
    }
    inspect(r)

    // Type assertion
    if mockRetriever, ok := r.(*mock.Retriever); ok {
        fmt.Println(mockRetriever.Contents)
    } else {
        fmt.Println(&quot;r is not a mock retriever&quot;)
    }

    fmt.Println(
        &quot;Try a session with mockRetriever&quot;)
    fmt.Println(session(&amp;mockRetriever))
}

func inspect(r Retriever) {
    fmt.Println(&quot;Inspecting&quot;, r)
    fmt.Printf(&quot; &gt; Type:%T Value:%v\n&quot;, r, r)
    fmt.Print(&quot; &gt; Type switch: &quot;)
    switch v := r.(type) {
    case *mock.Retriever:
        fmt.Println(&quot;Contents:&quot;, v.Contents)
    case *real.Retriever:
        fmt.Println(&quot;UserAgent:&quot;, v.UserAgent)
    }
    fmt.Println()
}
</code></pre>
<pre><code class="go">package mock

import &quot;fmt&quot;

type Retriever struct {
    Contents string
}

func (r *Retriever) String() string {
    return fmt.Sprintf(
        &quot;Retriever: {Contents=%s}&quot;, r.Contents)
}

func (r *Retriever) Post(url string,
    form map[string]string) string {
    r.Contents = form[&quot;contents&quot;]
    return &quot;ok&quot;
}

func (r *Retriever) Get(url string) string {
    return r.Contents
}

</code></pre>
<pre><code class="go">package real

import (
    &quot;net/http&quot;
    &quot;net/http/httputil&quot;
    &quot;time&quot;
)

type Retriever struct {
    UserAgent string
    TimeOut   time.Duration
}

func (r *Retriever) Get(url string) string {
    resp, err := http.Get(url)
    if err != nil {
        panic(err)
    }

    result, err := httputil.DumpResponse(
        resp, true)

    resp.Body.Close()

    if err != nil {
        panic(err)
    }

    return string(result)
}
</code></pre>
<p>常用接口stringer，reader，writer等</p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>IM project</title>
    <url>/2019/07/16/imgo/</url>
    <content><![CDATA[<h1 id="IM系统架构"><a href="#IM系统架构" class="headerlink" title="IM系统架构"></a>IM系统架构</h1><p>毕设项目接触了IM，当时是用Java实现，现在来用golang复现一下，有时间再复盘整理一下毕设项目</p>
<p>源代码：<a href="https://github.com/rexllz/im" target="_blank" rel="noopener">https://github.com/rexllz/im</a></p>
<p><img src="/2019/07/16/imgo/i1.jpg" alt="i1"></p>
<h1 id="单机性能瓶颈"><a href="#单机性能瓶颈" class="headerlink" title="单机性能瓶颈"></a>单机性能瓶颈</h1><ul>
<li>Map</li>
</ul>
<p>Map不能太大</p>
<p>读写锁（读次数远大于写次数）</p>
<ul>
<li>系统</li>
</ul>
<p>Linux的最大文件数影响</p>
<ul>
<li>CPU</li>
</ul>
<p>JSON编码次数影响最大</p>
<p>IO资源的使用（合并写操作）</p>
<p>多使用缓存</p>
<ul>
<li>应用/资源服务相分离</li>
</ul>
<p>文件服务迁移到oss</p>
<h1 id="搭建框架"><a href="#搭建框架" class="headerlink" title="搭建框架"></a>搭建框架</h1><h2 id="前端获取数据DEMO"><a href="#前端获取数据DEMO" class="headerlink" title="前端获取数据DEMO"></a>前端获取数据DEMO</h2><pre><code class="go">package main

import (
    &quot;net/http&quot;
)

func main() {

    //bind the func and request
    http.HandleFunc(&quot;/user/login&quot;,
        func(writer http.ResponseWriter, request *http.Request) {

            request.ParseForm()
            mobile := request.PostForm.Get(&quot;mobile&quot;)
            passwd := request.PostForm.Get(&quot;passwd&quot;)
            loginok := false

            if (mobile == &quot;186&quot; &amp;&amp; passwd == &quot;123&quot;) {

                loginok = true
            }

            str := `{&quot;code&quot;:0,&quot;data&quot;:{&quot;id&quot;:1,&quot;token&quot;:&quot;test&quot;}}`

            if !loginok {

                str = `{&quot;code&quot;:-1,&quot;msg&quot;:&quot;password wrong&quot;}`
            }
            //set header
            writer.Header().Set(&quot;Content-Type&quot;,&quot;application/json&quot;)
            writer.WriteHeader(http.StatusOK)

            writer.Write([]byte(str))

            //io.WriteString(writer,&quot;hello world&quot;)
    })

    //start the web server
    http.ListenAndServe(&quot;:8080&quot;,nil)
}
</code></pre>
<p><img src="/2019/07/16/imgo/i0.jpg" alt="i0"></p>
<h2 id="View的使用和支持"><a href="#View的使用和支持" class="headerlink" title="View的使用和支持"></a>View的使用和支持</h2><pre><code class="go">//support the static resource
    http.Handle(&quot;/&quot;, http.FileServer(http.Dir(&quot;.&quot;)))
</code></pre>
<p>create the shtml</p>
<pre><code class="html">{{define "/user/login.shtml"}}
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;/html&gt;
&lt;script&gt;
&lt;/script&gt;
{{end}}
</code></pre>
<p>handle</p>
<pre><code class="go">http.HandleFunc(&quot;/user/login.shtml&quot;,
        func(writer http.ResponseWriter, request *http.Request) {
            tpl,err := template.ParseFiles(&quot;view/user/login.html&quot;)
            if err!=nil {
                //quit and print the err
                log.Fatal(err.Error())
            }
            tpl.ExecuteTemplate(writer,&quot;/user/login.shtml&quot;,nil)

    })
</code></pre>
<p><img src="/2019/07/16/imgo/i3.jpg" alt="i3"></p>
<h2 id="Xorm操作数据库"><a href="#Xorm操作数据库" class="headerlink" title="Xorm操作数据库"></a>Xorm操作数据库</h2><pre><code>go get github.com/go-xorm/xorm
go get github.com/go-sql-driver/mysql
</code></pre><p>定义init函数（自动运行）</p>
<pre><code class="go">var DbEngin *xorm.Engine
func init(){
    drivename := &quot;mysql&quot;
    DsName := &quot;root:root@(127.0.0.1:3306)/imchat?charset=utf8&quot;
    DbEngin, err := xorm.NewEngine(drivename,DsName)
    if err!=nil {
        log.Fatal(err.Error())
    }
    //show the sql
    DbEngin.ShowSQL(true)
    //set the max connect num
    DbEngin.SetMaxOpenConns(2)
    //auto create tables
    //DbEngin.Sync2(new(User))
    fmt.Println(&quot;init DB connect&quot;)
}
</code></pre>
<h2 id="创建web项目结构"><a href="#创建web项目结构" class="headerlink" title="创建web项目结构"></a>创建web项目结构</h2><ul>
<li>建立目录</li>
<li>init.go（DB初始化）</li>
<li>服务函数</li>
</ul>
<p>实现注册功能</p>
<p>service</p>
<pre><code class="go">package service

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;im/model&quot;
    &quot;im/util&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

type UserService struct {

}

func (s* UserService)Register (
    mobile,
    plainpwd,
    nickname,
    avatar,
    sex string)(user model.User, err error){

        //check if the mobile exist
        tmp := model.User{}
        _, err = DbEngin.Where(&quot;mobile=?&quot;, mobile).Get(&amp;tmp)
        if err!=nil {
            return tmp,err
        }
        if tmp.Id&gt;0 {
            return tmp,errors.New(&quot;this mobile have account&quot;)
        }

        tmp.Mobile = mobile
        tmp.Nickname = nickname
        tmp.Avatar = avatar
        tmp.Sex = sex
        tmp.Salt = fmt.Sprintf(&quot;%06d&quot;,rand.Int31n(10000))
        tmp.Passwd = util.MakePasswd(plainpwd,tmp.Salt)
        tmp.Createat = time.Now()
        tmp.Token = fmt.Sprintf(&quot;%08d&quot;,rand.Int31())

        //insert one data,return number and error
        _, err = DbEngin.InsertOne(&amp;tmp)


        return tmp, err
}

func (s* UserService)Login (
    mobile,
    plainpwd string)(user model.User, err error){
    return user,nil
}
</code></pre>
<p>model</p>
<pre><code class="go">package model

import &quot;time&quot;

const (
    SEX_WOMEN=&quot;W&quot;
    SEX_MEN=&quot;M&quot;
    //
    SEX_UNKNOW=&quot;U&quot;
)
type User struct {
    //用户ID
    Id         int64     `xorm:&quot;pk autoincr bigint(20)&quot; form:&quot;id&quot; json:&quot;id&quot;`
    Mobile   string         `xorm:&quot;varchar(20)&quot; form:&quot;mobile&quot; json:&quot;mobile&quot;`
    Passwd       string    `xorm:&quot;varchar(40)&quot; form:&quot;passwd&quot; json:&quot;-&quot;`   // 什么角色
    Avatar       string         `xorm:&quot;varchar(150)&quot; form:&quot;avatar&quot; json:&quot;avatar&quot;`
    Sex        string    `xorm:&quot;varchar(2)&quot; form:&quot;sex&quot; json:&quot;sex&quot;`   // 什么角色
    Nickname    string    `xorm:&quot;varchar(20)&quot; form:&quot;nickname&quot; json:&quot;nickname&quot;`   // 什么角色
    //加盐随机字符串6
    Salt       string    `xorm:&quot;varchar(10)&quot; form:&quot;salt&quot; json:&quot;-&quot;`   // 什么角色
    Online     int    `xorm:&quot;int(10)&quot; form:&quot;online&quot; json:&quot;online&quot;`   //是否在线
    //前端鉴权因子,
    Token      string    `xorm:&quot;varchar(40)&quot; form:&quot;token&quot; json:&quot;token&quot;`   // 什么角色
    Memo      string    `xorm:&quot;varchar(140)&quot; form:&quot;memo&quot; json:&quot;memo&quot;`   // 什么角色
    Createat   time.Time    `xorm:&quot;datetime&quot; form:&quot;createat&quot; json:&quot;createat&quot;`   // 什么角色
}
</code></pre>
<p>ctrl</p>
<pre><code class="go">package ctrl

import (
    &quot;fmt&quot;
    &quot;im/model&quot;
    &quot;im/service&quot;
    &quot;im/util&quot;
    &quot;math/rand&quot;
    &quot;net/http&quot;
)

var userService service.UserService

func UserRegister(writer http.ResponseWriter, request *http.Request) {

    request.ParseForm()

    mobile := request.PostForm.Get(&quot;mobile&quot;)
    plainpwd := request.PostForm.Get(&quot;passwd&quot;)

    nickname := fmt.Sprintf(&quot;user%06d&quot;, rand.Int31())
    avatar := &quot;&quot;
    sex := model.SEX_UNKNOW

    user, err := userService.Register(mobile, plainpwd, nickname, avatar, sex)
    if err!=nil {
        util.RespFail(writer,err.Error())
    }else {
        util.RespOk(writer,user,&quot;&quot;)
    }
}

func UserLogin(writer http.ResponseWriter, request *http.Request) {

    request.ParseForm()
    mobile := request.PostForm.Get(&quot;mobile&quot;)
    passwd := request.PostForm.Get(&quot;passwd&quot;)
    loginok := false

    if (mobile == &quot;186&quot; &amp;&amp; passwd == &quot;123&quot;) {

        loginok = true
    }

    if loginok {
        data := make(map[string]interface{})
        data[&quot;id&quot;] = 1
        data[&quot;token&quot;] = &quot;test&quot;
        util.RespOk(writer,data,&quot;&quot;)
    }else {
        util.RespFail(writer,&quot;password wrong&quot;)
    }

}
</code></pre>
<p>util</p>
<pre><code class="go">package util

import (
    &quot;encoding/json&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

type H struct {
    Code int `json:&quot;code&quot;`
    Msg string `json:&quot;msg&quot;`
    Data interface{} `json:&quot;data,omitempty&quot;`
}

func RespFail(w http.ResponseWriter,msg string){
    Resp(w,-1,nil,msg)
}

func RespOk(w http.ResponseWriter,data interface{},msg string){
    Resp(w,0,data,msg)
}

func Resp(writer http.ResponseWriter,code int, data interface{}, msg string)  {
    //set header
    writer.Header().Set(&quot;Content-Type&quot;,&quot;application/json&quot;)
    writer.WriteHeader(http.StatusOK)

    //define a struct
    h := H{
        Code:code,
        Msg:msg,
        Data:data,
    }

    //transform the h to string
    ret,err := json.Marshal(h)

    if err!=nil {
        log.Println(err.Error())
    }

    writer.Write(ret)
}
</code></pre>
<p><img src="/2019/07/16/imgo/i6.jpg" alt="i6"></p>
<p><img src="/2019/07/16/imgo/i5.jpg" alt="i5"></p>
<h1 id="IM业务"><a href="#IM业务" class="headerlink" title="IM业务"></a>IM业务</h1><p>websocket.connect为并行数据，需要转为串行</p>
<pre><code class="go">node := &amp;Node{
        Conn:conn,

        //transfer Parallel to serial
        DataQueue:make(chan []byte,50),
        GroupSets:set.New(set.ThreadSafe),
    }
</code></pre>
<p>存储node，user的map需要上读写锁，以防止出错</p>
<p>读写锁实际是一种特殊的<a href="https://baike.baidu.com/item/自旋锁" target="_blank" rel="noopener">自旋锁</a>，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在<a href="https://baike.baidu.com/item/多处理器系统" target="_blank" rel="noopener">多处理器系统</a>中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。</p>
<pre><code class="go">rwlocker.Lock()
    clientMap[userId]=node
    rwlocker.Unlock()
</code></pre>
<pre><code class="go">//todo 完成发送逻辑,con
    go sendproc(node)
    //todo 完成接收逻辑
    go recvproc(node)
</code></pre>
<p>设计可以无限扩张业务场景的消息通讯结构</p>
<pre><code class="cgo">func recvproc(node *Node) {
    for{
        _,data,err := node.Conn.ReadMessage()
        if err!=nil{
            log.Println(err.Error())
            return
        }
        //todo 对data进一步处理
        //dispatch(data)
        fmt.Printf(&quot;recv&lt;=%s&quot;,data)
    }
}
</code></pre>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>前端通过websocket发送<code>json格式的字符串</code><br>用户2向用户3发送文字消息hello</p>
<pre><code class="json5">{id:1,userid:2,dstid:3,cmd:10,media:1,content:&quot;hello&quot;}
</code></pre>
<p>里面携带<br>谁发的-userid<br>要发给谁-dstid<br>这个消息有什么用-cmd<br>消息怎么展示-media<br>消息内容是什么-(url,amout,pic,content等)</p>
<h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><pre><code class="go">type Message struct {
    Id      int64  `json:&quot;id,omitempty&quot; form:&quot;id&quot;` //消息ID
    //谁发的
    Userid  int64  `json:&quot;userid,omitempty&quot; form:&quot;userid&quot;` //谁发的
    //什么业务
    Cmd     int    `json:&quot;cmd,omitempty&quot; form:&quot;cmd&quot;` //群聊还是私聊
    //发给谁
    Dstid   int64  `json:&quot;dstid,omitempty&quot; form:&quot;dstid&quot;`//对端用户ID/群ID
    //怎么展示
    Media   int    `json:&quot;media,omitempty&quot; form:&quot;media&quot;` //消息按照什么样式展示
    //内容是什么
    Content string `json:&quot;content,omitempty&quot; form:&quot;content&quot;` //消息的内容
    //图片是什么
    Pic     string `json:&quot;pic,omitempty&quot; form:&quot;pic&quot;` //预览图片
    //连接是什么
    Url     string `json:&quot;url,omitempty&quot; form:&quot;url&quot;` //服务的URL
    //简单描述
    Memo    string `json:&quot;memo,omitempty&quot; form:&quot;memo&quot;` //简单描述
    //其他的附加数据，语音长度/红包金额
    Amount  int    `json:&quot;amount,omitempty&quot; form:&quot;amount&quot;` //其他和数字相关的
}
const (
    //点对点单聊,dstid是用户ID
    CMD_SINGLE_MSG = 10
    //群聊消息,dstid是群id
    CMD_ROOM_MSG   = 11
    //心跳消息,不处理
    CMD_HEART      = 0

)
const (
    //文本样式
    MEDIA_TYPE_TEXT=1
    //新闻样式,类比图文消息
    MEDIA_TYPE_News=2
    //语音样式
    MEDIA_TYPE_VOICE=3
    //图片样式
    MEDIA_TYPE_IMG=4

    //红包样式
    MEDIA_TYPE_REDPACKAGR=5
    //emoj表情样式
    MEDIA_TYPE_EMOJ=6
    //超链接样式
    MEDIA_TYPE_LINK=7
    //视频样式
    MEDIA_TYPE_VIDEO=8
    //名片样式
    MEDIA_TYPE_CONCAT=9
    //其他自己定义,前端做相应解析即可
    MEDIA_TYPE_UDEF=100
)
/**
消息发送结构体,点对点单聊为例
1、MEDIA_TYPE_TEXT
{id:1,userid:2,dstid:3,cmd:10,media:1,
content:&quot;hello&quot;}

3、MEDIA_TYPE_VOICE,amount单位秒
{id:1,userid:2,dstid:3,cmd:10,media:3,
url:&quot;http://www.a,com/dsturl.mp3&quot;,
amount:40}

4、MEDIA_TYPE_IMG
{id:1,userid:2,dstid:3,cmd:10,media:4,
url:&quot;http://www.baidu.com/a/log.jpg&quot;}


2、MEDIA_TYPE_News
{id:1,userid:2,dstid:3,cmd:10,media:2,
content:&quot;标题&quot;,
pic:&quot;http://www.baidu.com/a/log,jpg&quot;,
url:&quot;http://www.a,com/dsturl&quot;,
&quot;memo&quot;:&quot;这是描述&quot;}


5、MEDIA_TYPE_REDPACKAGR //红包amount 单位分
{id:1,userid:2,dstid:3,cmd:10,media:5,url:&quot;http://www.baidu.com/a/b/c/redpackageaddress?id=100000&quot;,&quot;amount&quot;:300,&quot;memo&quot;:&quot;恭喜发财&quot;}
6、MEDIA_TYPE_EMOJ 6
{id:1,userid:2,dstid:3,cmd:10,media:6,&quot;content&quot;:&quot;cry&quot;}

7、MEDIA_TYPE_Link 7
{id:1,userid:2,dstid:3,cmd:10,media:7,
&quot;url&quot;:&quot;http://www.a.com/dsturl.html&quot;
}

8、MEDIA_TYPE_VIDEO 8
{id:1,userid:2,dstid:3,cmd:10,media:8,
pic:&quot;http://www.baidu.com/a/log,jpg&quot;,
url:&quot;http://www.a,com/a.mp4&quot;
}

9、MEDIA_TYPE_CONTACT 9
{id:1,userid:2,dstid:3,cmd:10,media:9,
&quot;content&quot;:&quot;10086&quot;,
&quot;pic&quot;:&quot;http://www.baidu.com/a/avatar,jpg&quot;,
&quot;memo&quot;:&quot;胡大力&quot;}

*/
</code></pre>
<p>从哪里接收数据?怎么处理这些数据呢?</p>
<pre><code class="go">func recvproc(node *Node) {
    for{
        _,data,err := node.Conn.ReadMessage()
        if err!=nil{
            log.Println(err.Error())
            return
        }
        //todo 对data进一步处理
        fmt.Printf(&quot;recv&lt;=%s&quot;,data)
        dispatch(data)
    }
}
func dispatch(data []byte){
    //todo 转成message对象

    //todo 根据cmd参数处理逻辑





    msg :=Message{}
    err := json.UnMarshal(data,&amp;msg)
    if err!=nil{
        log.Printf(err.Error())
        return ;
    }
    switch msg.Cmd {
        case CMD_SINGLE_MSG: //如果是单对单消息,直接将消息转发出去
            //向某个用户发回去
            fmt.Printf(&quot;c2cmsg %d=&gt;%d\n%s\n&quot;,msg.Userid,msg.Dstid,string(tmp))
            SendMsgToUser(msg.Userid, msg.Dstid, tmp)
            //fmt.Println(msg)
        case CMD_ROOM_MSG: //群聊消息,需要知道
            fmt.Printf(&quot;c2gmsg %d=&gt;%d\n%s\n&quot;,msg.Userid,msg.Dstid,string(tmp))
            SendMsgToRoom(msg.Userid, msg.Dstid, tmp)
        case CMD_HEART:
        default:
            //啥也别做

        }

}
</code></pre>
<h2 id="发送文字、表情包"><a href="#发送文字、表情包" class="headerlink" title="发送文字、表情包"></a>发送文字、表情包</h2><p>前端user1拼接好数据对象Message<br>msg={id:1,userid:2,dstid:3,cmd:10,media:1,content:txt}<br>转化成json字符串jsonstr<br>jsonstr = JSON.stringify(msg)<br>通过websocket.send(jsonstr)发送<br>后端S在recvproc中接收收数据data<br>并做相应的逻辑处理dispatch(data)-转发给user2<br>user2通过websocket.onmessage收到消息后做解析并显示</p>
<p>前端所有的操作都在拼接数据<br>如何拼接?</p>
<pre><code class="javascript">sendtxtmsg:function(txt){
//{id:1,userid:2,dstid:3,cmd:10,media:1,content:txt}
var msg =this.createmsgcontext();
//msg={&quot;dstid&quot;:dstid,&quot;cmd&quot;:cmd,&quot;userid&quot;:userId()}
//选择某个好友/群的时候对dstid,cmd进行赋值
//userId()返回用户自己的id ,
// 从/chat/index.shtml?id=xx&amp;token=yy中获得
//1文本类型
msg.media=1;msg.content=txt;
this.showmsg(userInfo(),msg);//显示自己发的文字
this.webSocket.send(JSON.stringify(msg))//发送
}

sendpicmsg:function(picurl){
    //{id:1,userid:2,dstid:3,cmd:10,media:4,
    // url:&quot;http://www.baidu.com/a/log,jpg&quot;}
    var msg =this.createmsgcontext();
    msg.media=4;
    msg.url=picurl;
    this.showmsg(userInfo(),msg)
    this.webSocket.send(JSON.stringify(msg))
}
sendaudiomsg:function(url,num){
    //{id:1,userid:2,dstid:3,cmd:10,media:3,url:&quot;http://www.a,com/dsturl.mp3&quot;,anount:40}
    var msg =this.createmsgcontext();
    msg.media=3;
    msg.url=url;
    msg.amount = num;
    this.showmsg(userInfo(),msg)
    console.log(&quot;sendaudiomsg&quot;,this.msglist);
    this.webSocket.send(JSON.stringify(msg))
}
</code></pre>
<h3 id="后端逻辑处理函数"><a href="#后端逻辑处理函数" class="headerlink" title="后端逻辑处理函数"></a>后端逻辑处理函数</h3><p>func dispatch(data[]byte)</p>
<pre><code class="cgo">func dispatch(data[]byte){
    //todo 解析data为message

    //todo根据message的cmd属性做相应的处理

}
func recvproc(node *Node) {
    for{
        _,data,err := node.Conn.ReadMessage()
        if err!=nil{
            log.Println(err.Error())
            return
        }
        //todo 对data进一步处理
        dispatch(data)
        fmt.Printf(&quot;recv&lt;=%s&quot;,data)
    }
}
</code></pre>
<h3 id="对端接收到消息后处理函数"><a href="#对端接收到消息后处理函数" class="headerlink" title="对端接收到消息后处理函数"></a>对端接收到消息后处理函数</h3><pre><code class="js">//初始化websocket的时候进行回调配置
this.webSocket.onmessage = function(evt){
     //{&quot;data&quot;:&quot;}&quot;,...}
     if(evt.data.indexOf(&quot;}&quot;)&gt;-1){
         this.onmessage(JSON.parse(evt.data));
     }else{
         console.log(&quot;recv&lt;==&quot;+evt.data)
     }
 }.bind(this)
onmessage:function(data){
     this.loaduserinfo(data.userid,function(user){
         this.showmsg(user,data)
     }.bind(this))
 }

 //消息显示函数
showmsg:function(user,msg){
    var data={}
    data.ismine = userId()==msg.userid;
    //console.log(data.ismine,userId(),msg.userid)
    data.user = user;
    data.msg = msg;
    //vue 只需要修改数据结构即可完成页面渲染
    this.msglist = this.msglist.concat(data)
    //面板重置
    this.reset();
    var that =this;
    //滚动到新消息处
    that.timer = setTimeout(function(){
        window.scrollTo(0, document.getElementById(&quot;convo&quot;).offsetHeight);
        clearTimeout(that.timer)
    },100)
 }
</code></pre>
<h3 id="表情包简单逻辑"><a href="#表情包简单逻辑" class="headerlink" title="表情包简单逻辑"></a>表情包简单逻辑</h3><p>弹出一个窗口,<br>选择图片获得一个连接地址<br>调用sendpicmsg方法开始发送流程</p>
<h2 id="图片等upload"><a href="#图片等upload" class="headerlink" title="图片等upload"></a>图片等upload</h2><p>##5.5 发送图片/拍照<br>弹出一个窗口,<br>选择图片,上传到服务器<br>获得一个链接地址<br>调用sendpicmsg方法开始发送流程</p>
<pre><code class="html">&lt;input 
accept=&quot;image/gif,image/jpeg,,image/png&quot; 
type=&quot;file&quot; 
onchange=&quot;upload(this)&quot; 
class=&#39;upload&#39;/&gt;
</code></pre>
<p>sendpicmsg方法开始发送流程</p>
<h3 id="upload前端实现"><a href="#upload前端实现" class="headerlink" title="upload前端实现"></a>upload前端实现</h3><pre><code class="javascript">function upload(dom){
        uploadfile(&quot;attach/upload&quot;,dom,function(res){
            if(res.code==0){//成功以后调用sendpicmsg
                vm.sendpicmsg(res.data)
            }
        })
    }

function uploadfile(uri,dom,callback){
    //H5新特性
    var formdata = new FormData();
    //获得一个文件dom.files[0]
    formdata.append(&quot;file&quot;,dom.files[0])
    //formdata.append(&quot;filetype&quot;,&quot;.png&quot;)//.mp3指定后缀

    var xhr = new XMLHttpRequest();//ajax初始化
    var url = &quot;http://&quot;+location.host+&quot;/&quot;+uri;
    //&quot;http://127.0.0.1/attach/upload&quot;
    xhr.open(&quot;POST&quot;,url, true);
    //成功时候回调
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4 &amp;&amp; 
        xhr.status == 200) {
            //fn.call(this, JSON.parse(xhr.responseText));
            callback(JSON.parse(xhr.responseText))
        }
    };
    xhr.send(formdata);
}    
</code></pre>
<h3 id="upload后端实现"><a href="#upload后端实现" class="headerlink" title="upload后端实现"></a>upload后端实现</h3><p>存储到本地</p>
<pre><code>func UploadLocal(writer http.ResponseWriter,
    request * http.Request){
    }
</code></pre><p>存储到alioss</p>
<pre><code>func UploadLocal(writer http.ResponseWriter,
     request * http.Request){
}
如何安装 golang.org/x/time/rate
&gt;cd $GOPATH/src/golang.org/x/
&gt;git clone https://github.com/golang/time.git time

</code></pre><p>采集语音</p>
<pre><code class="javascript">navigator.mediaDevices.getUserMedia(
    {audio: true, video: true}
    ).then(successfunc).catch(errfunc);


navigator.mediaDevices.getUserMedia(
    {audio: true, video: false}
    ).then(function(stream)  {
              //请求成功
              this.recorder = new MediaRecorder(stream);
              this.recorder.start();
              this.recorder.ondataavailable = (event) =&gt; {
                  uploadblob(&quot;attach/upload&quot;,event.data,&quot;.mp3&quot;,res=&gt;{
                      var duration = Math.ceil((new Date().getTime()-this.duration)/1000);
                      this.sendaudiomsg(res.data,duration);
                  })

                  stream.getTracks().forEach(function (track) {
                      track.stop();
                  });
                  this.showprocess = false
              }

          }.bind(this)).catch(function(err){
                mui.toast(err.msg)
                this.showprocess = false
            }.bind(this));
</code></pre>
<p>上传语音</p>
<pre><code class="javascript">function uploadblob(uri,blob,filetype,fn){
       var xhr = new XMLHttpRequest();
       xhr.open(&quot;POST&quot;,&quot;//&quot;+location.host+&quot;/&quot;+uri, true);
       // 添加http头，发送信息至服务器时内容编码类型
       xhr.onreadystatechange = function() {
           if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304)) {
               fn.call(this, JSON.parse(xhr.responseText));
           }
       };
       var _data=[];
       var formdata = new FormData();
       formdata.append(&quot;filetype&quot;,filetype);
       formdata.append(&quot;file&quot;,blob)
       xhr.send(formdata);
   }
</code></pre>
<h2 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h2><p>分析群id,找到加了这个群的用户,把消息发送过去</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>map<userid>&lt;qunid1,qunid2,qunid3&gt;<br>优势是锁的频次低<br>劣势是要轮训全部map</userid></p>
<pre><code class="go">type Node struct {
    Conn *websocket.Conn
    //并行转串行,
    DataQueue chan []byte
    GroupSets set.Interface
}
//映射关系表
var clientMap map[int64]*Node = make(map[int64]*Node,0)
</code></pre>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>map&lt;群id&gt;&lt;userid1,userid2,userid3&gt;<br>优势是找用户ID非常快<br>劣势是发送信息时需要根据userid获取node,锁的频次太高</p>
<pre><code class="go">type Node struct {
    Conn *websocket.Conn
    //并行转串行,
    DataQueue chan []byte
}
//映射关系表
var clientMap map[int64]*Node = make(map[int64]*Node,0)
var comMap map[int64]set.Interface= make(map[int64]set.Interface,0)

</code></pre>
<p>需要处理的问题</p>
<pre><code class="javascript">1、当用户接入的时候初始化groupset
2、当用户加入群的时候刷新groupset
3、完成信息分发
</code></pre>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="静态资源分离（Aliyun-OSS）"><a href="#静态资源分离（Aliyun-OSS）" class="headerlink" title="静态资源分离（Aliyun OSS）"></a>静态资源分离（Aliyun OSS）</h2><p>使用阿里云OSS</p>
<blockquote>
<p>go get github.com/aliyun/aliyun-oss-go-sdk/oss</p>
</blockquote>
<pre><code class="go">//权限设置为公共读状态
//需要安装
func UploadOss(writer http.ResponseWriter,
    request * http.Request){
    //todo 获得上传的文件
    srcfile,head,err:=request.FormFile(&quot;file&quot;)
    if err!=nil{
        util.RespFail(writer,err.Error())
        return
    }


    //todo 获得文件后缀.png/.mp3

    suffix := &quot;.png&quot;
    //如果前端文件名称包含后缀 xx.xx.png
    ofilename := head.Filename
    tmp := strings.Split(ofilename,&quot;.&quot;)
    if len(tmp)&gt;1{
        suffix = &quot;.&quot;+tmp[len(tmp)-1]
    }
    //如果前端指定filetype
    //formdata.append(&quot;filetype&quot;,&quot;.png&quot;)
    filetype := request.FormValue(&quot;filetype&quot;)
    if len(filetype)&gt;0{
        suffix = filetype
    }

    //todo 初始化ossclient
    client,err:=oss.New(EndPoint,AccessKeyId,AccessKeySecret)
    if err!=nil{
        util.RespFail(writer,err.Error())
        return
    }
    //todo 获得bucket
    bucket,err := client.Bucket(Bucket)
    if err!=nil{
        util.RespFail(writer,err.Error())
        return
    }
    //todo 设置文件名称
    //time.Now().Unix()
    filename := fmt.Sprintf(&quot;mnt/%d%04d%s&quot;,
        time.Now().Unix(), rand.Int31(),
        suffix)
    //todo 通过bucket上传
    err=bucket.PutObject(filename,srcfile)
    if err!=nil{
        util.RespFail(writer,err.Error())
        return
    }
    //todo 获得url地址
    url := &quot;http://&quot;+Bucket+&quot;.&quot;+EndPoint+&quot;/&quot;+filename

    //todo 响应到前端
    util.RespOk(writer,url,&quot;&quot;)
}
</code></pre>
<h1 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h1><h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p><img src="/2019/07/16/imgo/i7.jpg" alt="i7"></p>
<p>普通方案无法满足connect之间无法通讯的问题</p>
<p>需要建立总线维持信息</p>
<h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><p><img src="/2019/07/16/imgo/i8.jpg" alt="i8"></p>
<h2 id="局域网通讯协议"><a href="#局域网通讯协议" class="headerlink" title="局域网通讯协议"></a>局域网通讯协议</h2><p><img src="/2019/07/16/imgo/i9.jpg" alt="i9"></p>
<h2 id="实现调度应用"><a href="#实现调度应用" class="headerlink" title="实现调度应用"></a>实现调度应用</h2><p><img src="/2019/07/16/imgo/i10.jpg" alt="i10"></p>
<h2 id="实现（UDP方案）"><a href="#实现（UDP方案）" class="headerlink" title="实现（UDP方案）"></a>实现（UDP方案）</h2><p>回顾单体应用<br>开启ws接收协程recvproc/ws发送协程sendproc<br>websocket收到消息-&gt;dispatch发送给dstid</p>
<p>基于UDP的分布式应用<br>开启ws接收协程recvproc/ws发送协程sendproc<br>开启udp接收协程udprecvproc/udp发送协程udpsendproc</p>
<p>websocket收到消息-&gt;broadMsg广播到局域网<br>udp接收到收到消息-&gt;dispatch发送给dstid<br>自己是局域网一份子,所以也能接收到消息</p>
<pre><code class="go">var  udpsendchan chan []byte=make(chan []byte,1024)
//todo 将消息广播到局域网
func broadMsg(data []byte){
    udpsendchan&lt;-data
}

//todo 完成udp数据的发送协程
func udpsendproc(){
    log.Println(&quot;start udpsendproc&quot;)
    //todo 使用udp协议拨号
    con,err:=net.DialUDP(&quot;udp&quot;,nil,
        &amp;net.UDPAddr{
            IP:net.IPv4(192,168,0,255),
            Port:3000,
        })
    defer con.Close()
    if err!=nil{
        log.Println(err.Error())
        return
    }
    //todo 通过的到的con发送消息
    //con.Write()
    for{
        select {
        case data := &lt;- udpsendchan:
            _,err=con.Write(data)
            if err!=nil{
                log.Println(err.Error())
                return
            }
        }
    }
}
//todo 完成upd接收并处理功能
func udprecvproc(){
    log.Println(&quot;start udprecvproc&quot;)
    //todo 监听udp广播端口
    con,err:=net.ListenUDP(&quot;udp&quot;,&amp;net.UDPAddr{
        IP:net.IPv4zero,
        Port:3000,
    })
    defer con.Close()
    if err!=nil{log.Println(err.Error())}
    //TODO 处理端口发过来的数据
    for{
        var buf [512]byte
        n,err:=con.Read(buf[0:])
        if err!=nil{
            log.Println(err.Error())
            return
        }
        //直接数据处理
        dispatch(buf[0:n])
    }
    log.Println(&quot;stop updrecvproc&quot;)
}
</code></pre>
<h3 id="nginx反向代理-1"><a href="#nginx反向代理-1" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><pre><code>    upstream wsbackend {
            server 192.168.0.102:8080;
            server 192.168.0.100:8080;
            hash $request_uri;
    }
    map $http_upgrade $connection_upgrade {
    default upgrade;
    &#39;&#39;      close;
    }
    server {
      listen  80;
      server_name localhost;
      location / {
       proxy_pass http://wsbackend;
      }
      location ^~ /chat {
       proxy_pass http://wsbackend;
       proxy_connect_timeout 500s;
       proxy_read_timeout 500s;
       proxy_send_timeout 500s;
       proxy_set_header Upgrade $http_upgrade;
       proxy_set_header Connection &quot;Upgrade&quot;;
      }
     }

}
</code></pre><h3 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h3><ul>
<li>windows平台</li>
</ul>
<pre><code class="bash">::remove dir
rd /s/q release
::make dir 
md release
::go build -ldflags &quot;-H windowsgui&quot; -o chat.exe
go build -o chat.exe
::
COPY chat.exe release\
COPY favicon.ico release\favicon.ico
::
XCOPY asset\*.* release\asset\  /s /e
XCOPY view\*.* release\view\  /s /e 
</code></pre>
<ul>
<li>linux平台</li>
</ul>
<pre><code class="bash">#!/bin/sh
rm -rf ./release
mkdir  release
go build -o chat
chmod +x ./chat
cp chat ./release/
cp favicon.ico ./release/
cp -arf ./asset ./release/
cp -arf ./view ./release/
</code></pre>
<ul>
<li>运行注意事项<br>linux 下</li>
</ul>
<pre><code class="bash">nohup ./chat &gt;&gt;./log.log 2&gt;&amp;1 &amp;
</code></pre>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="idea-ignore插件"><a href="#idea-ignore插件" class="headerlink" title="idea .ignore插件"></a>idea .ignore插件</h2><p><img src="/2019/07/16/imgo/i2.jpg" alt="i2"></p>
<h2 id="JSON改为小写"><a href="#JSON改为小写" class="headerlink" title="JSON改为小写"></a>JSON改为小写</h2><p>nil值不发送</p>
<pre><code class="go">type H struct {
    Code int `json:&quot;code&quot;`
    Msg string `json:&quot;msg&quot;`
    Data interface{} `json:&quot;data,omitempty&quot;`
}
</code></pre>
<h2 id="自动渲染和接入全部View"><a href="#自动渲染和接入全部View" class="headerlink" title="自动渲染和接入全部View"></a>自动渲染和接入全部View</h2><p>写入统一函数</p>
<pre><code class="go">func RegisterView()  {
    tpl,err := template.ParseGlob(&quot;view/**/*&quot;)
    if err!=nil {
        //quit and print the err
        log.Fatal(err.Error())
    }

    for _,v := range tpl.Templates(){
        tplname := v.Name()

        http.HandleFunc(tplname,
            func(writer http.ResponseWriter, request *http.Request) {
                tpl.ExecuteTemplate(writer, tplname, nil)
        })
    }
}
</code></pre>
<h2 id="自动创建表结构"><a href="#自动创建表结构" class="headerlink" title="自动创建表结构"></a>自动创建表结构</h2><pre><code class="go">package service

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    _ &quot;github.com/go-sql-driver/mysql&quot;
    &quot;github.com/go-xorm/xorm&quot;
    &quot;im/model&quot;
    &quot;log&quot;
)

var DbEngin *xorm.Engine
func init(){
    drivename := &quot;mysql&quot;
    DsName := &quot;root:root@(127.0.0.1:3306)/imchat?charset=utf8&quot;
    err := errors.New(&quot;&quot;)
    DbEngin, err = xorm.NewEngine(drivename,DsName)
    if err!=nil &amp;&amp; &quot;&quot;!=err.Error(){
        log.Fatal(err.Error())
    }
    //show the sql
    DbEngin.ShowSQL(true)
    //set the max connect num
    DbEngin.SetMaxOpenConns(2)
    //auto create tables
    DbEngin.Sync2(new(model.User))
    fmt.Println(&quot;init DB connect&quot;)
}

</code></pre>
<p><img src="/2019/07/16/imgo/i4.jpg" alt="i4"></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Java GC</title>
    <url>/2019/02/22/javagc/</url>
    <content><![CDATA[<h1 id="垃圾判定"><a href="#垃圾判定" class="headerlink" title="垃圾判定"></a>垃圾判定</h1><ul>
<li>没有被其他对象引用</li>
</ul>
<h2 id="判定算法"><a href="#判定算法" class="headerlink" title="判定算法"></a>判定算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ul>
<li>判断对象的引用数量</li>
<li>每个对象都有一个引用计数器，被引用+1，完成引用-1</li>
<li>任何引用计数为0的对象实例可以被当作垃圾收集</li>
</ul>
<p>优点：执行效率高，程序执行受影响小</p>
<p>缺点：无法检测出循环引用，导致内存泄露（引用计数永不为0）</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li>通过判断对象的引用链是否可达来决定对象是否被回收</li>
</ul>
<p><img src="/2019/02/22/javagc/access.jpg" alt="access"></p>
<h4 id="GC-Root对象"><a href="#GC-Root对象" class="headerlink" title="GC Root对象"></a>GC Root对象</h4><ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>本地方法栈中JNI（Native方法）的引用对象</li>
<li>活跃线程的引用对象</li>
</ul>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法（Mark-amp-Sweep）"><a href="#标记-清除算法（Mark-amp-Sweep）" class="headerlink" title="标记-清除算法（Mark &amp; Sweep）"></a>标记-清除算法（Mark &amp; Sweep）</h3><ul>
<li>标记：从根集合扫描，对存活对象进行标记</li>
<li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象</li>
</ul>
<p><img src="/2019/02/22/javagc/sweep.jpg" alt="sweep"></p>
<ul>
<li>缺点：碎片化严重</li>
</ul>
<h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><ul>
<li>内存被分为对象面和空闲面</li>
<li>对象在对象面创建</li>
<li>对象面用完，将存活的对象复制到空闲面</li>
<li>将对象面所有对象清理</li>
</ul>
<p><img src="/2019/02/22/javagc/copy.jpg" alt="copy"></p>
<ul>
<li>解决碎片化问题</li>
<li>顺序分配内存，简单高效</li>
<li>适合存活率低的场景（不适合老年代）</li>
</ul>
<h3 id="标记-整理算法（Compacting）"><a href="#标记-整理算法（Compacting）" class="headerlink" title="标记-整理算法（Compacting）"></a>标记-整理算法（Compacting）</h3><ul>
<li>标记：从根集合扫描，对存活对象进行标记</li>
<li>清除：移动所有存活对象，按照内存地址重新依次排列，将末端内存地址以后的内存全部回收</li>
</ul>
<p><img src="/2019/02/22/javagc/sc.png" alt="compact"></p>
<ul>
<li>避免了碎片化</li>
<li>不用设置两块内存空间</li>
<li>适用于存活率高的场景（老年代）</li>
</ul>
<h3 id="分代收集算法（Generational-Collector）"><a href="#分代收集算法（Generational-Collector）" class="headerlink" title="分代收集算法（Generational Collector）"></a>分代收集算法（Generational Collector）</h3><ul>
<li>回收算法组合拳</li>
<li>按照对象生命周期不同划分区域采取不同算法</li>
</ul>
<p><img src="/2019/02/22/javagc/gcold.jpg" alt="gcold"></p>
<ul>
<li>jdk8以后取消永久代</li>
</ul>
<p><img src="/2019/02/22/javagc/gcnow.jpg" alt="gcnow"></p>
<ul>
<li>年轻代存活率低，采用复制算法</li>
<li>老年代存活率高，采用标记清除/整理算法</li>
</ul>
<h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><ul>
<li>年轻代GC</li>
<li>复制算法</li>
<li>频繁</li>
</ul>
<p>年轻代分为两个区域</p>
<ul>
<li>Eden</li>
<li>两个Survivor：From，To</li>
<li>8：1：1</li>
</ul>
<p><img src="/2019/02/22/javagc/young.jpg" alt="young"></p>
<p>对象在Eden出生，确定存活转移到s0</p>
<p><img src="/2019/02/22/javagc/y1.jpg" alt="y1"></p>
<p>清除所有eden区对象，并将存活对象年龄设置为1</p>
<p><img src="/2019/02/22/javagc/y2.jpg" alt="y2"></p>
<p>Eden重新加载对象，重复上述过程到s2，年龄+1</p>
<p><img src="/2019/02/22/javagc/y3.jpg" alt="y2"></p>
<p>清空Eden和s0</p>
<p><img src="/2019/02/22/javagc/y4.jpg" alt="y2"></p>
<p>周而复始</p>
<p><img src="/2019/02/22/javagc/y5.jpg" alt="y2"></p>
<p>年龄达到某值，进入老年区</p>
<blockquote>
<p>-XX:MaxTenuringThreshold     //可调整此年龄</p>
</blockquote>
<p>年轻代溢出对象也会转移至老年代</p>
<p>晋升到老年代的对象：</p>
<ul>
<li>经理多数Minor GC，年龄超过一定数值</li>
<li>Survivor中放不下的对象</li>
<li>新生成的大对象</li>
</ul>
<blockquote>
<p>-XX:+PretenuerSizeThreshold</p>
</blockquote>
<h4 id="调优参数"><a href="#调优参数" class="headerlink" title="调优参数"></a>调优参数</h4><blockquote>
<p>-XX:SurvivorRatio        //Eden,Survivor比例，默认8：1</p>
<p>-XX:NewRatio            //年轻代与老年代比例，默认1：2</p>
</blockquote>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><ul>
<li>老年代存放周期较长的对象</li>
<li>采用标记清理/整理算法GC</li>
<li>速度慢</li>
<li>频率低</li>
</ul>
<p>触发条件：</p>
<ul>
<li>老年代空间不足</li>
<li>永久代空间不足（JDK7以后取消）</li>
<li>CMS GC出现promotion/concurrent mode fail</li>
<li>Minor GC晋升老年代平均大小大于剩余空间</li>
<li>调用System.gc() 显式但不强制</li>
<li>使用RMI进行RPC或管理的JDK应用，一小时执行一次</li>
</ul>
<h2 id="年轻代垃圾回收器"><a href="#年轻代垃圾回收器" class="headerlink" title="年轻代垃圾回收器"></a>年轻代垃圾回收器</h2><h3 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h3><ul>
<li>JVM由于要执行GC而停止应用程序的执行</li>
<li>任何GC算法都会发生</li>
<li>减少stop-the-world实现GC优化</li>
</ul>
<h3 id="Safepoint"><a href="#Safepoint" class="headerlink" title="Safepoint"></a>Safepoint</h3><ul>
<li>GC时不再产生垃圾</li>
<li>分析过程中对象引用关系不会发生变化的点</li>
<li>到达安全点程序才会暂停</li>
<li>多在方法调用，循环跳转，异常跳转等</li>
<li>安全点数量适中</li>
</ul>
<h3 id="JVM运行模式"><a href="#JVM运行模式" class="headerlink" title="JVM运行模式"></a>JVM运行模式</h3><ul>
<li>server，启动慢运行快</li>
<li>client，启动快运行慢</li>
</ul>
<blockquote>
<p>java -version</p>
</blockquote>
<h3 id="垃圾收集器关系"><a href="#垃圾收集器关系" class="headerlink" title="垃圾收集器关系"></a>垃圾收集器关系</h3><p><img src="/2019/02/22/javagc/collector.jpg" alt="collector"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><blockquote>
<p>-XX:+UseSerialGC        //复制算法</p>
</blockquote>
<ul>
<li>单线程收集，GC时，必须暂停所有工作线程</li>
<li>简单高效，client默认年轻代收集器</li>
</ul>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><blockquote>
<p>-XX:+UserParNewGC        //复制算法</p>
</blockquote>
<ul>
<li>多线程收集</li>
<li>单核执行效率不及Serial，多核下有优势</li>
</ul>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><blockquote>
<p>-XX:+UserParallelGC        //复制算法</p>
</blockquote>
<ul>
<li>吞吐量=运行用户代码时间/(运行用户代码时间+GC时间)</li>
<li>关注吞吐量，忽视用户线程卡顿</li>
<li>Server模式下默认的年轻代收集器</li>
</ul>
<h2 id="老年代垃圾回收器"><a href="#老年代垃圾回收器" class="headerlink" title="老年代垃圾回收器"></a>老年代垃圾回收器</h2><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><blockquote>
<p>-XX:+UseSerialOldGC        //标记整理算法</p>
</blockquote>
<ul>
<li>单线程收集，必须停止工作线程</li>
<li>简单高效</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><blockquote>
<p>-XX:+UseParallelOldGC        //标记整理算法</p>
</blockquote>
<ul>
<li>多线程，吞吐量优先</li>
</ul>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a><strong>CMS收集器</strong></h3><blockquote>
<p>-XX:UseConcMarkSweepGC        //标记清除算法</p>
</blockquote>
<ul>
<li>初始标记：stop-the-world，JVM停顿，时间短</li>
<li>并发标记：并发追溯标记，程序不停顿</li>
<li>并发预处理：查找执行并发标记时晋升老年代的对象，不停顿</li>
<li>重新标记：暂停虚拟机，扫描CMS堆中剩余对象</li>
<li>并发清理：清理垃圾对象，程序不卡顿</li>
<li>并发重置：重置CMS收集器的数据结构</li>
</ul>
<p>特点：边产生边回收、碎片化严重</p>
<h3 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a>Garbage First</h3><ul>
<li>并行和并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测停顿</li>
</ul>
<p>1、将整个Java堆内存划分为多个大小相等的Region</p>
<p>2、年轻代老年代不再物理隔阂</p>
<p><img src="/2019/02/22/javagc/gf.jpg" alt="gf"></p>
<h3 id="收集器结合情况"><a href="#收集器结合情况" class="headerlink" title="收集器结合情况"></a>收集器结合情况</h3><p><img src="/2019/02/22/javagc/gclink.jpg" alt="gclink"></p>
<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><ul>
<li>Object.finalize()是否与C++析构函数作用相同</li>
</ul>
<p>不同</p>
<p>析构函数调用确定，finalize()不确定，也就是还未运行完已经被GC</p>
<ul>
<li>Java中的强引用、软引用、弱引用和虚引用</li>
</ul>
<p>强引用：</p>
<blockquote>
<p>Object obj = new Object();</p>
</blockquote>
<p>1、即使抛出OutOfMemoryError也不会回收该对象</p>
<p>2、可以通过设置为null来弱化作用，使其被回收</p>
<p>软引用：</p>
<blockquote>
<p>SoftReference<string> softRef=new SoftReference<string>(str);</string></string></p>
</blockquote>
<p>1、对象有用但非必须状态</p>
<p>2、只有当内存不足，GC才会回收</p>
<p>3、可用来实现高速缓存</p>
<p>弱引用</p>
<blockquote>
<p>WeakReference<string> weakRef=new WeakReference<string>(str);</string></string></p>
</blockquote>
<p>1、比软引用更弱</p>
<p>2、GC时被回收</p>
<p>3、GC优先级低，所以被回收概率也不大</p>
<p>虚引用：</p>
<p>1、形同虚设</p>
<p>2、任何时候都可能被回收</p>
<p>3、跟踪对象被GC的活动，起哨兵作用</p>
<p>4、必须和引用队列ReferenceQueue联合使用</p>
<p><img src="/2019/02/22/javagc/ref.jpg" alt="ref"></p>
<p>四种引用的关系：</p>
<p><img src="/2019/02/22/javagc/ref4.jpg" alt="ref4"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM basic</title>
    <url>/2019/02/21/jvm/</url>
    <content><![CDATA[<h1 id="JVM-basic"><a href="#JVM-basic" class="headerlink" title="JVM basic"></a>JVM basic</h1><h2 id="Compile-Once-Run-Anywhere"><a href="#Compile-Once-Run-Anywhere" class="headerlink" title="Compile Once, Run Anywhere"></a>Compile Once, Run Anywhere</h2><ul>
<li>平台无关性</li>
</ul>
<p><img src="/2019/02/21/jvm/javaclass.jpg" alt="javaclass"></p>
<ul>
<li>查看字节码.class</li>
</ul>
<p>反编译工具</p>
<blockquote>
<p>javap</p>
</blockquote>
<ul>
<li>为何不直接解析为机器码</li>
</ul>
<p>1、可将准备工作提前做好，.class文件不存在语法等错误，无需再校验</p>
<p>2、可将其他语言解析成字节码实现，提高平台兼容性</p>
<h2 id="JVM-架构"><a href="#JVM-架构" class="headerlink" title="JVM 架构"></a>JVM 架构</h2><p><img src="/2019/02/21/jvm/jvm.jpg" alt="jvm"></p>
<h2 id="类从编译到执行过程"><a href="#类从编译到执行过程" class="headerlink" title="类从编译到执行过程"></a>类从编译到执行过程</h2><ul>
<li>编译器将***.java源文件编译为.class字节码文件</li>
<li>ClassLoader将字节码转化为JVM的Class<robot>对象</robot></li>
<li>JVM利用Class<robot>对象实例化Robot对象</robot></li>
</ul>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><ul>
<li>负责将class问及结案的二进制数据流装载进JVM，进行连接，初始化等操作</li>
</ul>
<h3 id="ClassLoader种类"><a href="#ClassLoader种类" class="headerlink" title="ClassLoader种类"></a>ClassLoader种类</h3><ul>
<li>BootStrapClassLoader：C++编写，加载核心库java.*</li>
<li>ExtClassLoader：Java编写，加载扩展库javax.*</li>
<li>AppClassLoader：Java编写，加载程序所在目录，类路径</li>
<li>自定义ClassLoader：Java编写，定制化加载</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="/2019/02/21/jvm/classloader.jpg" alt="classloader"></p>
<ul>
<li>可避免重复加载相同字节码</li>
</ul>
<h2 id="LoadClass-amp-forName"><a href="#LoadClass-amp-forName" class="headerlink" title="LoadClass &amp; forName"></a>LoadClass &amp; forName</h2><h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><ul>
<li>隐式加载：new</li>
<li>显示加载：loadClass，forName</li>
</ul>
<h3 id="类的装载过程"><a href="#类的装载过程" class="headerlink" title="类的装载过程"></a>类的装载过程</h3><ul>
<li><p>加载：通过ClassLoader加载class字节码，生成class对象</p>
</li>
<li><p>链接：</p>
<p>1、校验：检查加载的class正确性和安全性</p>
<p>2、准备：为类变量分配存储空间并设置类变量初始值</p>
<p>3、解析：JVM将常量池内的符号引用转换为直接引用</p>
</li>
<li><p>初始化：执行类变量赋值和静态代码块</p>
</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>Class.forName得到的class是已经初始化的</li>
<li>Classloder.loadClass得到的class是还没有链接的</li>
</ul>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Thread Basic</title>
    <url>/2019/02/24/javamt/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p> <img src="/2019/02/24/javamt/thread.jpg" alt></p>
<ul>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>所有与进程相关的资源，都被记录在PCB中</li>
</ul>
<p><img src="/2019/02/24/javamt/pcb.jpg" alt></p>
<p>进程控制块（PCB）</p>
<ul>
<li>进程是抢占处理机的调度单位，线程属于进程，共享其资源</li>
<li>线程只有堆栈寄存器，程序计数器和TCB组成</li>
</ul>
<p><img src="/2019/02/24/javamt/ts.jpg" alt></p>
<ul>
<li>进程可被看成独立的应用</li>
<li>进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径</li>
<li>线程没有独立的地址空间，多进程的程序较多线程健壮</li>
<li>进程的切换较线程大 </li>
</ul>
<h1 id="Java中的线程与进程"><a href="#Java中的线程与进程" class="headerlink" title="Java中的线程与进程"></a>Java中的线程与进程</h1><ul>
<li>Java对OS进行了封装，包括线程与进程</li>
<li>一个程序对应一个进程，一个进程至少一个线程</li>
<li>一个进程对应一个JVM实例，多个线程共享JVM堆</li>
<li>Java采用单线程编程模式，程序会自动创建主线程</li>
<li>主线程可以创建子线程，原则上后于子线程完成执行</li>
</ul>
<h2 id="start-amp-run"><a href="#start-amp-run" class="headerlink" title="start &amp; run"></a>start &amp; run</h2><pre><code class="java">package com.interview.javabasic.thread;

public class ThreadTest {
    private static void attack() {
        System.out.println(&quot;Fight&quot;);
        System.out.println(&quot;Current Thread is : &quot; + Thread.currentThread().getName());
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(){
            public void run(){
                attack();
            }
        };
        System.out.println(&quot;current main thread is : &quot; + Thread.currentThread().getName());
        t.start();
        t.join();
        t.start();
    }
}
</code></pre>
<p><img src="/2019/02/24/javamt/start.jpg" alt></p>
<ul>
<li>调用start()方法会调用JVM native并创建新的子线程并启动</li>
<li>run()方法只是Thread的一个普通方法调用</li>
</ul>
<h2 id="Thread-amp-Runnable"><a href="#Thread-amp-Runnable" class="headerlink" title="Thread &amp; Runnable"></a>Thread &amp; Runnable</h2><ul>
<li>Thread是一个实现Runnable接口的一个类，使run支持多线程。</li>
<li><p>因类的单一继承原则，推荐使用Runnable接口</p>
<p><strong>重写thread run方法</strong></p>
</li>
</ul>
<pre><code class="java">package com.interview.javabasic.thread;

public class MyThread extends Thread {
    private String name;
    public MyThread(String name){
        this.name = name;
    }
    @Override
    public void run(){
        for(int i = 0 ; i &lt; 10 ; i ++){
            System.out.println(&quot;Thread start : &quot; + this.name + &quot;,i= &quot; + i);
        }
    }
}
</code></pre>
<pre><code class="java">package com.interview.javabasic.thread;

public class ThreadDemo {
    public static void main(String[] args) {
        MyThread mt1 = new MyThread(&quot;Thread1&quot;);
        MyThread mt2 = new MyThread(&quot;Thread2&quot;);
        MyThread mt3 = new MyThread(&quot;Thread3&quot;);
        mt1.start();
        mt2.start();
        mt3.start();
    }
}
</code></pre>
<p><strong>实现Runnable接口</strong></p>
<pre><code class="java">package com.interview.javabasic.thread;

public class MyRunnable implements Runnable {
    private String name;
    public MyRunnable(String name){
        this.name = name;
    }
    @Override
    public void run(){
        for(int i = 0 ; i &lt; 10 ; i ++){
            System.out.println(&quot;Thread start : &quot; + this.name + &quot;,i= &quot; + i);
        }
    }
}
</code></pre>
<pre><code class="java">package com.interview.javabasic.thread;

public class RunnableDemo {
    public static void main(String[] args) throws InterruptedException {
        MyRunnable mr1 = new MyRunnable(&quot;Runnable1&quot;);
        MyRunnable mr2 = new MyRunnable(&quot;Runnable2&quot;);
        MyRunnable mr3 = new MyRunnable(&quot;Runnable3&quot;);
        Thread t1 = new Thread(mr1);
        Thread t2 = new Thread(mr2);
        Thread t3 = new Thread(mr3);
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre>
<h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>实现对Run方法传参方式</p>
<ul>
<li>构造函数传参</li>
<li>成员变量传参</li>
<li>回调函数传参</li>
</ul>
<h2 id="处理线程返回值"><a href="#处理线程返回值" class="headerlink" title="处理线程返回值"></a>处理线程返回值</h2><ul>
<li>主线程等待法</li>
<li>使用Thread类的join()阻塞当前线程以等待子线程处理完毕，粒度不够细</li>
</ul>
<pre><code class="java">package com.interview.javabasic.thread;

public class CycleWait implements Runnable{
    private String value;
    public void run() {
        try {
            Thread.currentThread().sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        value = &quot;we have data now&quot;;
    }

    public static void main(String[] args) throws InterruptedException {
        CycleWait cw = new CycleWait();
        Thread t = new Thread(cw);
        t.start();
//        while (cw.value == null){
//            Thread.currentThread().sleep(100);
//        }
        t.join();
        System.out.println(&quot;value : &quot; + cw.value);
    }
}
</code></pre>
<ul>
<li><p>通过Callable接口实现</p>
<p>1、通过Future Task 获取</p>
</li>
</ul>
<pre><code class="java">package com.interview.javabasic.thread;

import java.util.concurrent.Callable;

public class MyCallable implements Callable&lt;String&gt; {
    @Override
    public String call() throws Exception{
        String value=&quot;test&quot;;
        System.out.println(&quot;Ready to work&quot;);
        Thread.currentThread().sleep(5000);
        System.out.println(&quot;task done&quot;);
        return  value;
    }

}
</code></pre>
<pre><code class="java">package com.interview.javabasic.thread;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class FutureTaskDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask&lt;String&gt; task = new FutureTask&lt;String&gt;(new MyCallable());
        new Thread(task).start();
        if(!task.isDone()){
            System.out.println(&quot;task has not finished, please wait!&quot;);
        }
        System.out.println(&quot;task return: &quot; + task.get());

    }
}
</code></pre>
<p>​    2、线程池获取</p>
<pre><code class="java">package com.interview.javabasic.thread;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
        Future&lt;String&gt; future = newCachedThreadPool.submit(new MyCallable());
        if(!future.isDone()){
            System.out.println(&quot;task has not finished, please wait!&quot;);
        }
        try {
            System.out.println(future.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        } finally {
            newCachedThreadPool.shutdown();
        }
    }
}
</code></pre>
<ul>
<li>可提交多个Callable并发执行</li>
</ul>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul>
<li><p>New，新建：创建后尚未启动的状态</p>
</li>
<li><p>Runnable，运行：包含Running Ready</p>
</li>
<li><p>Waiting，无限期等待：不会被分配CPU时间，需要显式唤醒</p>
<p>无Timeout参数的Object.wait()</p>
<p>无Timeout参数的Thread.join()</p>
<p>LockSupport.park()</p>
</li>
<li><p>Timed Waiting，限期等待：一定时间后自动唤醒</p>
<p>Thread.sleep()</p>
<p>设置Timeout参数的Object.wait()</p>
<p>设置Timeout参数的Thread.join()</p>
<p>LockSupport.parkNanos()</p>
<p>LockSupport.parkUntil()</p>
</li>
<li><p>Blocked，阻塞：等待获取排他锁</p>
</li>
<li><p>Terminated，结束：已经结束执行</p>
<p>结束后不能再执行</p>
</li>
</ul>
<h2 id="Sleep-amp-Wait"><a href="#Sleep-amp-Wait" class="headerlink" title="Sleep &amp; Wait"></a>Sleep &amp; Wait</h2><ul>
<li>sleep是Thread中的方法，wait是Object中的方法</li>
<li>sleep可在任何方法中使用，wait正能在synchronize方法或块中使用</li>
<li><strong>Thread.sleep只会让出cpu，不改变锁状态</strong></li>
<li><strong>Object.wait既会让出cpu，也会改变锁状态，释放已被占用的同步资源锁</strong></li>
</ul>
<pre><code class="java">package com.interview.javabasic.thread;

public class WaitSleepDemo {
    public static void main(String[] args) {
        final Object lock = new Object();
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;thread A is waiting to get lock&quot;);
                synchronized (lock){
                    try {
                        System.out.println(&quot;thread A get lock&quot;);
                        Thread.sleep(20);
                        System.out.println(&quot;thread A do wait method&quot;);
                        lock.wait();
                        System.out.println(&quot;thread A is done&quot;);
                    } catch (InterruptedException e){
                        e.printStackTrace();
                    }
                }
            }
        }).start();
        try{
            Thread.sleep(10);
        } catch (InterruptedException e){
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;thread B is waiting to get lock&quot;);
                synchronized (lock){
                    try {
                        System.out.println(&quot;thread B get lock&quot;);
                        System.out.println(&quot;thread B is sleeping 10 ms&quot;);
                        Thread.sleep(10);
                        lock.notifyAll();
                        Thread.yield();
                        Thread.sleep(2000);
                        System.out.println(&quot;thread B is done&quot;);
                    } catch (InterruptedException e){
                        e.printStackTrace();
                    }
                }
            }
        }).start();

    }
}
</code></pre>
<h2 id="notify-amp-notifyall"><a href="#notify-amp-notifyall" class="headerlink" title="notify &amp; notifyall"></a>notify &amp; notifyall</h2><ul>
<li>锁池，entrylist</li>
</ul>
<p><img src="/2019/02/24/javamt/entrylist.jpg" alt="entrylist"></p>
<ul>
<li>等待池，waitset</li>
</ul>
<p><img src="/2019/02/24/javamt/waitset.jpg" alt="waitset"></p>
<ul>
<li><p>notifyall</p>
<p>会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</p>
</li>
<li><p>notify</p>
<p>随机选取一个在等待池中的线程进入锁池去竞争获取锁的机会</p>
</li>
</ul>
<pre><code class="java">package com.interview.javabasic.thread;

import java.util.logging.Level;
import java.util.logging.Logger;

public class NotificationDemo {
    private volatile boolean go = false;

    public static void main(String args[]) throws InterruptedException {
        final NotificationDemo test = new NotificationDemo();

        Runnable waitTask = new Runnable(){

            @Override
            public void run(){
                try {
                    test.shouldGo();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot; finished Execution&quot;);
            }
        };

        Runnable notifyTask = new Runnable(){

            @Override
            public void run(){
                test.go();
                System.out.println(Thread.currentThread().getName() + &quot; finished Execution&quot;);
            }
        };

        Thread t1 = new Thread(waitTask, &quot;WT1&quot;); //will wait
        Thread t2 = new Thread(waitTask, &quot;WT2&quot;); //will wait
        Thread t3 = new Thread(waitTask, &quot;WT3&quot;); //will wait
        Thread t4 = new Thread(notifyTask,&quot;NT1&quot;); //will notify

        //starting all waiting thread
        t1.start();
        t2.start();
        t3.start();

        //pause to ensure all waiting thread started successfully
        Thread.sleep(200);

        //starting notifying thread
        t4.start();

    }
    /*
     * wait and notify can only be called from synchronized method or bock
     */
    private synchronized void shouldGo() throws InterruptedException {
        while(go != true){
            System.out.println(Thread.currentThread()
                    + &quot; is going to wait on this object&quot;);
            wait(); //release lock and reacquires on wakeup
            System.out.println(Thread.currentThread() + &quot; is woken up&quot;);
        }
        go = false; //resetting condition
    }

    /*
     * both shouldGo() and go() are locked on current object referenced by &quot;this&quot; keyword
     */
    private synchronized void go() {
        while (go == false){
            System.out.println(Thread.currentThread()
                    + &quot; is going to notify all or one thread waiting on this object&quot;);

            go = true; //making condition true for waiting thread
            //notify(); // only one out of three waiting thread WT1, WT2,WT3 will woke up
            notifyAll(); // all waiting thread  WT1, WT2,WT3 will woke up
        }

    }
}
</code></pre>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p><img src="/2019/02/24/javamt/yield.jpg" alt="yield"></p>
<pre><code class="java">package com.interview.javabasic.thread;

public class YieldDemo {
    public static void main(String[] args) {
        Runnable yieldTask = new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i &lt;= 10; i++) {
                    System.out.println(Thread.currentThread().getName() + i);
                    if (i == 5) {
                        Thread.yield();
                    }
                }
            }
        };
        Thread t1 = new Thread(yieldTask, &quot;A&quot;);
        Thread t2 = new Thread(yieldTask, &quot;B&quot;);
        t1.start();
        t2.start();
    }
}
</code></pre>
<h2 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h2><ul>
<li>stop()，supend()，resume() 太暴力，被弃用</li>
<li><p>无法清理，立即释放锁，产生问题</p>
</li>
<li><p>使用<strong>interrupt()</strong>，通知线程应该被中断</p>
<p>1、如果处于被阻塞状态，立即退出被阻塞状态，抛出InterruptedException</p>
<p>2、处于活动状态，中断标志置位true，继续活动不受影响</p>
</li>
</ul>
<pre><code class="java">package com.interview.javabasic.thread;

public class InterruptDemo {
    public static void main(String[] args) throws InterruptedException {
        Runnable interruptTask = new Runnable() {
            @Override
            public void run() {
                int i = 0;
                try {
                    //在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程
                    while (!Thread.currentThread().isInterrupted()) {
                        Thread.sleep(100); // 休眠100ms
                        i++;
                        System.out.println(Thread.currentThread().getName() + &quot; (&quot; + Thread.currentThread().getState() + &quot;) loop &quot; + i);
                    }
                } catch (InterruptedException e) {
                    //在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）
                    System.out.println(Thread.currentThread().getName() + &quot; (&quot; + Thread.currentThread().getState() + &quot;) catch InterruptedException.&quot;);
                }
            }
        };
        Thread t1 = new Thread(interruptTask, &quot;t1&quot;);
        System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;);

        t1.start();                      // 启动“线程t1”
        System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;);

        // 主线程休眠300ms，然后主线程给t1发“中断”指令。
        Thread.sleep(300);
        t1.interrupt();
        System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;);

        // 主线程休眠300ms，然后查看t1的状态。
        Thread.sleep(300);
        System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;);
    }
}
</code></pre>
<h2 id="线程的转换"><a href="#线程的转换" class="headerlink" title="线程的转换"></a>线程的转换</h2><p><img src="/2019/02/24/javamt/transfer.jpg" alt="transfer"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S Concepts</title>
    <url>/2020/06/07/k8sintro/</url>
    <content><![CDATA[<p>Concepts study here: </p>
<p><a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></p>
<h2 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a>kubeadm init</h2><ol>
<li><p>Kubeadmin init pre-flight check </p>
<p>Check the version of K8S/OS, user(root), host, port, tools etc. </p>
</li>
<li><p>Genrate key and certification </p>
<p>/etc/kubernetes/pki</p>
</li>
<li><p>Generate kubeconfig file </p>
<p>.kube/config    /etc/kubernetes/*.conf    KUBECONFIG</p>
</li>
<li><p>Generate manifest file</p>
<p>/etc/kubernetes/manifests</p>
</li>
<li><p>Download the image, wait for starting</p>
<p>Download from k8s.gcr.io </p>
<p>kubeadmin waits for response from localhost:6443.healthz (liveessProde, config by manifests/kube-piserver.yaml)</p>
</li>
<li><p>Save master configuration information </p>
</li>
<li><p>Mark master sign on current node</p>
</li>
<li><p>Config TLS</p>
</li>
<li><p>Install DNS and kube-proxy</p>
<p>deploy kube-proxy via daemonSet</p>
<p>deploy kibe-dns </p>
</li>
</ol>
<h2 id="kubeadm-join"><a href="#kubeadm-join" class="headerlink" title="kubeadm join"></a>kubeadm join</h2><p>add nodes to cluster </p>
<p>Disovery-token-ca-cert-hash: used by node to check master</p>
<p>token: used by master to check node</p>
<h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><p>Kubelet runs on all K8S nodes (including master), launched by OS init process(like systemd).</p>
<p>Node pod manager</p>
<p>config by /etc/systmd/system/kubelet.service.d/10 -kubeadm.conf</p>
<p><code>systemctl daemon-reload &amp; systemctl estart kubelet</code></p>
<h2 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h2><p>lauched by kubelet via static pod</p>
<p>Pod spec: /etc/kubernetes/manifests/kube-apiserver.yaml</p>
<h2 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h2><p>Lauched by kubelet via static pod</p>
<p>Communicate with api-server based on TLS</p>
<p>Runtime data saved in /var/lib/etcd</p>
<h2 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h2><p>Responsible for nodes/pod/namespace/service account/service endpoint/resource in cluster</p>
<p>/etc/kubernetes/manifests/kube-controller-manager.yaml</p>
<h2 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h2><p>Scheduler for pod</p>
<p>Lauched by kubelet via static pod</p>
<h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>Config: /var/lib/kube-proxy/config.conf (pod)</p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Common Class</title>
    <url>/2019/02/25/jclass/</url>
    <content><![CDATA[<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><h2 id="Error-amp-Exception"><a href="#Error-amp-Exception" class="headerlink" title="Error &amp; Exception"></a>Error &amp; Exception</h2><ul>
<li>error：致命系统错误，编辑器不检查</li>
<li>exception：程序可以处理的异常，可被捕获和恢复</li>
</ul>
<p><img src="/2019/02/25/jclass/exception.jpg" alt="exception"></p>
<ul>
<li>RuntimeException：不可预知的，程序应当避免</li>
<li>非RuntimeException：可预知，从编译器校验的异常</li>
</ul>
<h2 id="Common-Exception"><a href="#Common-Exception" class="headerlink" title="Common Exception"></a>Common Exception</h2><p><img src="/2019/02/25/jclass/commonexception.jpg" alt="commonexception"></p>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><ul>
<li>抛出异常：创建异常对象，交由运行时系统处理</li>
<li>捕获异常：寻找合适的异常处理器处理异常，否则终止程序</li>
</ul>
<pre><code class="java">package com.interview.javabasic.throwable;

public class ExceptionHandleMechanism {
    public static void doWork() {
        try {
            int i = 10 / 0;    //会抛出异常
            System.out.println(&quot;i=&quot; + i);
        } catch (ArithmeticException e) {
            //捕获 Exception
            System.out.println(&quot;ArithmeticException: &quot; + e);
        } finally {
            System.out.println(&quot;Finally&quot;);
        }
    }
    public static void main(String[] args) {
        doWork();
        System.out.println(&quot;Mission Complete&quot;);
    }
}
</code></pre>
<ul>
<li>finally先于return执行</li>
<li>尽量不要捕获通用异常</li>
<li>异常一定要处理，不要生吞异常</li>
<li>提早抛出，方便精确定位</li>
<li>延时处理，用更大的信息域处理异常</li>
</ul>
<h2 id="异常统一处理"><a href="#异常统一处理" class="headerlink" title="异常统一处理"></a>异常统一处理</h2><p><img src="/2019/02/25/jclass/handler.jpg" alt="handler"></p>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><ul>
<li>try-catch耗时大于if</li>
</ul>
<h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p><img src="/2019/02/25/jclass/listset.jpg" alt="listset"></p>
<ul>
<li>arraylist没有用到lock与synchronized，并发不安全</li>
<li>vector大量synchronized，效率低，并发性差，矛盾，弃用</li>
<li>没有用到lock与synchronized</li>
</ul>
<h2 id="Set实现两种比较"><a href="#Set实现两种比较" class="headerlink" title="Set实现两种比较"></a>Set实现两种比较</h2><ul>
<li>自然排序</li>
</ul>
<pre><code class="java">package com.interview.javabasic.collection;

import java.util.HashSet;
import java.util.Set;
import java.util.TreeSet;

public class Customer implements Comparable{
    private String name;

    private int age;

    public Customer(String name, int age) {
        this.age = age;
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (!(obj instanceof Customer))
            return false;
        final Customer other = (Customer) obj;

        if (this.name.equals(other.getName()) &amp;&amp; this.age == other.getAge())
            return true;
        else
            return false;
    }
    @Override
    public int compareTo(Object o) {
        Customer other = (Customer) o;

        // 先按照name属性排序
        if (this.name.compareTo(other.getName()) &gt; 0)
            return 1;
        if (this.name.compareTo(other.getName()) &lt; 0)
            return -1;

        // 在按照age属性排序
        if (this.age &gt; other.getAge())
            return 1;
        if (this.age &lt; other.getAge())
            return -1;
        return 0;

    }

    @Override
    public int hashCode() {
        int result;
        result = (name == null ? 0 : name.hashCode());
        result = 29 * result + age;
        return result;
    }
    public static void main(String[] args) {
        Set&lt;Customer&gt; set = new TreeSet&lt;Customer&gt;();
        Customer customer1 = new Customer(&quot;Tom&quot;, 16);
        Customer customer2 = new Customer(&quot;Tom&quot;, 15);
        set.add(customer1);
        set.add(customer2);
        for(Customer c : set){
            System.out.println(c.name + &quot; &quot; + c.age);
        }
    }
}
</code></pre>
<ul>
<li>客户化排序（共存优先）</li>
</ul>
<pre><code class="java">package com.interview.javabasic.collection;

import java.util.Comparator;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

public class CustomerComparator implements Comparator&lt;Customer&gt; {
    @Override
    public int compare(Customer c1, Customer c2) {
        if(c1.getName().compareTo(c2.getName())&gt;0)return -1;
        if(c1.getName().compareTo(c2.getName())&lt;0)return 1;
        return 0;
    }

    public static void main(String args[]){
        Set&lt;Customer&gt; set = new TreeSet&lt;Customer&gt;(new CustomerComparator());

        Customer customer1= new Customer(&quot;Tom&quot;,5);
        Customer customer2= new Customer(&quot;Tom&quot;,9);
        Customer customer3= new Customer(&quot;Tom&quot;,2);
        set.add(customer1);
        set.add(customer2);
        set.add(customer3);
        Iterator&lt;Customer&gt; it = set.iterator();
        while(it.hasNext()){
            Customer customer = it.next();
            System.out.println(customer.getName()+&quot; &quot;+customer.getAge());
        }
    }
}
</code></pre>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/2019/02/25/jclass/map.jpg" alt="map"></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li>散列表</li>
</ul>
<p><img src="/2019/02/25/jclass/hash.jpg" alt="hash"></p>
<ul>
<li>性能恶化O(1)-O(N)</li>
</ul>
<p><img src="/2019/02/25/jclass/hash2.jpg" alt="hash2"></p>
<ul>
<li>put</li>
</ul>
<p><img src="/2019/02/25/jclass/put.jpg" alt="put"></p>
<ul>
<li>hashmap ：减少碰撞</li>
<li>扰动函数</li>
<li>使用final对象，采用合适的equals，hashcode方法</li>
<li>多线程下，调整大小可能造成死锁</li>
</ul>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><ul>
<li>线程安全</li>
<li>涉及到修改hashtable的方法synchronized实现</li>
<li>串行化运行，效率低</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul>
<li>曾经：segment分段锁</li>
<li>当前</li>
</ul>
<p><img src="/2019/02/25/jclass/cmap.jpg" alt="cmap"></p>
<p><img src="/2019/02/25/jclass/cput.jpg" alt="cput"></p>
<p><img src="/2019/02/25/jclass/csum.jpg" alt="csum"></p>
<p><img src="/2019/02/25/jclass/sum.jpg" alt="sum"></p>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="AIO-BIO-NIO"><a href="#AIO-BIO-NIO" class="headerlink" title="AIO,BIO,NIO"></a>AIO,BIO,NIO</h2><ul>
<li>BIO</li>
</ul>
<p><img src="/2019/02/25/jclass/bio.jpg" alt="bio"></p>
<pre><code class="java">package com.interview.javabasic.io;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class BIOPlainEchoServer {
    public void serve(int port) throws IOException {
        //将ServerSocket绑定到指定的端口里
        final ServerSocket socket = new ServerSocket(port);
        while (true) {
            //阻塞直到收到新的客户端连接
            final Socket clientSocket = socket.accept();
            System.out.println(&quot;Accepted connection from &quot; + clientSocket);
            //创建一个子线程去处理客户端的请求
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) {
                        PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true);
                        //从客户端读取数据并原封不动回写回去
                        while (true) {
                            writer.println(reader.readLine());
                            writer.flush();
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }

    public void improvedServe(int port) throws IOException {
        //将ServerSocket绑定到指定的端口里
        final ServerSocket socket = new ServerSocket(port);
        //创建一个线程池
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (true) {
            //阻塞直到收到新的客户端连接
            final Socket clientSocket = socket.accept();
            System.out.println(&quot;Accepted connection from &quot; + clientSocket);
            //将请求提交给线程池去执行
            executorService.execute(() -&gt; {
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) {
                    PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true);
                    //从客户端读取数据并原封不动回写回去
                    while (true) {
                        writer.println(reader.readLine());
                        writer.flush();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
</code></pre>
<ul>
<li>NIO</li>
</ul>
<p><img src="/2019/02/25/jclass/nio.jpg" alt="nio"></p>
<p>核心：</p>
<ul>
<li>channels</li>
<li>buffers</li>
<li>selectors</li>
</ul>
<p><img src="/2019/02/25/jclass/selector.jpg" alt="selector"></p>
<pre><code class="java">package com.interview.javabasic.io;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class NIOPlainEchoServer {
    public void serve(int port) throws IOException {
        System.out.println(&quot;Listening for connections on port &quot; + port);
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        ServerSocket ss = serverChannel.socket();
        InetSocketAddress address = new InetSocketAddress(port);
        //将ServerSocket绑定到指定的端口里
        ss.bind(address);
        serverChannel.configureBlocking(false);
        Selector selector = Selector.open();
        //将channel注册到Selector里，并说明让Selector关注的点，这里是关注建立连接这个事件
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        while (true) {
            try {
                //阻塞等待就绪的Channel，即没有与客户端建立连接前就一直轮询
                selector.select();
            } catch (IOException ex) {
                ex.printStackTrace();
                //代码省略的部分是结合业务，正确处理异常的逻辑
                break;
            }
            //获取到Selector里所有就绪的SelectedKey实例,每将一个channel注册到一个selector就会产生一个SelectedKey
            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();
            while (iterator.hasNext()) {
                SelectionKey key = (SelectionKey) iterator.next();
                //将就绪的SelectedKey从Selector中移除，因为马上就要去处理它，防止重复执行
                iterator.remove();
                try {
                    //若SelectedKey处于Acceptable状态
                    if (key.isAcceptable()) {
                        ServerSocketChannel server = (ServerSocketChannel) key.channel();
                        //接受客户端的连接
                        SocketChannel client = server.accept();
                        System.out.println(&quot;Accepted connection from &quot; + client);
                        client.configureBlocking(false);
                        //像selector注册socketchannel，主要关注读写，并传入一个ByteBuffer实例供读写缓存
                        client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(100));
                    }
                    //若SelectedKey处于可读状态
                    if (key.isReadable()) {
                        SocketChannel client = (SocketChannel) key.channel();
                        ByteBuffer output = (ByteBuffer) key.attachment();
                        //从channel里读取数据存入到ByteBuffer里面
                        client.read(output);
                    }
                    //若SelectedKey处于可写状态
                    if (key.isWritable()) {
                        SocketChannel client = (SocketChannel) key.channel();
                        ByteBuffer output = (ByteBuffer) key.attachment();
                        output.flip();
                        //将ByteBuffer里的数据写入到channel里
                        client.write(output);
                        output.compact();
                    }
                } catch (IOException ex) {
                    key.cancel();
                    try {
                        key.channel().close();
                    } catch (IOException cex) {
                    }
                }
            }
        }
    }
}
</code></pre>
<ul>
<li>AIO</li>
</ul>
<p><img src="/2019/02/25/jclass/aio.jpg" alt="aio"></p>
<p>实现：</p>
<ul>
<li>基于回调，实现completionhandler，触发回调函数</li>
<li>返回future</li>
</ul>
<p><img src="/2019/02/25/jclass/compare.jpg" alt="compare"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Tips1</title>
    <url>/2019/01/10/linux/</url>
    <content><![CDATA[<h1 id="Linux体系架构"><a href="#Linux体系架构" class="headerlink" title="Linux体系架构"></a>Linux体系架构</h1><p><img src="/2019/01/10/linux/struct.jpg" alt="struct"></p>
<h1 id="查找检索"><a href="#查找检索" class="headerlink" title="查找检索"></a>查找检索</h1><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><blockquote>
<p>find path [options] params</p>
<p>find -name “file*”        //当前目录</p>
<p>find / -name “file.txt”        //全局</p>
</blockquote>
<p>在指定目录下查找文件</p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><blockquote>
<p>grep “haha” file.txt</p>
</blockquote>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ul>
<li>可将指令连接</li>
<li><p>|</p>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2></li>
</ul>
<p><img src="/2019/01/10/linux/awk.jpg" alt="awk"></p>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><ul>
<li>sed [option] command filename</li>
<li>stream editor</li>
<li>适合行内容编辑</li>
</ul>
<p><img src="/2019/01/10/linux/sed.jpg" alt="sed"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Memory Model</title>
    <url>/2019/02/22/memory/</url>
    <content><![CDATA[<h1 id="JVM内存模型架构"><a href="#JVM内存模型架构" class="headerlink" title="JVM内存模型架构"></a>JVM内存模型架构</h1><p><img src="/2019/02/22/memory/jvm.jpg" alt="jvm"></p>
<h2 id="程序计数器（PC）"><a href="#程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a>程序计数器（PC）</h2><ul>
<li>当前线程所执行的字节码行号指示器</li>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>和线程一一对应</li>
<li>只对Java方法计数，如果是Native方法则计数器值为Undefined</li>
<li>不会发生内存泄漏</li>
</ul>
<h2 id="Java虚拟机栈（Stack）"><a href="#Java虚拟机栈（Stack）" class="headerlink" title="Java虚拟机栈（Stack）"></a>Java虚拟机栈（Stack）</h2><ul>
<li>Java方法执行的内存模型</li>
<li>包含多个栈帧</li>
<li>与方法对应</li>
</ul>
<h3 id="java-lang-StackOverflowError"><a href="#java-lang-StackOverflowError" class="headerlink" title="java.lang.StackOverflowError"></a>java.lang.StackOverflowError</h3><p><img src="/2019/02/22/memory/stack.jpg" alt="stack"></p>
<ul>
<li>局部变量表：包含方法执行过程中所有的变量</li>
<li>操作数栈：入栈，出栈，复制，交换，产生消费变量</li>
</ul>
<p>eg.递归过深，栈帧超过虚拟栈深度，就会报错</p>
<h3 id="java-lang-OutOfMemoryError"><a href="#java-lang-OutOfMemoryError" class="headerlink" title="java.lang.OutOfMemoryError"></a>java.lang.OutOfMemoryError</h3><p>如果虚拟机栈可以动态扩展，并超出内存，就会报此错误</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>native方法使用</p>
<h2 id="元空间与永久代"><a href="#元空间与永久代" class="headerlink" title="元空间与永久代"></a>元空间与永久代</h2><p>MetaSpace &amp; PermGen</p>
<p>Java8以后，元空间替代了永久代，PermGen Space报错消失</p>
<ul>
<li><p>存储Class相关信息</p>
</li>
<li><p><strong>元空间使用本地内存，永久代使用jvm内存</strong></p>
</li>
<li>类信息加载空间</li>
<li>线程共享</li>
</ul>
<h3 id="MetaSpace相比PermGen优势"><a href="#MetaSpace相比PermGen优势" class="headerlink" title="MetaSpace相比PermGen优势"></a>MetaSpace相比PermGen优势</h3><ul>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li>
<li>永久代为GC带来复杂度</li>
</ul>
<h2 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h2><ul>
<li>JVM内存中最大一块</li>
<li>线程共享</li>
<li>对象实例的分配区域</li>
<li>GC管理的主要区域</li>
</ul>
<p><img src="/2019/02/22/memory/heap.PNG" alt="heap"></p>
<h2 id="性能调优参数"><a href="#性能调优参数" class="headerlink" title="性能调优参数"></a>性能调优参数</h2><ul>
<li>-Xss：规定每个线程虚拟机（堆栈）大小，影响并发线程数大小（256K）</li>
<li>-Xms：堆的初始值</li>
<li><p>-Xmx：堆动态扩容能达到的最大值</p>
</li>
<li><p>尽量Xms Xmx设置一样，防止内存抖动</p>
</li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ul>
<li>静态存储：编译时确定每个数据目标在运行时的存储空间需求（无可变数据结构，无嵌套递归）</li>
<li>栈式存储：数据区需求在编译时未知，运行时模块入口前决定</li>
<li>堆式存储：编译时或运行时模块入口都无法确定，动态分配</li>
</ul>
<h2 id="Java内存模型中堆与栈"><a href="#Java内存模型中堆与栈" class="headerlink" title="Java内存模型中堆与栈"></a>Java内存模型中堆与栈</h2><ul>
<li>联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址</li>
</ul>
<p><img src="/2019/02/22/memory/stackandheap.jpg" alt="stackandheap"></p>
<ul>
<li><p>区别：</p>
<p>1、栈自动释放，堆需要GC</p>
<p>2、栈空间较堆小</p>
<p>3、栈产生的内存碎片远小于堆</p>
<p>4、栈支持静态和动态分配，堆仅支持动态分配</p>
<p>5、栈效率较高</p>
</li>
</ul>
<h2 id="Hello-World实例"><a href="#Hello-World实例" class="headerlink" title="Hello World实例"></a>Hello World实例</h2><p><img src="/2019/02/22/memory/hello.jpg" alt="hello"></p>
<p><img src="/2019/02/22/memory/hellod.jpg" alt="hellod"></p>
<h2 id="JDK版本问题"><a href="#JDK版本问题" class="headerlink" title="JDK版本问题"></a>JDK版本问题</h2><ul>
<li>intern()</li>
</ul>
<p><img src="/2019/02/22/memory/intern.jpg" alt="intern"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty Demo</title>
    <url>/2019/06/11/nettydemo/</url>
    <content><![CDATA[<h1 id="初识Netty"><a href="#初识Netty" class="headerlink" title="初识Netty"></a>初识Netty</h1><p>Netty是一个提供了易于使用的API的客户端/服务器框架</p>
<ul>
<li>高并发</li>
<li>NIO（非阻塞IO）</li>
<li>传输快，零拷贝</li>
</ul>
<p><img src="/2019/06/11/nettydemo/n1.jpg" alt="n1"></p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>线程访问资源，该资源是否准备就绪的一种处理方式</p>
<ul>
<li><p>阻塞：如果资源占用，则一直等待</p>
</li>
<li><p>非阻塞：如果资源占用，则返回一个结果</p>
</li>
</ul>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>访问数据的一种机制</p>
<p><img src="/2019/06/11/nettydemo/n2.jpg" alt="n2"></p>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><ul>
<li><p>BIO</p>
<p>同步阻塞IO，Block IO</p>
<p>并发处理能力差，依赖网速带宽</p>
</li>
</ul>
<p><img src="/2019/06/11/nettydemo/n3.jpg" alt="n3"></p>
<p>通过增加线程，一应一答，改良后引入线程池</p>
<ul>
<li><p>NIO</p>
<p>非堵塞IO，Non-Block IO</p>
<p>线程会做其他事情，定时再去查看资源情况</p>
<p>引入selector多路复用选择器，buffer等</p>
</li>
</ul>
<p><img src="/2019/06/11/nettydemo/n4.jpg" alt="n4"></p>
<p>客户端增多，不会影响性能</p>
<ul>
<li><p>AIO</p>
<p>异步非阻塞</p>
<p>线程做其他事情，释放资源者通知线程</p>
</li>
</ul>
<p><img src="/2019/06/11/nettydemo/n5.jpg" alt="n5"></p>
<p><img src="/2019/06/11/nettydemo/n6.jpg" alt="n6"></p>
<h2 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h2><ul>
<li>单线程模型：所有操作由一个NIO单线程处理</li>
</ul>
<p><img src="/2019/06/11/nettydemo/n7.jpg" alt="n7"></p>
<ul>
<li>多线程模型：由一组NIO线程处理IO操作</li>
</ul>
<p><img src="/2019/06/11/nettydemo/n8.jpg" alt="n8"></p>
<ul>
<li>主从线程模型：一组线程池接受请求，一组线程池处理IO</li>
</ul>
<p><img src="/2019/06/11/nettydemo/n9.jpg" alt="n9"></p>
<h1 id="简单服务器编写"><a href="#简单服务器编写" class="headerlink" title="简单服务器编写"></a>简单服务器编写</h1><p>引入依赖</p>
<pre><code class="xml">&lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
            &lt;version&gt;4.1.25.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">public class HelloServer {
    public static void main(String[] args) throws Exception{

        //declare a thread group, to accept the connect from the client
        //bossgroup
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        //workergroup,do the task from the bossgroup
        EventLoopGroup workerGroup = new NioEventLoopGroup();


        try {
            //create the netty server
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGroup,workerGroup)
                    .channel(NioServerSocketChannel.class)   //set nio pattern
                    .childHandler(new HelloServerIni());

            //start the server and set the port
            ChannelFuture channelFuture = serverBootstrap.bind(8088).sync();

            //listen the closed channel and set sync
            channelFuture.channel().closeFuture().sync();
        }finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
</code></pre>
<p>每个channel由多个handler组成管道pipeline</p>
<p><img src="/2019/06/11/nettydemo/n10.jpg" alt="n10"></p>
<pre><code class="java">public class HelloServerIni extends ChannelInitializer&lt;SocketChannel&gt; {
    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        //get pipeline
        ChannelPipeline channelPipeline = channel.pipeline();
        //add handler by pipeline
        channelPipeline.addLast(&quot;HttpServerCodec&quot;,new HttpServerCodec());
        channelPipeline.addLast(&quot;customHandler&quot;,new CustomHandler());

    }
}
</code></pre>
<pre><code class="java">public class CustomHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; {
    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, HttpObject httpObject) throws Exception {

        Channel channel = channelHandlerContext.channel();

        if (httpObject instanceof HttpRequest){

            System.out.println(channel.remoteAddress());

            ByteBuf content = Unpooled.copiedBuffer(&quot;Hello Netty&quot;, CharsetUtil.UTF_8);

            FullHttpResponse fullHttpResponse =
                    new DefaultFullHttpResponse(HttpVersion.HTTP_1_0,
                            HttpResponseStatus.OK,
                            content);

            fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,&quot;text/plain&quot;);
            fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());

            channel.writeAndFlush(fullHttpResponse);
        }

    }
}
</code></pre>
<h1 id="Netty生命周期"><a href="#Netty生命周期" class="headerlink" title="Netty生命周期"></a>Netty生命周期</h1><p><img src="/2019/06/11/nettydemo/n11.jpg" alt="n11"></p>
<p><img src="/2019/06/11/nettydemo/n12.jpg" alt="n12"></p>
<h1 id="实时通讯Demo"><a href="#实时通讯Demo" class="headerlink" title="实时通讯Demo"></a>实时通讯Demo</h1><p>三种实现方式：</p>
<ul>
<li>Ajax轮询</li>
<li>Long pull</li>
<li>websocket</li>
</ul>
<h2 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h2><p>chatserver</p>
<pre><code class="java">public class ChatServer {
    public static void main(String[] args) throws Exception{
        EventLoopGroup maingroup = new NioEventLoopGroup();
        EventLoopGroup subgroup = new NioEventLoopGroup();

        try {

            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(maingroup,subgroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChatServerIni());

            ChannelFuture channelFuture = serverBootstrap.bind(8088).sync();
            channelFuture.channel().closeFuture().sync();

        }finally {
            maingroup.shutdownGracefully();
            subgroup.shutdownGracefully();

        }

    }
}
</code></pre>
<p>chatserverini</p>
<pre><code class="java">public class ChatServerIni extends ChannelInitializer&lt;SocketChannel&gt; {

    @Override
    protected void initChannel(SocketChannel channel) throws Exception {
        ChannelPipeline channelPipeline = channel.pipeline();

        channelPipeline.addLast(new HttpServerCodec());

        //support write big data stream
        channelPipeline.addLast(new ChunkedWriteHandler());

        //max contend length
        //aggregate the http request and http response
        channelPipeline.addLast(new HttpObjectAggregator(1024*64));

        //--------------to support http---------------------

        //to set the websocket route
        //do something about handshaking(close, ping, pong)
        channelPipeline.addLast(new WebSocketServerProtocolHandler(&quot;/ws&quot;));

        //custom handler
        channelPipeline.addLast(new ChatHandler());
    }
}
</code></pre>
<p>chatserver handler</p>
<pre><code class="java">public class ChatHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; {

    //manage the clients channels
    private static ChannelGroup clients = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {

        //add client channel to channel group
        clients.add(ctx.channel());
    }

    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        super.handlerRemoved(ctx);

        System.out.println(ctx.channel().id().asLongText());
        System.out.println(ctx.channel().id().asShortText());

    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {

        String content = msg.text();
        System.out.println(content);

        for (Channel channel: clients){
            channel.writeAndFlush(
                    new TextWebSocketFrame(&quot;[server get message:]&quot;
                            + LocalDateTime.now() + content));

        }

//        clients.writeAndFlush (
//                new TextWebSocketFrame(&quot;[server get message:]&quot;
//                + LocalDateTime.now() + content));
    }
}
</code></pre>
<h2 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h2><pre><code class="js">var socket = new WebSocket(&quot;ws://[ip]:[port]&quot;); 
</code></pre>
<p>生命周期：</p>
<ul>
<li>onopen()</li>
<li>onmessage()</li>
<li>onerror()</li>
<li>onclose()</li>
</ul>
<p>主动方法：</p>
<ul>
<li>Socket.send()</li>
<li>Socket.close()</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;div&gt;send message:&lt;/div&gt;
        &lt;input type=&quot;text&quot; id=&quot;msgContent&quot; /&gt;
        &lt;input type=&quot;button&quot; value=&quot;send&quot; onclick=&quot;CHAT.chat()&quot;/&gt;

        &lt;div&gt;get message:&lt;/div&gt;
        &lt;div id=&quot;receiveMsg&quot; style=&quot;background-color: antiquewhite;&quot;&gt;&lt;/div&gt;

        &lt;script type=&quot;application/javascript&quot;&gt;

            window.CHAT = {
                socket: null,
                init: function(){
                    if(window.WebSocket){
                        CHAT.socket = new WebSocket(&quot;ws://127.0.0.1:8088/ws&quot;);
                        CHAT.socket.onopen = function(){
                            console.log(&quot;on open&quot;);
                        };
                        CHAT.socket.onclose = function(){
                            console.log(&quot;on close&quot;);
                        };
                        CHAT.socket.onerror = function(){
                            console.log(&quot;on error&quot;);
                        };
                        CHAT.socket.onmessage = function(e){
                            console.log(&quot;on message&quot; + e.data);
                            var receiveMsg = document.getElementById(&quot;receiveMsg&quot;);
                            var html = receiveMsg.innerHTML;
                            receiveMsg.innerHTML = html + &quot;&lt;br/&gt;&quot; + e.data;
                        };

                    }else{
                        alert(&quot;no support for websocket&quot;);
                    }
                },
                chat: function(){
                    var msg = document.getElementById(&quot;msgContent&quot;);
                    CHAT.socket.send(msg.value);
                }
            }
            CHAT.init();

        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p><img src="/2019/06/11/nettydemo/n13.jpg" alt="n13"></p>
<h2 id="Springboot中整合"><a href="#Springboot中整合" class="headerlink" title="Springboot中整合"></a>Springboot中整合</h2><p>修改chatserver</p>
<pre><code class="java">@Component
public class ChatServer {

    private static class SingletionChatServer{
        static final ChatServer instance = new ChatServer();
    }

    public static ChatServer getInstance(){
        return SingletionChatServer.instance;
    }

    private EventLoopGroup maingroup;
    private EventLoopGroup subgroup;
    private ChannelFuture channelFuture;
    private ServerBootstrap serverBootstrap;

    public ChatServer() {
        maingroup = new NioEventLoopGroup();
        subgroup = new NioEventLoopGroup();
        serverBootstrap = new ServerBootstrap();
        serverBootstrap.group(maingroup,subgroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChatServerIni());

    }

    public void start() {
        this.channelFuture = serverBootstrap.bind(8088);
        System.err.println(&quot;netty started&quot;);
    }
}
</code></pre>
<p>在springapplication同级目录下创建nettybooter类</p>
<pre><code class="java">@Component
public class NettyBooter implements ApplicationListener&lt;ContextRefreshedEvent&gt; {
    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
        if(contextRefreshedEvent.getApplicationContext().getParent() == null){
            try {
                ChatServer.getInstance().start();
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }
}
</code></pre>
<h1 id="项目部分代码"><a href="#项目部分代码" class="headerlink" title="项目部分代码"></a>项目部分代码</h1><pre><code class="java">package hku.knowname.weasel.chatmanagement.chatserver;

import hku.knowname.weasel.chatmanagement.ChatService.ChatService;
import hku.knowname.weasel.chatmanagement.SpringUtil;
import hku.knowname.weasel.chatmanagement.enums.MsgActionEnum;
import hku.knowname.weasel.chatmanagement.utils.JsonUtils;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
import io.netty.util.concurrent.GlobalEventExecutor;
import org.apache.commons.lang3.StringUtils;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class ChatHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; {

    //manage the clients channels
    public static ChannelGroup clients = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {

        //add client channel to channel group
        clients.add(ctx.channel());
    }

    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        super.handlerRemoved(ctx);

        System.out.println(ctx.channel().id().asLongText());
        System.out.println(ctx.channel().id().asShortText());

    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {

        String content = msg.text();
//        System.out.println(content);

        Channel currentChannel = ctx.channel();

        //1. get the message from client
        DataContent dataContent = JsonUtils.jsonToPojo(content, DataContent.class);
        Integer action = dataContent.getAction();

        //2. judge the message type
        if (action == MsgActionEnum.CONNECT.type){
            // 2.1 link the channel and user id
            int sendID = dataContent.getChatMsg().getSendId();
            UserChannelRel.put(sendID, currentChannel);

            //test
            for (Channel c : clients){
                System.out.println(c.id().asLongText());
            }
            UserChannelRel.output();

        }else if (action == MsgActionEnum.CHAT.type){
            ChatMsg chatMsg = dataContent.getChatMsg();
            String msgText = chatMsg.getMsg();
            int receivedid = chatMsg.getReceiveId();
            int sendid = chatMsg.getSendId();

            // 2.2 chat type: save the chat message in db, tag the status[no read]
            //save chat to db
            ChatService chatService = (ChatService) SpringUtil.getBean(&quot;chatServiceImp&quot;);

            String msgId = chatService.saveMsg(chatMsg);
            chatMsg.setChatId(msgId);

            //send msg
            Channel receiverChannel = UserChannelRel.get(receivedid);
            if (receiverChannel == null){
                // receiver user offline , send msg TODO
            }else {
                // find this receiver in channel group
                Channel findChannel = clients.find(receiverChannel.id());
                if (findChannel != null){
                    //user online
                    receiverChannel.writeAndFlush(
                            new TextWebSocketFrame(JsonUtils.objectToJson(chatMsg)));

                }else {
                    // user offline TODO

                }
            }




        }else if (action == MsgActionEnum.SIGNED.type){
            // 2.3 read type: change the status to the [already read]
            ChatService chatService = (ChatService) SpringUtil.getBean(&quot;chatServiceImp&quot;);
            //extand means the chatid in the signed type, with comma
            String chatidstr = dataContent.getExtand();
            String[] chatids = chatidstr.split(&quot;,&quot;);
            List&lt;String&gt; chatidList = new ArrayList&lt;&gt;();
            for (String mid: chatids){
                if (StringUtils.isNotBlank(mid)){
                    chatidList.add(mid);
                }
            }
            System.out.println(chatidList.toString());

            if (chatidList != null &amp;&amp; !chatidList.isEmpty() &amp;&amp; chatidList.size()&gt;0){
                //sign the msg batch
                chatService.updateMsgSigned(chatidList);

            }
        }else if (action == MsgActionEnum.KEEPALIVE.type){
            // 2.4 heartbeat
        }

//        for (Channel channel: clients){
//            channel.writeAndFlush(
//                    new TextWebSocketFrame(&quot;[server get message:]&quot;
//                            + LocalDateTime.now() + content));
//        }

        clients.writeAndFlush (
                new TextWebSocketFrame(&quot;[server get message:]&quot;
                + LocalDateTime.now() + content));


    }
}

</code></pre>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ Basic</title>
    <url>/2019/05/28/mq/</url>
    <content><![CDATA[<p>没办法，港大不放我实习，那就只能在毕设时候尽量多看点东西啦orz</p>
<h1 id="主流消息中间件"><a href="#主流消息中间件" class="headerlink" title="主流消息中间件"></a>主流消息中间件</h1><h2 id="Active-MQ"><a href="#Active-MQ" class="headerlink" title="Active MQ"></a>Active MQ</h2><p>老牌、性能一般</p>
<p>集群架构：</p>
<p><img src="/2019/05/28/mq/struct.jpg" alt="struct"></p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul>
<li>追求吞吐量</li>
<li>面向大数据</li>
<li>对重复、丢失、错误没有严格要求</li>
<li>基于Pull的模式</li>
<li>不支持事务</li>
</ul>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><ul>
<li>适合大规模分布式</li>
<li>源于Kafka</li>
<li>对消息可靠传输与事务做了优化</li>
<li>维护困难</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul>
<li>Erlang开发</li>
<li>基于AMQP</li>
<li>数据一致性、稳定性、安全性很好</li>
</ul>
<p><img src="/2019/05/28/mq/struct2.jpg" alt="struct2"></p>
<h1 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h1><ul>
<li>开源的消息代理和队列服务器</li>
<li>基于AMQP</li>
<li>用普通协议在完全不同的应用间共享数据</li>
<li>配置 ebin/rabbit.app</li>
</ul>
<p>高性能原因</p>
<ul>
<li>Erlang语言效率高，与原生socket一样的延迟</li>
</ul>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><ul>
<li>高级消息队列协议</li>
<li>一种规范</li>
</ul>
<p><img src="/2019/05/28/mq/amqp.jpg" alt="amqp"></p>
<h3 id="核心规范"><a href="#核心规范" class="headerlink" title="核心规范"></a>核心规范</h3><ul>
<li>Server：又称Broker，接收客户端连接，实现AMQP实体服务。</li>
<li>Connection：连接，应用程序与Broker的网络连接。</li>
<li>Channel：网络通道，几乎所有操作都在Chanel中进行，是消息读写的通道，客户端可以建立多个Channel，每个Channel代表一个会话任务。</li>
<li>Message：用于服务器之间、应用之间传递数据。由properties和body组成。</li>
<li>Virtual Host：用于逻辑隔离，最上层路由，一个Virtual Host可以有若干个Exchange和Queue，但不能同名。</li>
<li>Exchange：交换机，接收消息，根据路由键转发到绑定的队列。</li>
<li>Bingding：Exchange和Queue之间的虚拟连接，binding中可以包含routing key。</li>
<li>Routing Key：一个路由规则，虚拟机可以由此确定如何路由消息。</li>
<li>Queue：消息队列，保存消息并转发给消费者。</li>
</ul>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="/2019/05/28/mq/struc.jpg" alt="struc"></p>
<p><img src="/2019/05/28/mq/ex.jpg" alt="ex"></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><blockquote>
<p>rabbitmq-server start &amp;   //后台启动</p>
<p>lsof -i:5672            //查看端口</p>
</blockquote>
<blockquote>
<p>rabbitmqctl stop_app</p>
</blockquote>
<blockquote>
<p>rabbitmq-plugins list</p>
</blockquote>
<blockquote>
<p>rabbitmq-plugins enable rabbitmq_management</p>
</blockquote>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><blockquote>
<p>rabbitmqctl stop_app</p>
<p>rabbitmqctl start_app</p>
<p>rabbitmqctl status</p>
<p>rabbitmqctl List_queues    //查看所有队列信息</p>
<p>rabbitmqctl reset     //清除所有数据，stop之后使用</p>
</blockquote>
<h2 id="简单概念"><a href="#简单概念" class="headerlink" title="简单概念"></a>简单概念</h2><ul>
<li>ConnectionFactory         //获取连接工厂</li>
<li>Connection                     //连接</li>
<li>Channel                          //数据通信通道，接受或发送消息</li>
<li>Queue                            //消息存储队列</li>
<li>Producer &amp; Consumer   //生产者、消费者</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>producer</p>
<pre><code class="java">        //1. create the connection factory and config it
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setPort(5672);
        connectionFactory.setHost(&quot;127.0.0.1&quot;);
        connectionFactory.setVirtualHost(&quot;/&quot;);


        //2. create connection by connection factory
        Connection connection = connectionFactory.newConnection();

        //3. create channel by the connection
        Channel channel = connection.createChannel();

        //4. send data by the channel
        for (int i = 0; i&lt;5; i++){
            String msg = &quot;Hello RbbitMQ&quot;;
            channel.basicPublish(&quot;&quot;,&quot;test001&quot;,null,msg.getBytes());
        }

        //5. close channel connection
        channel.close();
        connection.close();
</code></pre>
<p><img src="/2019/05/28/mq/mq0.jpg" alt="mq0"></p>
<p>第一个参数 exchange默认””则选择default交换机</p>
<p>但是routingkey必须名字相同才会被路由</p>
<p><img src="/2019/05/28/mq/mq7.jpg" alt="mq7"></p>
<p>consumer</p>
<pre><code class="java">        //1. create the connection factory and config it
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setPort(5672);
        connectionFactory.setHost(&quot;127.0.0.1&quot;);
        connectionFactory.setVirtualHost(&quot;/&quot;);


        //2. create connection by connection factory
        Connection connection = connectionFactory.newConnection();

        //3. create channel by the connection
        Channel channel = connection.createChannel();

        //4. declare queue
        String queuename = &quot;test001&quot;;
        channel.queueDeclare(queuename,true,false,false,null);

        //5. create the consumer
        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);
        //6. set the channel
        channel.basicConsume(queuename,true,queueingConsumer);

        //7. get data
        while (true){
            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();
            String body = new String(delivery.getBody());
            System.err.println(body);
//            Envelope envelope = delivery.getEnvelope();
        }
</code></pre>
<p><img src="/2019/05/28/mq/mq1.jpg" alt="mq1"></p>
<p>运行代码：先启动consumer，producer启动后执行完成（consumer接收到消息）</p>
<p><img src="/2019/05/28/mq/mq3.jpg" alt="mq3"></p>
<p><img src="/2019/05/28/mq/mq2.jpg" alt="mq2"></p>
<p>先启动producer，消息存储在队列中</p>
<p><img src="/2019/05/28/mq/mq4.jpg" alt="mq4"></p>
<p><img src="/2019/05/28/mq/mq5.jpg" alt="mq5"></p>
<p>再启动consumer：消息被消费</p>
<p><img src="/2019/05/28/mq/mq6.jpg" alt="mq6"></p>
<h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p><img src="/2019/05/28/mq/mq8.jpg" alt="mq8"></p>
<ul>
<li>交换机类型Type: direct, topic, fanout, headers</li>
<li>Durability: true为持久化</li>
<li>Auto Delete: 当最后一个绑定在Exchange上的队列删除后，自动删除这个Exchange</li>
<li>Internal：当前Exchange是否用于内部使用，默认false</li>
<li>Arguments：扩展参数定制化使用</li>
</ul>
<h3 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h3><p>所有发送到Direct Exchange的消息被转发到RouteKey中指定的Queue</p>
<p><img src="/2019/05/28/mq/mq9.jpg" alt="mq9"></p>
<p>consumer</p>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer4DirectExchange {

    public static void main(String[] args) throws Exception {


        ConnectionFactory connectionFactory = new ConnectionFactory() ;  

        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        connectionFactory.setAutomaticRecoveryEnabled(true);
        connectionFactory.setNetworkRecoveryInterval(3000);
        Connection connection = connectionFactory.newConnection();

        Channel channel = connection.createChannel();  
        //4 声明
        String exchangeName = &quot;test_direct_exchange&quot;;
        String exchangeType = &quot;direct&quot;;
        String queueName = &quot;test_direct_queue&quot;;
        String routingKey = &quot;test.direct&quot;;

        //表示声明了一个交换机
        channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null);
        //表示声明了一个队列
        channel.queueDeclare(queueName, false, false, false, null);
        //建立一个绑定关系:
        channel.queueBind(queueName, exchangeName, routingKey);

        //durable 是否持久化消息
        QueueingConsumer consumer = new QueueingConsumer(channel);
        //参数：队列名称、是否自动ACK、Consumer
        channel.basicConsume(queueName, true, consumer);  
        //循环获取消息  
        while(true){  
            //获取消息，如果没有消息，这一步将会一直阻塞  
            Delivery delivery = consumer.nextDelivery();  
            String msg = new String(delivery.getBody());    
            System.out.println(&quot;收到消息：&quot; + msg);  
        } 
    }
}
</code></pre>
<p>producer</p>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Producer4DirectExchange {


    public static void main(String[] args) throws Exception {

        //1 创建ConnectionFactory
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        //2 创建Connection
        Connection connection = connectionFactory.newConnection();
        //3 创建Channel
        Channel channel = connection.createChannel();  
        //4 声明
        String exchangeName = &quot;test_direct_exchange&quot;;
        String routingKey = &quot;test.direct111&quot;;
        //5 发送

        String msg = &quot;Hello World RabbitMQ 4  Direct Exchange Message 111 ... &quot;;
        channel.basicPublish(exchangeName, routingKey , null , msg.getBytes());         

    }    
}
</code></pre>
<h3 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h3><p>所有发送到topic exchange 的消息，被转发到所关心的routekey中指定topic的queue中</p>
<p>exchange将routekey和某个topic进行模糊匹配，此时，队列需要绑定一个topic</p>
<p>log.#     -&gt;          log.xx.xxx</p>
<p>log.*      -&gt;         log.xxx</p>
<p><img src="/2019/05/28/mq/mq10.jpg" alt="mq10"></p>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer4TopicExchange {

    public static void main(String[] args) throws Exception {


        ConnectionFactory connectionFactory = new ConnectionFactory() ;  

        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        connectionFactory.setAutomaticRecoveryEnabled(true);
        connectionFactory.setNetworkRecoveryInterval(3000);
        Connection connection = connectionFactory.newConnection();

        Channel channel = connection.createChannel();  
        //4 声明
        String exchangeName = &quot;test_topic_exchange&quot;;
        String exchangeType = &quot;topic&quot;;
        String queueName = &quot;test_topic_queue&quot;;
        //String routingKey = &quot;user.*&quot;;
        String routingKey = &quot;user.*&quot;;
        // 1 声明交换机 
        channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null);
        // 2 声明队列
        channel.queueDeclare(queueName, false, false, false, null);
        // 3 建立交换机和队列的绑定关系:
        channel.queueBind(queueName, exchangeName, routingKey);

        //durable 是否持久化消息
        QueueingConsumer consumer = new QueueingConsumer(channel);
        //参数：队列名称、是否自动ACK、Consumer
        channel.basicConsume(queueName, true, consumer);  
        //循环获取消息  
        while(true){  
            //获取消息，如果没有消息，这一步将会一直阻塞  
            Delivery delivery = consumer.nextDelivery();  
            String msg = new String(delivery.getBody());    
            System.out.println(&quot;收到消息：&quot; + msg);  
        } 
    }
}

</code></pre>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Producer4TopicExchange {


    public static void main(String[] args) throws Exception {

        //1 创建ConnectionFactory
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        //2 创建Connection
        Connection connection = connectionFactory.newConnection();
        //3 创建Channel
        Channel channel = connection.createChannel();  
        //4 声明
        String exchangeName = &quot;test_topic_exchange&quot;;
        String routingKey1 = &quot;user.save&quot;;
        String routingKey2 = &quot;user.update&quot;;
        String routingKey3 = &quot;user.delete.abc&quot;;
        //5 发送

        String msg = &quot;Hello World RabbitMQ 4 Topic Exchange Message ...&quot;;
        channel.basicPublish(exchangeName, routingKey1 , null , msg.getBytes()); 
        channel.basicPublish(exchangeName, routingKey2 , null , msg.getBytes());     
        channel.basicPublish(exchangeName, routingKey3 , null , msg.getBytes()); 
        channel.close();  
        connection.close();  
    }

}

</code></pre>
<p>曾经使用过的规则不会自动解绑</p>
<p><img src="/2019/05/28/mq/mq11.jpg" alt="mq11"></p>
<h3 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h3><p>不处理任何路由键，只简单把queue和exchange绑定</p>
<p>发送到该交换机的消息都会转发到与该交换机绑定的队列上</p>
<p>性能最好、速度最快</p>
<p><img src="/2019/05/28/mq/mq12.jpg" alt="mq12"></p>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer4FanoutExchange {

    public static void main(String[] args) throws Exception {

        ConnectionFactory connectionFactory = new ConnectionFactory() ;  

        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        connectionFactory.setAutomaticRecoveryEnabled(true);
        connectionFactory.setNetworkRecoveryInterval(3000);
        Connection connection = connectionFactory.newConnection();

        Channel channel = connection.createChannel();  
        //4 声明
        String exchangeName = &quot;test_fanout_exchange&quot;;
        String exchangeType = &quot;fanout&quot;;
        String queueName = &quot;test_fanout_queue&quot;;
        String routingKey = &quot;&quot;;    //不设置路由键
        channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null);
        channel.queueDeclare(queueName, false, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);

        //durable 是否持久化消息
        QueueingConsumer consumer = new QueueingConsumer(channel);
        //参数：队列名称、是否自动ACK、Consumer
        channel.basicConsume(queueName, true, consumer); 
        //循环获取消息  
        while(true){  
            //获取消息，如果没有消息，这一步将会一直阻塞  
            Delivery delivery = consumer.nextDelivery();  
            String msg = new String(delivery.getBody());    
            System.out.println(&quot;收到消息：&quot; + msg);  
        } 
    }
}

</code></pre>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Producer4FanoutExchange {


    public static void main(String[] args) throws Exception {

        //1 创建ConnectionFactory
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        //2 创建Connection
        Connection connection = connectionFactory.newConnection();
        //3 创建Channel
        Channel channel = connection.createChannel();  
        //4 声明
        String exchangeName = &quot;test_fanout_exchange&quot;;
        //5 发送
        for(int i = 0; i &lt; 10; i ++) {
            String msg = &quot;Hello World RabbitMQ 4 FANOUT Exchange Message ...&quot;;
            channel.basicPublish(exchangeName, &quot;&quot;, null , msg.getBytes());         
            //routekeycan be anything, no influence
        }
        channel.close();  
        connection.close();  
    }

}

</code></pre>
<p><img src="/2019/05/28/mq/mq13.jpg" alt="mq13"></p>
<h2 id="Bingding"><a href="#Bingding" class="headerlink" title="Bingding"></a>Bingding</h2><p>Exchange 与 Exchange、Queue之间的连接关系</p>
<p>可以包含routing key等参数</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Durability：是否持久化Durable、Transient</p>
<p>Auto delete：如果yes，最后一个监听移除后，queue自动删除</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>传递的数据</p>
<p>Properties，Payload（Body）两部分组成</p>
<p>常用属性：delivery mode、headers（自定义属性）</p>
<p>priority优先级</p>
<p>content_type, content_encoding</p>
<p>correlation_id:消息唯一id</p>
<p>reply_to\ expiration 存活时间\ message_id</p>
<pre><code class="java">import java.util.Map;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Envelope;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer {

    public static void main(String[] args) throws Exception {

        //1 创建一个ConnectionFactory, 并进行配置
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        //2 通过连接工厂创建连接
        Connection connection = connectionFactory.newConnection();

        //3 通过connection创建一个Channel
        Channel channel = connection.createChannel();

        //4 声明（创建）一个队列
        String queueName = &quot;test001&quot;;
        channel.queueDeclare(queueName, true, false, false, null);

        //5 创建消费者
        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);

        //6 设置Channel
        channel.basicConsume(queueName, true, queueingConsumer);

        while(true){
            //7 获取消息
            Delivery delivery = queueingConsumer.nextDelivery();
            String msg = new String(delivery.getBody());
            System.err.println(&quot;消费端: &quot; + msg);
            Map&lt;String, Object&gt; headers = delivery.getProperties().getHeaders();
            System.err.println(&quot;headers get my1 value: &quot; + headers.get(&quot;my1&quot;));

            //Envelope envelope = delivery.getEnvelope();
        }

    }
}

</code></pre>
<pre><code class="java">import java.util.HashMap;
import java.util.Map;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Procuder {


    public static void main(String[] args) throws Exception {
        //1 创建一个ConnectionFactory, 并进行配置
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        //2 通过连接工厂创建连接
        Connection connection = connectionFactory.newConnection();

        //3 通过connection创建一个Channel
        Channel channel = connection.createChannel();

        Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;();
        headers.put(&quot;my1&quot;, &quot;111&quot;);
        headers.put(&quot;my2&quot;, &quot;222&quot;);


        AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
                .deliveryMode(2)//durable
                .contentEncoding(&quot;UTF-8&quot;)//encoding
                .expiration(&quot;10000&quot;)
                .headers(headers)
                .build();

        //4 通过Channel发送数据
        for(int i=0; i &lt; 5; i++){
            String msg = &quot;Hello RabbitMQ!&quot;;
            //1 exchange   2 routingKey
            channel.basicPublish(&quot;&quot;, &quot;test001&quot;, properties, msg.getBytes());
        }

        //5 记得要关闭相关的连接
        channel.close();
        connection.close();
    }
}

</code></pre>
<h2 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h2><p>虚拟地址，用于逻辑隔离，最上层的消息路由</p>
<p>一个VH里可以有若干个Exchange 和Queue</p>
<p>同一个VH里exchange 和queue名称不能相同</p>
<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="消息的可靠性传递"><a href="#消息的可靠性传递" class="headerlink" title="消息的可靠性传递"></a>消息的可靠性传递</h2><ul>
<li>保障消息成功发出</li>
<li>保障MQ节点成功接收</li>
<li>发送端收到MQ节点确认应答</li>
<li>完善的消息补偿机制</li>
</ul>
<p><strong>解决方案</strong></p>
<p>1、消息入库，对消息打标记</p>
<p><img src="/2019/05/28/mq/mq14.jpg" alt="mq14"></p>
<p>2、消息延迟投递，做二次确认，延迟检查</p>
<p><img src="/2019/05/28/mq/mq15.jpg" alt="mq15"></p>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>对一个操作无论执行多少次，结果相同，避免重复消费</p>
<p>主流幂等操作：</p>
<p>1、唯一ID+指纹码，利用数据库主键去重</p>
<p>先查询，有，返回失败，没有，插入新数据</p>
<p>实现简单，但是数据库压力较大，可以分库分表解决</p>
<p>2、利用Redis原子特性实现</p>
<p>如果落库，需要考虑数据库缓存的原子性</p>
<p>如果不入库，需要考虑定时同步策略</p>
<h2 id="Confirm确认消息"><a href="#Confirm确认消息" class="headerlink" title="Confirm确认消息"></a>Confirm确认消息</h2><p>消息确认：生产者的消息投递之后，若broker收到，会给生产者应答</p>
<p><img src="/2019/05/28/mq/mq16.jpg" alt="mq16"></p>
<p>确认步骤：</p>
<p>1、channel上开启确认模式: channel.confirmSelect()</p>
<p>2、在channel上添加监听，addConfirmListener，监听成功或者失败的返回结果，根据具体结果决定是否重新发送，记录日志等</p>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer {


    public static void main(String[] args) throws Exception {


        //1 创建ConnectionFactory
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        //2 获取C    onnection
        Connection connection = connectionFactory.newConnection();

        //3 通过Connection创建一个新的Channel
        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_confirm_exchange&quot;;
        String routingKey = &quot;confirm.#&quot;;
        String queueName = &quot;test_confirm_queue&quot;;

        //4 声明交换机和队列 然后进行绑定设置, 最后制定路由Key
        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true);
        channel.queueDeclare(queueName, true, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);

        //5 创建消费者 
        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);
        channel.basicConsume(queueName, true, queueingConsumer);

        while(true){
            Delivery delivery = queueingConsumer.nextDelivery();
            String msg = new String(delivery.getBody());

            System.err.println(&quot;消费端: &quot; + msg);
        }


    }
}
</code></pre>
<pre><code class="java">import java.io.IOException;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.ConfirmListener;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Producer {


    public static void main(String[] args) throws Exception {


        //1 创建ConnectionFactory
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        //2 获取C    onnection
        Connection connection = connectionFactory.newConnection();

        //3 通过Connection创建一个新的Channel
        Channel channel = connection.createChannel();


        //4 指定我们的消息投递模式: 消息的确认模式 
        channel.confirmSelect();

        String exchangeName = &quot;test_confirm_exchange&quot;;
        String routingKey = &quot;confirm.save&quot;;

        //5 发送一条消息
        String msg = &quot;Hello RabbitMQ Send confirm message!&quot;;
        channel.basicPublish(exchangeName, routingKey, null, msg.getBytes());

        //6 添加一个确认监听
        channel.addConfirmListener(new ConfirmListener() {
            @Override
            public void handleNack(long deliveryTag, boolean multiple) throws IOException {
                System.err.println(&quot;-------no ack!-----------&quot;);
            }

            @Override
            public void handleAck(long deliveryTag, boolean multiple) throws IOException {
                System.err.println(&quot;-------ack!-----------&quot;);
            }
        });    
    }
}
</code></pre>
<h2 id="Return消息机制"><a href="#Return消息机制" class="headerlink" title="Return消息机制"></a>Return消息机制</h2><p>ReurnListener用于处理一些不可路由的消息</p>
<p>某些情况，消息无法通过exchange或者routingkey，监听这种不可达消息，使用return listener</p>
<p>配置项：</p>
<p>Mandatory，若为true，监听器会接受不可达的消息，做后续处理，若为false，broker会自动删除消息</p>
<p><img src="/2019/05/28/mq/mq17.jpg" alt="mq17"></p>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer {


    public static void main(String[] args) throws Exception {


        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_return_exchange&quot;;
        String routingKey = &quot;return.#&quot;;
        String queueName = &quot;test_return_queue&quot;;

        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);
        channel.queueDeclare(queueName, true, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);

        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);

        channel.basicConsume(queueName, true, queueingConsumer);

        while(true){

            Delivery delivery = queueingConsumer.nextDelivery();
            String msg = new String(delivery.getBody());
            System.err.println(&quot;消费者: &quot; + msg);
        }        
    }
}
</code></pre>
<pre><code class="java">import java.io.IOException;
import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.ReturnListener;
import com.rabbitmq.client.AMQP.BasicProperties;

public class Producer {


    public static void main(String[] args) throws Exception {


        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();

        String exchange = &quot;test_return_exchange&quot;;
        String routingKey = &quot;return.save&quot;;
        String routingKeyError = &quot;abc.save&quot;;

        String msg = &quot;Hello RabbitMQ Return Message&quot;;


        channel.addReturnListener(new ReturnListener() {
            @Override
            public void handleReturn(int replyCode, String replyText, String exchange,
                    String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException {

                System.err.println(&quot;---------handle  return----------&quot;);
                System.err.println(&quot;replyCode: &quot; + replyCode);
                System.err.println(&quot;replyText: &quot; + replyText);
                System.err.println(&quot;exchange: &quot; + exchange);
                System.err.println(&quot;routingKey: &quot; + routingKey);
                System.err.println(&quot;properties: &quot; + properties);
                System.err.println(&quot;body: &quot; + new String(body));
            }
        });


        channel.basicPublish(exchange, routingKeyError, true, null, msg.getBytes());

        //channel.basicPublish(exchange, routingKeyError, true, null, msg.getBytes());    
    }
}
</code></pre>
<h2 id="消费端自动监听"><a href="#消费端自动监听" class="headerlink" title="消费端自动监听"></a>消费端自动监听</h2><p>避免while循环下nextDlivery</p>
<p>继承DefaultConsumer即可，override handleDelivery方法</p>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Producer {


    public static void main(String[] args) throws Exception {

        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();

        String exchange = &quot;test_consumer_exchange&quot;;
        String routingKey = &quot;consumer.save&quot;;

        String msg = &quot;Hello RabbitMQ Consumer Message&quot;;

        for(int i =0; i&lt;5; i ++){
            channel.basicPublish(exchange, routingKey, true, null, msg.getBytes());
        }

    }
}
</code></pre>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer {


    public static void main(String[] args) throws Exception {


        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();


        String exchangeName = &quot;test_consumer_exchange&quot;;
        String routingKey = &quot;consumer.#&quot;;
        String queueName = &quot;test_consumer_queue&quot;;

        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);
        channel.queueDeclare(queueName, true, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);

        channel.basicConsume(queueName, true, new MyConsumer(channel));    
    }
}

</code></pre>
<p>自定义myconsumer</p>
<pre><code class="java">import java.io.IOException;
import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;

public class MyConsumer extends DefaultConsumer {


    public MyConsumer(Channel channel) {
        super(channel);
    }

    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        System.err.println(&quot;-----------consume message----------&quot;);
        System.err.println(&quot;consumerTag: &quot; + consumerTag);
        System.err.println(&quot;envelope: &quot; + envelope);
        System.err.println(&quot;properties: &quot; + properties);
        System.err.println(&quot;body: &quot; + new String(body));
    }
}
</code></pre>
<h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>broker囤积大量消息后，消费端开始接受，大量数据涌来，导致服务器崩溃等问题</p>
<p>消费端速度低于生产端速度时</p>
<p>qos服务质量保证功能，基于consume或者channel设置qos值，在有一定数目消息未被确认之前，不会消费更多的消息，autoACK设置为false</p>
<p><img src="/2019/05/28/mq/mq18.jpg" alt="mq18"></p>
<p><img src="/2019/05/28/mq/mq19.jpg" alt="mq19"></p>
<p>no_ack = false才生效此功能</p>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer {


    public static void main(String[] args) throws Exception {


        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();


        String exchangeName = &quot;test_qos_exchange&quot;;
        String queueName = &quot;test_qos_queue&quot;;
        String routingKey = &quot;qos.#&quot;;

        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);
        channel.queueDeclare(queueName, true, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);

        //1 限流方式  第一件事就是 autoAck设置为 false

        channel.basicQos(0, 1, false);

        channel.basicConsume(queueName, false, new MyConsumer(channel));


    }
}
</code></pre>
<pre><code class="java">import java.io.IOException;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;

public class MyConsumer extends DefaultConsumer {


    private Channel channel ;

    public MyConsumer(Channel channel) {
        super(channel);
        this.channel = channel;
    }

    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        System.err.println(&quot;-----------consume message----------&quot;);
        System.err.println(&quot;consumerTag: &quot; + consumerTag);
        System.err.println(&quot;envelope: &quot; + envelope);
        System.err.println(&quot;properties: &quot; + properties);
        System.err.println(&quot;body: &quot; + new String(body));

        channel.basicAck(envelope.getDeliveryTag(), false);
        //doesn&#39;t support ack by batch
        //if we delete this ack function, the MQ will not send the next message because no ack get

    }
}
</code></pre>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Producer {


    public static void main(String[] args) throws Exception {

        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();

        String exchange = &quot;test_qos_exchange&quot;;
        String routingKey = &quot;qos.save&quot;;

        String msg = &quot;Hello RabbitMQ QOS Message&quot;;

        for(int i =0; i&lt;5; i ++){
            channel.basicPublish(exchange, routingKey, true, null, msg.getBytes());
        }
    }
}
</code></pre>
<h2 id="消费端ACK和重回队列"><a href="#消费端ACK和重回队列" class="headerlink" title="消费端ACK和重回队列"></a>消费端ACK和重回队列</h2><p>消费端可手工ack or nack</p>
<p>重回队列：消费端没有处理成功的消息，重新发送给broker，一般关闭</p>
<pre><code class="java">import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer {


    public static void main(String[] args) throws Exception {


        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();


        String exchangeName = &quot;test_ack_exchange&quot;;
        String queueName = &quot;test_ack_queue&quot;;
        String routingKey = &quot;ack.#&quot;;

        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);
        channel.queueDeclare(queueName, true, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);

        // 手工签收 必须要关闭 autoAck = false
        channel.basicConsume(queueName, false, new MyConsumer(channel));

    }
}
</code></pre>
<pre><code class="java">import java.io.IOException;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;

public class MyConsumer extends DefaultConsumer {


    private Channel channel ;

    public MyConsumer(Channel channel) {
        super(channel);
        this.channel = channel;
    }

    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        System.err.println(&quot;-----------consume message----------&quot;);
        System.err.println(&quot;body: &quot; + new String(body));
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if((Integer)properties.getHeaders().get(&quot;num&quot;) == 0) {
            channel.basicNack(envelope.getDeliveryTag(), false, true);
        } else {
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
    }
}
</code></pre>
<pre><code class="java">import java.util.HashMap;
import java.util.Map;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Producer {


    public static void main(String[] args) throws Exception {

        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();

        String exchange = &quot;test_ack_exchange&quot;;
        String routingKey = &quot;ack.save&quot;;



        for(int i =0; i&lt;5; i ++){

            Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();
            headers.put(&quot;num&quot;, i);

            AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
                    .deliveryMode(2)
                    .contentEncoding(&quot;UTF-8&quot;)
                    .headers(headers)
                    .build();
            String msg = &quot;Hello RabbitMQ ACK Message &quot; + i;
            channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes());
        }
    }
}
</code></pre>
<p><img src="/2019/05/28/mq/mq20.jpg" alt="mq20"></p>
<h2 id="TTL队列-消息"><a href="#TTL队列-消息" class="headerlink" title="TTL队列/消息"></a>TTL队列/消息</h2><p>time to live 生存时间</p>
<p>入队开始计算，超时消息自动清除</p>
<p>可以设置队列挥着消息本身的TTL</p>
<pre><code class="java">AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
                .deliveryMode(2)//durable
                .contentEncoding(&quot;UTF-8&quot;)//encoding
                .expiration(&quot;10000&quot;)
                .headers(headers)
                .build();
</code></pre>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>DLX:dead-letter-exchange</p>
<p>当消息在队列中变成死信以后，重新publish到另外一个exchange，这个exchange就是DLX</p>
<p>死信情况：</p>
<p>1、消息被拒绝（basic.reject/basic.nack），requeue为false</p>
<p>2、TTL过期</p>
<p>3、队列达到最大长度</p>
<p>使用方法：</p>
<p>1、首先需要设置死信交换机和队列</p>
<p>2、正常声明交换机、队列、绑定，需要额外参数arguments.put(“x-dead-letter-exchange”,”dlx.exchange”);</p>
<p>注意，arguments设置在普通队列上来指定去往哪个死信队列</p>
<p>3、满足条件的消息直接被路由到DLX</p>
<pre><code class="java">import java.util.HashMap;
import java.util.Map;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import com.rabbitmq.client.QueueingConsumer.Delivery;

public class Consumer {


    public static void main(String[] args) throws Exception {


        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();

        // 这就是一个普通的交换机 和 队列 以及路由
        String exchangeName = &quot;test_dlx_exchange&quot;;
        String routingKey = &quot;dlx.#&quot;;
        String queueName = &quot;test_dlx_queue&quot;;

        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);

        Map&lt;String, Object&gt; agruments = new HashMap&lt;String, Object&gt;();
        agruments.put(&quot;x-dead-letter-exchange&quot;, &quot;dlx.exchange&quot;);
        //这个agruments属性，要设置到声明队列上
        channel.queueDeclare(queueName, true, false, false, agruments);
        channel.queueBind(queueName, exchangeName, routingKey);

        //要进行死信队列的声明:
        channel.exchangeDeclare(&quot;dlx.exchange&quot;, &quot;topic&quot;, true, false, null);
        channel.queueDeclare(&quot;dlx.queue&quot;, true, false, false, null);
        channel.queueBind(&quot;dlx.queue&quot;, &quot;dlx.exchange&quot;, &quot;#&quot;);

        channel.basicConsume(queueName, true, new MyConsumer(channel));
    }
}
</code></pre>
<pre><code class="java">import java.io.IOException;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;

public class MyConsumer extends DefaultConsumer {


    public MyConsumer(Channel channel) {
        super(channel);
    }

    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        System.err.println(&quot;-----------consume message----------&quot;);
        System.err.println(&quot;consumerTag: &quot; + consumerTag);
        System.err.println(&quot;envelope: &quot; + envelope);
        System.err.println(&quot;properties: &quot; + properties);
        System.err.println(&quot;body: &quot; + new String(body));
    }
}
</code></pre>
<pre><code class="java">import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class Producer {


    public static void main(String[] args) throws Exception {

        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost(&quot;192.168.11.76&quot;);
        connectionFactory.setPort(5672);
        connectionFactory.setVirtualHost(&quot;/&quot;);

        Connection connection = connectionFactory.newConnection();
        Channel channel = connection.createChannel();

        String exchange = &quot;test_dlx_exchange&quot;;
        String routingKey = &quot;dlx.save&quot;;

        String msg = &quot;Hello RabbitMQ DLX Message&quot;;

        for(int i =0; i&lt;1; i ++){

            AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
                    .deliveryMode(2)
                    .contentEncoding(&quot;UTF-8&quot;)
                    .expiration(&quot;10000&quot;)
                    .build();
            channel.basicPublish(exchange, routingKey, true, properties, msg.getBytes());
        }
    }
}
</code></pre>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Seven Principles of Software Design</title>
    <url>/2019/04/10/principles/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/rexllz/design" target="_blank" rel="noopener">https://github.com/rexllz/design</a></p>
</blockquote>
<h1 id="开闭原则（Open-Closed-）"><a href="#开闭原则（Open-Closed-）" class="headerlink" title="开闭原则（Open/Closed ）"></a>开闭原则（Open/Closed ）</h1><p><strong>对扩展开放、对修改关闭</strong></p>
<ul>
<li><p>提高软件的可复用和可维护性</p>
</li>
<li><p>面向抽象编程</p>
</li>
<li><p>面向接口编程</p>
</li>
</ul>
<pre><code class="java">public interface ICourse {
    Integer getId();
    String getName();
    Double getPrice();
}
</code></pre>
<pre><code class="java">public class JavaCourse implements ICourse{
    private Integer Id;
    private String name;
    private Double price;

    public JavaCourse(Integer id, String name, Double price) {
        this.Id = id;
        this.name = name;
        this.price = price;
    }

    public Integer getId() {
        return this.Id;
    }

    public String getName() {
        return this.name;
    }

    public Double getPrice() {
        return this.price;
    }
}

</code></pre>
<pre><code class="java">public class JavaDiscountCourse extends JavaCourse{

    public JavaDiscountCourse(Integer id, String name, Double price) {
        super(id, name, price);
    }

    public Double getDiscountPrice(){
        return super.getPrice()*0.8;
    }

    public Double getOriginPrice(){
        return super.getPrice();
    }
}
</code></pre>
<p><img src="/2019/04/10/principles/oc.jpg" alt="oc"></p>
<h1 id="依赖倒置原则（Dependency-Inversion）"><a href="#依赖倒置原则（Dependency-Inversion）" class="headerlink" title="依赖倒置原则（Dependency Inversion）"></a>依赖倒置原则（Dependency Inversion）</h1><p><strong>高层模块不应该依赖底层模块，二者都应该依赖抽象</strong></p>
<ul>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>针对接口编程，不可针对实现编程</li>
</ul>
<h2 id="高层依赖底层的情况"><a href="#高层依赖底层的情况" class="headerlink" title="高层依赖底层的情况"></a>高层依赖底层的情况</h2><pre><code class="java">public class Rex {
    public void studyJava(){
        System.out.println(&quot;study java&quot;);
    }
    public void studyPython(){
        System.out.println(&quot;study python&quot;);
    }
    public void studyJs(){
        System.out.println(&quot;study js&quot;);
    }
}
</code></pre>
<pre><code class="java">//v1 面向实现编程
//高层依赖底层
//test 依赖 rex
public static void main(String[] args) {
        Rex rex = new Rex();
        rex.studyJava();
        rex.studyJs();
        rex.studyPython();
    }
</code></pre>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><pre><code class="java">public class Rex {
    public void studyCourse(ICourse iCourse){
        iCourse.studyCourse();
    }
}
</code></pre>
<pre><code class="java">//依赖倒置
    public static void main(String[] args) {
        Rex rex = new Rex();
        rex.studyCourse(new JavaCourse());
        rex.studyCourse(new JsCourse());
        rex.studyCourse(new PythonCourse());
    }
</code></pre>
<p><img src="/2019/04/10/principles/di.jpg" alt="di"></p>
<h2 id="构造器注入-单例"><a href="#构造器注入-单例" class="headerlink" title="构造器注入(单例)"></a>构造器注入(单例)</h2><pre><code class="java">public class Rex {
    private ICourse iCourse;
    public Rex(ICourse iCourse) {
        this.iCourse = iCourse;
    }
    public void studyImoocCourse(){
        iCourse.studyCourse();
    }
}
</code></pre>
<pre><code class="java">//v3 构造器注入
public static void main(String[] args) {
        Rex rex = new Rex(new JavaCourse());
        rex.studyImoocCourse();
}
</code></pre>
<h2 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h2><pre><code class="java">public class Rex {
    private ICourse iCourse;
    public void setiCourse(ICourse iCourse){
        this.iCourse = iCourse;
    }
    public void studyImoocCourse(){
        iCourse.studyCourse();
    }
}
</code></pre>
<pre><code class="java">//v4 setter injection
public static void main(String[] args) {
        Rex rex = new Rex();
        rex.setiCourse(new JavaCourse());
        rex.studyImoocCourse();

        rex.setiCourse(new PythonCourse());
        rex.studyImoocCourse();

        rex.setiCourse(new JsCourse());
        rex.studyImoocCourse();
}
</code></pre>
<h1 id="单一职责原则（Single-Responsibility-）"><a href="#单一职责原则（Single-Responsibility-）" class="headerlink" title="单一职责原则（Single Responsibility ）"></a>单一职责原则（Single Responsibility ）</h1><ul>
<li>不存在多于一个导致类变更的原因</li>
<li>一个类、接口、方法只负责一个职责</li>
<li>降低复杂度，提高可读性、可维护性、降低风险</li>
</ul>
<h2 id="类的单一原则"><a href="#类的单一原则" class="headerlink" title="类的单一原则"></a>类的单一原则</h2><p><strong>不遵循单一职责原则的例子</strong></p>
<pre><code class="java">public class Bird {
    public void mainMoveMode(String birdName){
        if(&quot;鸵鸟&quot;.equals(birdName)){
            System.out.println(birdName+&quot;用脚走&quot;);
        }else{
            System.out.println(birdName+&quot;用翅膀飞&quot;);
        }
    }
}
</code></pre>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        Bird bird = new Bird();
        bird.mainMoveMode(&quot;鸵鸟&quot;);
        bird.mainMoveMode(&quot;大雁&quot;);
    }
}
</code></pre>
<p><strong>类的单一原则修改</strong></p>
<pre><code class="java">public class FlyBird {
    public void mainMoveMode(String birdName){
        System.out.println(birdName+&quot;用翅膀飞&quot;);
    }
}
</code></pre>
<pre><code class="java">public class WalkBird {
    public void mainMoveMode(String birdName){
        System.out.println(birdName+&quot;用脚走&quot;);
    }
}
</code></pre>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        WalkBird walkBird = new WalkBird();
        walkBird.mainMoveMode(&quot;鸵鸟&quot;);
        FlyBird flyBird = new FlyBird();
        flyBird.mainMoveMode(&quot;大雁&quot;);
    }
}
</code></pre>
<p><img src="/2019/04/10/principles/sr.jpg" alt="sr"></p>
<h2 id="接口的单一原则"><a href="#接口的单一原则" class="headerlink" title="接口的单一原则"></a>接口的单一原则</h2><p><img src="/2019/04/10/principles/isr.jpg" alt="isr"></p>
<h2 id="方法的单一原则"><a href="#方法的单一原则" class="headerlink" title="方法的单一原则"></a>方法的单一原则</h2><p>每个方法对单一属性进行修改或者实现单一功能</p>
<h1 id="接口隔离原则（Interface-Segregation）"><a href="#接口隔离原则（Interface-Segregation）" class="headerlink" title="接口隔离原则（Interface Segregation）"></a>接口隔离原则（Interface Segregation）</h1><ul>
<li>采用多个接口，而不依赖于单一总接口</li>
<li>一个类与一个类的依赖应该建立在最小的接口上</li>
<li>接口尽量小、尽量细化</li>
</ul>
<pre><code class="java">public interface IAnimalAction {
    void eat();

    void fly();

    void swim();
}
</code></pre>
<pre><code class="java">public interface IFlyAnimalAction {
    void fly();
}
</code></pre>
<pre><code class="java">public interface ISwimAnimalAction {
    void swim();
}
</code></pre>
<pre><code class="java">public interface IEatAnimalAction {
    void eat();
}
</code></pre>
<p><strong>需要适度</strong></p>
<p><img src="/2019/04/10/principles/is.jpg" alt="is"></p>
<p>比起单一职责，更倾向于架构，接口，而不是功能</p>
<h1 id="迪米特原则（最少知道）"><a href="#迪米特原则（最少知道）" class="headerlink" title="迪米特原则（最少知道）"></a>迪米特原则（最少知道）</h1><ul>
<li>一个对象应该对其他对象保持最少的了解</li>
<li>降低类与类的耦合</li>
<li>只和朋友类保持关系（内部使用的类不是朋友类）</li>
</ul>
<p><img src="/2019/04/10/principles/demeter.jpg" alt="demeter"></p>
<h1 id="里氏替换原则（Liskov-Substitution，LSP）"><a href="#里氏替换原则（Liskov-Substitution，LSP）" class="headerlink" title="里氏替换原则（Liskov Substitution，LSP）"></a>里氏替换原则（Liskov Substitution，LSP）</h1><ul>
<li>如果软件可以适用父类，那一定能适用子类</li>
<li>子类可以拓展父类的功能，但不能改变已有的功能</li>
<li>子类可以实现父类的抽象方法，但不能修改非抽象方法</li>
<li>子类可以增加方法</li>
<li>重载方法时，入参应当更宽松</li>
<li><p>子类重载或重写方法时，输出要更严格</p>
</li>
<li><p><strong>有效约束继承泛滥，体现开闭原则</strong></p>
</li>
<li><strong>增加健壮性、拓展性</strong></li>
</ul>
<p>不符合里氏替换的例子</p>
<pre><code class="java">public class Rectangle {
    private long length;
    private long width;

    @Override
    public long getWidth() {
        return width;
    }

    @Override
    public long getLength() {
        return length;
    }

    public void setLength(long length) {
        this.length = length;
    }

    public void setWidth(long width) {
        this.width = width;
    }
}
</code></pre>
<pre><code class="java">public class Square extends Rectangle {
    private long sideLength;

    public long getSideLength() {
        return sideLength;
    }

    public void setSideLength(long sideLength) {
        this.sideLength = sideLength;
    }

    @Override
    public long getWidth() {
        return sideLength;
    }

    @Override
    public long getLength() {
        return sideLength;
    }
}
</code></pre>
<pre><code class="java">public static void resize(Rectangle rectangle){
        while (rectangle.getWidth() &lt;= rectangle.getLength()){
            rectangle.setWidth(rectangle.getWidth()+1);
            System.out.println(&quot;width:&quot;+rectangle.getWidth() + &quot; length:&quot;+rectangle.getLength());
        }
        System.out.println(&quot;resize方法结束 width:&quot;+rectangle.getWidth() + 
                           &quot; length:&quot;+rectangle.getLength());
    }
</code></pre>
<p>新建上层接口</p>
<p><img src="/2019/04/10/principles/lsp.jpg" alt="lsp"></p>
<p>从而避免了resize中传入square，因为square不再是rectangle子类</p>
<h1 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h1><ul>
<li>has-A &amp; contains-A 代替 is-A</li>
<li>降低耦合</li>
</ul>
<pre><code class="java">public abstract class DBConnection {
    //    public String getConnection(){
//        return &quot;MySQL数据库连接&quot;;
//    }
    public abstract String getConnection();
}
</code></pre>
<pre><code class="java">public class MySQLConnection extends DBConnection {
    @Override
    public String getConnection() {
        return &quot;MySQL数据库连接&quot;;
    }
}
</code></pre>
<pre><code class="java">public class PostgreSQLConnection extends DBConnection {
    @Override
    public String getConnection() {
        return &quot;PostgreSQL数据库连接&quot;;
    }
}
</code></pre>
<pre><code class="java">public class ProductDao{
    private DBConnection dbConnection;

    public void setDbConnection(DBConnection dbConnection) {
        this.dbConnection = dbConnection;
    }

    public void addProduct(){
        String conn = dbConnection.getConnection();
        System.out.println(&quot;使用&quot;+conn+&quot;增加产品&quot;);
    }
}
</code></pre>
<pre><code class="java">public class Test {
    public static void main(String[] args) {
        ProductDao productDao = new ProductDao();
        productDao.setDbConnection(new PostgreSQLConnection());
        productDao.addProduct();
    }
}
</code></pre>
<p><img src="/2019/04/10/principles/ca.jpg" alt="ca"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ Cluster</title>
    <url>/2019/06/08/rabbitcluster/</url>
    <content><![CDATA[<p>正所谓万物皆可集群。。</p>
<h1 id="RabbitMQ集群架构模式"><a href="#RabbitMQ集群架构模式" class="headerlink" title="RabbitMQ集群架构模式"></a>RabbitMQ集群架构模式</h1><h2 id="主备模式-Warren"><a href="#主备模式-Warren" class="headerlink" title="主备模式(Warren)"></a>主备模式(Warren)</h2><p>适合并发或数据量不高的情况下，简单易用</p>
<p>主节点挂掉，从节点替补（可能多个从节点）</p>
<p><img src="/2019/06/08/rabbitcluster/c1.jpg" alt="c1"></p>
<p><img src="/2019/06/08/rabbitcluster/c2.jpg" alt="c2"></p>
<p>每五秒做一次检查，两次正常可用，两次失败不可用</p>
<h2 id="远程模式-Shovel"><a href="#远程模式-Shovel" class="headerlink" title="远程模式(Shovel)"></a>远程模式(Shovel)</h2><p>双活模式，将消息移动到不同数据中心，分摊压力</p>
<p>可以跨地域使两个MQ互联</p>
<p>近端同步确认，远端异步确认</p>
<p><img src="/2019/06/08/rabbitcluster/c3.jpg" alt="c3"></p>
<h2 id="镜像模式-Mirror"><a href="#镜像模式-Mirror" class="headerlink" title="镜像模式(Mirror)"></a>镜像模式(Mirror)</h2><p>使用镜像队列，使用2-3个节点实现数据同步</p>
<p><img src="/2019/06/08/rabbitcluster/c4.jpg" alt="c4"></p>
<h2 id="多活模式"><a href="#多活模式" class="headerlink" title="多活模式"></a>多活模式</h2><p>在两个或多个MQ集群中实现数据同步</p>
<p><img src="/2019/06/08/rabbitcluster/c5.jpg" alt="c5"></p>
<p><img src="/2019/06/08/rabbitcluster/c6.jpg" alt="c6"></p>
<p>federation exchange：</p>
<p><img src="/2019/06/08/rabbitcluster/c7.jpg" alt="c7"></p>
<p><img src="/2019/06/08/rabbitcluster/c8.jpg" alt="c8"></p>
<h1 id="镜像模型的构建"><a href="#镜像模型的构建" class="headerlink" title="镜像模型的构建"></a>镜像模型的构建</h1><p>实验说明</p>
<p><img src="/2019/06/08/rabbitcluster/c9.jpg" alt="c9"></p>
<h2 id="节点安装"><a href="#节点安装" class="headerlink" title="节点安装"></a>节点安装</h2><ul>
<li>安装依赖</li>
</ul>
<pre><code>yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz
</code></pre><ul>
<li>下载安装包</li>
</ul>
<pre><code>wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm
wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm
wget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm
</code></pre><ul>
<li>安装服务命令</li>
</ul>
<pre><code>rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm 
rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm
rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm
</code></pre><ul>
<li>修改集群用户与连接心跳检测</li>
</ul>
<pre><code>注意修改vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app文件
修改：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,只保留guest
修改：heartbeat 为1
</code></pre><ul>
<li>安装管理插件</li>
</ul>
<pre><code>//首先启动服务
/etc/init.d/rabbitmq-server start stop status restart
//查看服务有没有启动： lsof -i:5672
rabbitmq-plugins enable rabbitmq_management
//可查看管理端口有没有启动： lsof -i:15672 或者 netstat -tnlp|grep 15672
</code></pre><ul>
<li>服务指令</li>
</ul>
<pre><code>/etc/init.d/rabbitmq-server start stop status restart
验证单个节点是否安装成功：http://192.168.11.71:15672/
1．  Ps：以上操作三个节点（71、72、73）同时进行操作
</code></pre><h2 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h2><p>选择76、77、78任意一个节点为Master（这里选择76为Master），也就是说我们需要把76的Cookie文件同步到77、78节点上去，进入/var/lib/rabbitmq目录下，把/var/lib/rabbitmq/.erlang.cookie文件的权限修改为777，原来是400；然后把.erlang.cookie文件copy到各个节点下；最后把所有cookie文件权限还原为400即可。</p>
<pre><code>/etc/init.d/rabbitmq-server stop 
//进入目录修改权限；远程copy77、78节点，比如：
scp /var/lib/rabbitmq/.erlang.cookie 到192.168.11.77和192.168.11.78中
</code></pre><h2 id="组成集群"><a href="#组成集群" class="headerlink" title="组成集群"></a>组成集群</h2><ul>
<li>停止MQ服务</li>
</ul>
<pre><code>rabbitmqctl stop
</code></pre><ul>
<li><p>组成集群</p>
<p>接下来我们就可以使用集群命令，配置76、77、78为集群模式，3个节点（76、77、78）执行启动命令，后续启动集群使用此命令即可。</p>
</li>
</ul>
<pre><code>rabbitmq-server -detached
</code></pre><ul>
<li>slave加入集群</li>
</ul>
<pre><code class="bash">//注意做这个步骤的时候：需要配置/etc/hosts 必须相互能够寻址到
bhz77：rabbitmqctl stop_app
bhz77：rabbitmqctl join_cluster --ram rabbit@bhz76
bhz77：rabbitmqctl start_app
bhz78：rabbitmqctl stop_app
bhz78：rabbitmqctl join_cluster rabbit@bhz76
bhz78：rabbitmqctl start_app
//在另外其他节点上操作要移除的集群节点
rabbitmqctl forget_cluster_node rabbit@bhz24
</code></pre>
<ul>
<li>修改集群名称</li>
</ul>
<pre><code class="bash">rabbitmqctl set_cluster_name rabbitmq_cluster1
</code></pre>
<ul>
<li>查看集群状态</li>
</ul>
<pre><code class="bash">rabbitmqctl cluster_status
</code></pre>
<ul>
<li><p>管控台界面</p>
<p>访问任意一个管控台节点：<a href="http://192.168.11.71:15672" target="_blank" rel="noopener">http://192.168.11.71:15672</a> </p>
</li>
</ul>
<p><img src="/2019/06/08/rabbitcluster/c10.jpg" alt="c10"></p>
<ul>
<li><p>配置镜像队列</p>
<p>将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态一致，RabbitMQ高可用集群就已经搭建好了,我们可以重启服务，查看其队列是否在从节点同步</p>
</li>
</ul>
<pre><code class="bash">rabbitmqctl set_policy ha-all &quot;^&quot; &#39;{&quot;ha-mode&quot;:&quot;all&quot;}&#39;
</code></pre>
<h2 id="Ha-Proxy"><a href="#Ha-Proxy" class="headerlink" title="Ha-Proxy"></a>Ha-Proxy</h2><p>HAProxy是一款提供高可用性、负载均衡以及基于TCP和HTTP应用的代理软件，HAProxy是完全免费的、借助HAProxy可以快速并且可靠的提供基于TCP和HTTP应用的代理解决方案。</p>
<p>HAProxy适用于那些负载较大的web站点，这些站点通常又需要会话保持或七层处理。 </p>
<p>HAProxy可以支持数以万计的并发连接,并且HAProxy的运行模式使得它可以很简单安全的整合进架构中，同时可以保护web服务器不被暴露到网络上</p>
<ul>
<li>Haproxy安装</li>
</ul>
<pre><code class="bash">//下载依赖包
yum install gcc vim wget
//下载haproxy
wget http://www.haproxy.org/download/1.6/src/haproxy-1.6.5.tar.gz
//解压
tar -zxvf haproxy-1.6.5.tar.gz -C /usr/local
//进入目录、进行编译、安装
cd /usr/local/haproxy-1.6.5
make TARGET=linux31 PREFIX=/usr/local/haproxy
make install PREFIX=/usr/local/haproxy
mkdir /etc/haproxy
//赋权
groupadd -r -g 149 haproxy
useradd -g haproxy -r -s /sbin/nologin -u 149 haproxy
//创建haproxy配置文件
touch /etc/haproxy/haproxy.cfg
</code></pre>
<ul>
<li>Haproxy配置</li>
</ul>
<pre><code>vim /etc/haproxy/haproxy.cfg

#logging options
global
    log 127.0.0.1 local0 info
    maxconn 5120
    chroot /usr/local/haproxy
    uid 99
    gid 99
    daemon
    quiet
    nbproc 20
    pidfile /var/run/haproxy.pid

defaults
    log global
    #使用4层代理模式，”mode http”为7层代理模式
    mode tcp
    #if you set mode to tcp,then you nust change tcplog into httplog
    option tcplog
    option dontlognull
    retries 3
    option redispatch
    maxconn 2000
    contimeout 5s
     ##客户端空闲超时时间为 60秒 则HA 发起重连机制
     clitimeout 60s
     ##服务器端链接超时时间为 15秒 则HA 发起重连机制
     srvtimeout 15s    
#front-end IP for consumers and producters

listen rabbitmq_cluster
    bind 0.0.0.0:5672
    #配置TCP模式
    mode tcp
    #balance url_param userid
    #balance url_param session_id check_post 64
    #balance hdr(User-Agent)
    #balance hdr(host)
    #balance hdr(Host) use_domain_only
    #balance rdp-cookie
    #balance leastconn
    #balance source //ip
    #简单的轮询
    balance roundrobin
    #rabbitmq集群节点配置 #inter 每隔五秒对mq集群做健康检查， 2次正确证明服务器可用，2次失败证明服务器不可用，并且配置主备机制
        server bhz76 192.168.11.76:5672 check inter 5000 rise 2 fall 2
        server bhz77 192.168.11.77:5672 check inter 5000 rise 2 fall 2
        server bhz78 192.168.11.78:5672 check inter 5000 rise 2 fall 2
#配置haproxy web监控，查看统计信息
listen stats
    bind 192.168.11.79:8100
    mode http
    option httplog
    stats enable
    #设置haproxy监控地址为http://localhost:8100/rabbitmq-stats
    stats uri /rabbitmq-stats
    stats refresh 5s

</code></pre><ul>
<li>启动haproxy</li>
</ul>
<pre><code>/usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg
//查看haproxy进程状态
ps -ef | grep haproxy
</code></pre><ul>
<li><p>访问haproxy</p>
<p>访问如下地址可以对rmq节点进行监控：<a href="http://192.168.1.27:8100/rabbitmq-stats" target="_blank" rel="noopener">http://192.168.1.27:8100/rabbitmq-stats</a></p>
</li>
</ul>
<p><img src="/2019/06/08/rabbitcluster/c11.jpg" alt="c11"></p>
<ul>
<li>关闭haproxy</li>
</ul>
<pre><code>killall haproxy
ps -ef | grep haproxy
</code></pre><h2 id="KeepAlived"><a href="#KeepAlived" class="headerlink" title="KeepAlived"></a>KeepAlived</h2><p>Keepalived，它是一个高性能的服务器高可用或热备解决方案，Keepalived主要来防止服务器单点故障的发生问题，可以通过其与Nginx、Haproxy等反向代理的负载均衡服务器配合实现web服务端的高可用。Keepalived以VRRP协议为实现基础，用VRRP协议来实现高可用性（HA）.VRRP（Virtual Router Redundancy Protocol）协议是用于实现路由器冗余的协议，VRRP协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器IP（一个或多个）。</p>
<ul>
<li><p>Keepalived安装</p>
<p><a href="http://www.keepalived.org/download.html" target="_blank" rel="noopener">http://www.keepalived.org/download.html</a></p>
</li>
</ul>
<pre><code>//安装所需软件包
yum install -y openssl openssl-devel
//下载
wget http://www.keepalived.org/software/keepalived-1.2.18.tar.gz
//解压、编译、安装
tar -zxvf keepalived-1.2.18.tar.gz -C /usr/local/
cd keepalived-1.2.18/ &amp;&amp; ./configure --prefix=/usr/local/keepalived
make &amp;&amp; make install
//将keepalived安装成Linux系统服务，因为没有使用keepalived的默认安装路径（默认路径：/usr/local）,安装完成之后，需要做一些修改工作
//首先创建文件夹，将keepalived配置文件进行复制：
mkdir /etc/keepalived
cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/
//然后复制keepalived脚本文件：
cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/
cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
ln -s /usr/local/sbin/keepalived /usr/sbin/
ln -s /usr/local/keepalived/sbin/keepalived /sbin/
//可以设置开机启动：chkconfig keepalived on，到此我们安装完毕!
chkconfig keepalived on
</code></pre><ul>
<li>Keepalived配置</li>
</ul>
<pre><code>vim /etc/keepalived/keepalived.conf


! Configuration File for keepalived

global_defs {
   router_id bhz79  ##标识节点的字符串，通常为hostname

}

vrrp_script chk_haproxy {
    script &quot;/etc/keepalived/haproxy_check.sh&quot;  ##执行脚本位置
    interval 2  ##检测时间间隔
    weight -20  ##如果条件成立则权重减20
}

vrrp_instance VI_1 {
    state MASTER  ## 主节点为MASTER，备份节点为BACKUP
    interface eth0 ## 绑定虚拟IP的网络接口（网卡），与本机IP地址所在的网络接口相同（我这里是eth0）
    virtual_router_id 79  ## 虚拟路由ID号（主备节点一定要相同）
    mcast_src_ip 192.168.11.79 ## 本机ip地址
    priority 100  ##优先级配置（0-254的值）
    nopreempt
    advert_int 1  ## 组播信息发送间隔，俩个节点必须配置一致，默认1s
authentication {  ## 认证匹配
        auth_type PASS
        auth_pass bhz
    }

    track_script {
        chk_haproxy
    }

    virtual_ipaddress {
        192.168.11.70  ## 虚拟ip，可以指定多个
    }
}




another

! Configuration File for keepalived

global_defs {
   router_id bhz80  ##标识节点的字符串，通常为hostname

}

vrrp_script chk_haproxy {
    script &quot;/etc/keepalived/haproxy_check.sh&quot;  ##执行脚本位置
    interval 2  ##检测时间间隔
    weight -20  ##如果条件成立则权重减20
}

vrrp_instance VI_1 {
    state BACKUP  ## 主节点为MASTER，备份节点为BACKUP
    interface eno16777736 ## 绑定虚拟IP的网络接口（网卡），与本机IP地址所在的网络接口相同（我这里是eno16777736）
    virtual_router_id 79  ## 虚拟路由ID号（主备节点一定要相同）
    mcast_src_ip 192.168.11.80  ## 本机ip地址
    priority 90  ##优先级配置（0-254的值）
    nopreempt
    advert_int 1  ## 组播信息发送间隔，俩个节点必须配置一致，默认1s
authentication {  ## 认证匹配
        auth_type PASS
        auth_pass bhz
    }

    track_script {
        chk_haproxy
    }

    virtual_ipaddress {
        192.168.1.70  ## 虚拟ip，可以指定多个
    }
}

</code></pre><ul>
<li><p>执行脚本编写</p>
<p>添加文件位置为/etc/keepalived/haproxy_check.sh（79、80两个节点文件内容一致即可）</p>
</li>
</ul>
<pre><code>#!/bin/bash
COUNT=`ps -C haproxy --no-header |wc -l`
if [ $COUNT -eq 0 ];then
    /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg
    sleep 2
    if [ `ps -C haproxy --no-header |wc -l` -eq 0 ];then
        killall keepalived
    fi
fi

</code></pre><ul>
<li>执行脚本</li>
</ul>
<pre><code>chmod +x /etc/keepalived/haproxy_check.sh
//启动两台机器的keepalived
service keepalived start | stop | status | restart
//查看状态
ps -ef | grep haproxy
ps -ef | grep keepalived
</code></pre><ul>
<li>高可用测试</li>
</ul>
<p>vip在27节点上</p>
<p><img src="/2019/06/08/rabbitcluster/c12.jpg" alt="c12"></p>
<p>27节点宕机测试：停掉27的keepalived服务即可。</p>
<p><img src="/2019/06/08/rabbitcluster/c13.jpg" alt="c13"></p>
<p>查看28节点状态：我们发现VIP漂移到了28节点上，那么28节点的haproxy可以继续对外提供服务！</p>
<p><img src="/2019/06/08/rabbitcluster/c14.jpg" alt="c14"></p>
<h2 id="集群配置文件"><a href="#集群配置文件" class="headerlink" title="集群配置文件"></a>集群配置文件</h2><p>创建如下配置文件位于：/etc/rabbitmq目录下（这个目录需要自己创建）</p>
<p>环境变量配置文件：rabbitmq-env.conf </p>
<p>配置信息配置文件：rabbitmq.config（可以不创建和配置，修改）</p>
<p>rabbitmq-env.conf配置文件：</p>
<p>关键参数配置:</p>
<p>RABBITMQ_NODE_IP_ADDRESS=本机IP地址</p>
<p>RABBITMQ_NODE_PORT=5672</p>
<p>RABBITMQ_LOG_BASE=/var/lib/rabbitmq/log</p>
<p>RABBITMQ_MNESIA_BASE=/var/lib/rabbitmq/mnesia</p>
<p>配置参考参数如下：</p>
<p>RABBITMQ_NODENAME=FZTEC-240088 节点名称</p>
<p>RABBITMQ_NODE_IP_ADDRESS=127.0.0.1 监听IP</p>
<p>RABBITMQ_NODE_PORT=5672 监听端口</p>
<p>RABBITMQ_LOG_BASE=/data/rabbitmq/log 日志目录</p>
<p>RABBITMQ_PLUGINS_DIR=/data/rabbitmq/plugins 插件目录</p>
<p>RABBITMQ_MNESIA_BASE=/data/rabbitmq/mnesia 后端存储目录</p>
<p>更详细的配置参见： <a href="http://www.rabbitmq.com/configure.html#configuration-file" target="_blank" rel="noopener">http://www.rabbitmq.com/configure.html#configuration-file</a></p>
<p>配置文件信息修改：</p>
<p>/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.4/ebin/rabbit.app和rabbitmq.config配置文件配置任意一个即可，我们进行配置如下：</p>
<p>vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.4/ebin/rabbit.app</p>
<p>关键参数配置</p>
<p>tcp_listerners 设置rabbimq的监听端口，默认为[5672]。<br>disk_free_limit 磁盘低水位线，若磁盘容量低于指定值则停止接收数据，默认值为{mem_relative, 1.0},即与内存相关联1：1，也可定制为多少byte.<br>vm_memory_high_watermark，设置内存低水位线，若低于该水位线，则开启流控机制，默认值是0.4，即内存总量的40%。<br>hipe_compile 将部分rabbimq代码用High Performance Erlang compiler编译，可提升性能，该参数是实验性，若出现erlang vm segfaults，应关掉。<br>force_fine_statistics， 该参数属于rabbimq_management，若为true则进行精细化的统计，但会影响性能</p>
<p>更详细的配置参见：<a href="http://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">http://www.rabbitmq.com/configure.html</a></p>
<h1 id="恢复与故障转移"><a href="#恢复与故障转移" class="headerlink" title="恢复与故障转移"></a>恢复与故障转移</h1><p>镜像队列为例</p>
<p><img src="/2019/06/08/rabbitcluster/c15.jpg" alt="c15"></p>
<p><img src="/2019/06/08/rabbitcluster/c16.jpg" alt="c16"></p>
<p><img src="/2019/06/08/rabbitcluster/c17.jpg" alt="c17"></p>
<p><img src="/2019/06/08/rabbitcluster/c18.jpg" alt="c18"></p>
<p><img src="/2019/06/08/rabbitcluster/c19.jpg" alt="c19"></p>
<p><img src="/2019/06/08/rabbitcluster/c20.jpg" alt="c20"></p>
<h1 id="延迟插件"><a href="#延迟插件" class="headerlink" title="延迟插件"></a>延迟插件</h1><p>延迟队列可以用于消息的延迟推送，定时任务，削峰限流，降级等机制。</p>
<ul>
<li>download the ‘rabbitmq_delayed_message_exchange-0.0.1.ez’ file</li>
</ul>
<p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p>
<p><a href="http://www.rabbitmq.com/community-plugins.html" target="_blank" rel="noopener">http://www.rabbitmq.com/community-plugins.html</a></p>
<p><a href="https://bintray.com/rabbitmq/community-plugins/rabbitmq_delayed_message_exchange/v3.6.x#files/" target="_blank" rel="noopener">https://bintray.com/rabbitmq/community-plugins/rabbitmq_delayed_message_exchange/v3.6.x#files/</a></p>
<ul>
<li>PUT Directory</li>
</ul>
<p>/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.4/plugins</p>
<ul>
<li>Then run the following command</li>
</ul>
<p>Start the rabbitmq cluster for command</p>
<pre><code>rabbitmq-server -detached
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
</code></pre><ul>
<li>访问地址：<a href="http://192.168.1.21:15672/#/exchanges" target="_blank" rel="noopener">http://192.168.1.21:15672/#/exchanges</a>，添加延迟队列</li>
</ul>
<p><img src="/2019/06/08/rabbitcluster/c21.jpg" alt="c21"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>React Basic</title>
    <url>/2019/06/25/react/</url>
    <content><![CDATA[<p>学习一下前端知识来完成基本的项目。。</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li>安装node，配置环境变量</li>
<li>安装react脚手架   npm install -g create-react-app</li>
</ul>
<p>目录结构：</p>
<p><img src="/2019/06/25/react/r0.jpg" alt="r0"></p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>前端组件化，将复杂前端分割成多个组件完成</p>
<p><img src="/2019/06/25/react/r1.jpg" alt="r1"></p>
<p>在index.js中</p>
<pre><code class="js">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import &#39;./index.css&#39;;

import App from &#39;./App&#39;;
import * as serviceWorker from &#39;./serviceWorker&#39;;

ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA
serviceWorker.unregister();
</code></pre>
<p>serviceWorker用于离线保存网页</p>
<p>其中引入了app组件</p>
<p>ReactDOM.render(<app>, document.getElementById(‘root’));</app></p>
<p>在app.js中定义组件</p>
<pre><code class="js">import React from &#39;react&#39;;
import logo from &#39;./logo.svg&#39;;
import &#39;./App.css&#39;;

function App() {
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;header className=&quot;App-header&quot;&gt;
        &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;
        &lt;p&gt;
          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.
        &lt;/p&gt;
        &lt;a
          className=&quot;App-link&quot;
          href=&quot;https://reactjs.org&quot;
          target=&quot;_blank&quot;
          rel=&quot;noopener noreferrer&quot;
        &gt;
          Learn React
        &lt;/a&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p><img src="/2019/06/25/react/r2.jpg" alt="r2"></p>
<p>编写简单的组件：Rex.js</p>
<pre><code class="js">import React, { Component} from &quot;react&quot;;

class Rex extends Component{
    render() {
        return(
            &lt;div&gt;
                hello rex
            &lt;/div&gt;
        );
    }
}

export default Rex;
</code></pre>
<p>index.js中改变引用（组件的开头必须大写）</p>
<pre><code class="js">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import &#39;./index.css&#39;;

import App from &#39;./App&#39;;
import Rex from &#39;./Rex&#39;;
import * as serviceWorker from &#39;./serviceWorker&#39;;

// ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));
ReactDOM.render(&lt;Rex /&gt;, document.getElementById(&#39;root&#39;));

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA
serviceWorker.unregister();

</code></pre>
<p>显示效果：</p>
<p><img src="/2019/06/25/react/r3.jpg" alt="r3"></p>
<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>必须引入react，才可以使用JSX语法，是一种在js中使用html的方式</p>
<p>大写标签代表组件，小写标签代表html</p>
<p>react中，component render返回的html，最外层必须被包裹</p>
<pre><code class="jsx">import React , { Component, Fragment} from &#39;react&#39;;

class TodoList extends Component{
    render() {
        return(

            &lt;Fragment&gt;
                &lt;div&gt;
                    &lt;input/&gt;
                    &lt;button&gt;submit&lt;/button&gt;
                &lt;/div&gt;

                &lt;ul&gt;
                    &lt;li&gt;hahah&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/Fragment&gt;

        )
    }
}
export default TodoList;
</code></pre>
<p>Fragment为最外层隐形div（大写开头为组件）</p>
<p>JSX注释{/<em> </em>/}</p>
<p>创建css文件</p>
<pre><code class="css">.input {
    border: 1px solid red;
}
</code></pre>
<p>导入包</p>
<blockquote>
<p>impott ‘./xxx.css’;</p>
</blockquote>
<pre><code class="jsx">&lt;input
    className-&#39;input&#39;
    /&gt;
</code></pre>
<p>触发光标位置</p>
<pre><code class="jsx">&lt;label htmlFor=&quot;id&quot;&gt;label&lt;/label&gt;
</code></pre>
<h1 id="响应式与事件"><a href="#响应式与事件" class="headerlink" title="响应式与事件"></a>响应式与事件</h1><p>react中的类默认一个构造函数，会率先触发，state负责存储数据</p>
<p>react可以给页面状态，响应状态的变化</p>
<pre><code class="jsx">import React , { Component, Fragment} from &#39;react&#39;;

class TodoList extends Component{

    constructor(props) {
        super(props);
        this.state = {
            input: &#39;&#39;,
            list: []
        }
    }


    render() {
        return(

            &lt;Fragment&gt;
                &lt;div&gt;
                    &lt;input
                        value={this.state.input}
                        onChange={this.handleInputChange.bind(this)}
                    /&gt;
                    &lt;button&gt;submit&lt;/button&gt;
                &lt;/div&gt;

                &lt;ul&gt;
                    &lt;li&gt;hahah&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/Fragment&gt;

        )
    }

    handleInputChange(e){
        this.setState({
            input: e.target.value
        })
    }

}
export default TodoList;
</code></pre>
<p>绑定相同this，通过e传递数据，并通过setState改变数值，全程对数据操作</p>
<h1 id="实现一个TodoList"><a href="#实现一个TodoList" class="headerlink" title="实现一个TodoList"></a>实现一个TodoList</h1><p>react不允许对state进行操作，必须深拷贝操作，以方便优化性能</p>
<pre><code class="jsx">import React , { Component, Fragment} from &#39;react&#39;;

class TodoList extends Component{

    constructor(props) {
        super(props);
        this.state = {
            input: &#39;&#39;,
            list: []
        }
    }

    render() {
        return(
            &lt;Fragment&gt;
                &lt;div&gt;
                    &lt;input
                        value={this.state.input}
                        onChange={this.handleInputChange.bind(this)}
                    /&gt;
                    &lt;button
                        onClick={this.handleBtnClick.bind(this)}
                    &gt;Submit&lt;/button&gt;
                &lt;/div&gt;
                &lt;ul&gt;
                        {
                            this.state.list.map((item,index) =&gt;{
                                return&lt;li
                                    key={index}
                                    onClick={this.handleDelete.bind(this,index)}
                                &gt;{item}&lt;/li&gt;
                            })
                        }
                &lt;/ul&gt;
            &lt;/Fragment&gt;
        )
    }

    handleBtnClick(){
        this.setState({
            list: [...this.state.list, this.state.input],
            input: &#39;&#39;
        })
    }

    handleInputChange(e){
        this.setState({
            input: e.target.value
        })
    }

    handleDelete(index){
        const list = [...this.state.list];
        list.splice(index,1);
        this.setState({
            list: list
        })
    }

}
export default TodoList;
</code></pre>
<p><img src="/2019/06/25/react/r4.jpg" alt="r4"></p>
<h1 id="组件-js之间的传值"><a href="#组件-js之间的传值" class="headerlink" title="组件.js之间的传值"></a>组件.js之间的传值</h1><p>大组件：</p>
<pre><code class="jsx">import React, { Component, Fragment } from &#39;react&#39;;
import TodoItem from &#39;./TodoItem&#39;;
import Test from &#39;./Test&#39;;
import &#39;./style.css&#39;;

class TodoList extends Component {

    constructor(props) {
        super(props);
        // 当组件的state或者props发生改变的时候，render函数就会重新执行
        this.state = {
            inputValue: &#39;&#39;,
            list: []
        }
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        this.handleItemDelete = this.handleItemDelete.bind(this);
    }

    render() {
        return (
            &lt;Fragment&gt;
                &lt;div&gt;
                    &lt;label htmlFor=&quot;insertArea&quot;&gt;输入内容&lt;/label&gt;
                    &lt;input 
                        id=&quot;insertArea&quot;
                        className=&#39;input&#39;
                        value={this.state.inputValue}
                        onChange={this.handleInputChange}
                    /&gt;
                    &lt;button onClick={this.handleBtnClick}&gt;提交&lt;/button&gt;
                &lt;/div&gt;
                &lt;ul&gt;
                    {this.getTodoItem()}
                &lt;/ul&gt;
                &lt;Test content={this.state.inputValue}/&gt;
            &lt;/Fragment&gt;
        )
    }

    getTodoItem() {
        return this.state.list.map((item, index) =&gt; {
            return (
                &lt;TodoItem 
                    key={index}
                    content={item} 
                    index={index}
                    deleteItem={this.handleItemDelete}
                /&gt;
            )
        })
    }

    handleInputChange(e) {
        const value = e.target.value;
        this.setState(() =&gt; ({
            inputValue: value
        }));
    }

    handleBtnClick() {
        this.setState((prevState) =&gt; ({
            list: [...prevState.list, prevState.inputValue],
            inputValue: &#39;&#39;
        }));
    }

    handleItemDelete(index) {
        this.setState((prevState) =&gt; {
            const list = [...prevState.list];
            list.splice(index, 1);
            return {list}
        });
    }
}

export default TodoList;
</code></pre>
<p>小组件：</p>
<pre><code class="jsx">import React, { Component } from &#39;react&#39;;
import PropTypes from &#39;prop-types&#39;;

class TodoItem extends Component {

    constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this);
    }

    render() {
        const { content, test }  = this.props;
        // JSX -&gt; createElemnt -&gt;  虚拟DOM（JS 对象） -&gt; 真实的DOM
        // return &lt;div&gt;&lt;span&gt;item&lt;/span&gt;&lt;/div&gt;
        return React.createElement(&#39;div&#39;, {}, React.createElement(&#39;span&#39;, {}, &#39;item&#39;));
    }

    handleClick() {
        const { deleteItem, index } = this.props;
        deleteItem(index);
    }
}

TodoItem.propTypes = {
    test: PropTypes.string.isRequired,
    content: PropTypes.arrayOf(PropTypes.number, PropTypes.string),
    deleteItem: PropTypes.func,
    index: PropTypes.number
}

TodoItem.defaultProps = {
    test: &#39;hello world&#39;
}

export default TodoItem;
</code></pre>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React Skills</title>
    <url>/2019/07/07/react2/</url>
    <content><![CDATA[<p>项目调试：摇动手机打开开发者菜单</p>
<p>react native可以通过ES5,ES6，函数的方法定义组件，函数方法没有状态，不能使用this</p>
<h1 id="组件的传参"><a href="#组件的传参" class="headerlink" title="组件的传参"></a>组件的传参</h1><p>将外部的item传给TodoItem小组件，明明为content：</p>
<p><img src="/2019/07/07/react2/r0.jpg" alt="r0"></p>
<p>子组件使用传递得到的内容</p>
<p><img src="/2019/07/07/react2/r2.jpg" alt="r2"></p>
<h1 id="设置proptype和default"><a href="#设置proptype和default" class="headerlink" title="设置proptype和default"></a>设置proptype和default</h1><p>propTypes要求格式、要求非空</p>
<p>defaultProps设置默认值</p>
<pre><code class="js">TodoItem.propTypes = {
    test: PropTypes.string.isRequired,
    content: PropTypes.arrayOf(PropTypes.number, PropTypes.string),
    deleteItem: PropTypes.func,
    index: PropTypes.number
}

TodoItem.defaultProps = {
    test: &#39;hello world&#39;
}
</code></pre>
<h1 id="Props-State-Render"><a href="#Props-State-Render" class="headerlink" title="Props, State, Render"></a>Props, State, Render</h1><p>当state和props发生改变时，render函数就会执行</p>
<p>render过程效率很高，因为有虚拟DOM</p>
<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><p>render的过程</p>
<ul>
<li>State 数据</li>
<li>JSX 模板</li>
<li>数据+模板 整合生成真实DOM</li>
<li>State发生改变</li>
<li>数据+模板 整合生成真实DOM，替换原有DOM</li>
</ul>
<p>多次生成DOM非常耗费性能</p>
<p>改良过程：</p>
<ul>
<li>State 数据</li>
<li>JSX 模板</li>
<li>数据+模板 整合生成真实DOM</li>
<li>State发生改变</li>
<li>数据+模板 整合生成真实DOM，并不替换原有DOM</li>
<li>对比差异</li>
<li>局部替换</li>
</ul>
<p>最终方案：虚拟DOM</p>
<ul>
<li>State 数据</li>
<li>JSX 模板</li>
<li>数据+模板 整合生成真实DOM</li>
<li>生成虚拟DOM（一个js对象）</li>
<li>State发生改变</li>
<li>生成新的虚拟DOM</li>
<li>比较两个虚拟DOM的区别</li>
<li>直接操作DOM，改变内容</li>
</ul>
<h1 id="ref的使用"><a href="#ref的使用" class="headerlink" title="ref的使用"></a>ref的使用</h1><p>input中onchange函数</p>
<p><img src="/2019/07/07/react2/r3.jpg" alt="r3"></p>
<p>传值一个e得到DOM值，对应函数从e中得到input value</p>
<p><img src="/2019/07/07/react2/r4.jpg" alt="r4"></p>
<p>增加ref参数，引用dom节点为this.input</p>
<p><img src="/2019/07/07/react2/r5.jpg" alt="r5"></p>
<p>对应函数通过ref获得值</p>
<p><img src="/2019/07/07/react2/r6.jpg" alt="r6"></p>
<p>本质是直接操纵DOM（不推荐）</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期函数：某一时刻组件自动执行的函数</p>
<p><img src="/2019/07/07/react2/r7.jpg" alt="r7"></p>
<ul>
<li>Iinitialization</li>
</ul>
<p>constructor函数，构建props和state</p>
<ul>
<li>Mounting挂载</li>
</ul>
<p>componentWillMount，即将挂载到页面时执行</p>
<p>componentDidMount，组件挂载到页面后自动执行</p>
<p>初次加载页面时的过程：</p>
<p><img src="/2019/07/07/react2/r8.jpg" alt="r8"></p>
<ul>
<li>Updating组件更新</li>
</ul>
<p>ShoudComponentUpdate，组件被更新之前，自动执行，返回一个布尔类型，表示是否需要更新组件，如果返回false，不会继续后续流程</p>
<p>ComponentWillUpdate，在should返回true后，组件更新之前执行</p>
<p>update时的过程：</p>
<p><img src="/2019/07/07/react2/r9.jpg" alt="r9"></p>
<p>ComponentWillReceiveProps</p>
<p>接受父组件props时调用，父组件render重新执行时，子组件此函数执行</p>
<ul>
<li>UnMounting</li>
</ul>
<p>组件被卸载前执行</p>
<p>所有生命周期函数都有默认实现，唯有render函数必须自己实现才可以运行</p>
<p>使用情景：避免子组件过度渲染</p>
<p><img src="/2019/07/07/react2/r10.jpg" alt="r10"></p>
<p>使用情景：发送Ajax请求，规定写在componentDidMount中</p>
<p><img src="/2019/07/07/react2/r11.jpg" alt="r11"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Basic</title>
    <url>/2019/02/18/redis/</url>
    <content><![CDATA[<h1 id="缓存初识"><a href="#缓存初识" class="headerlink" title="缓存初识"></a>缓存初识</h1><h2 id="缓存在应用中的架构"><a href="#缓存在应用中的架构" class="headerlink" title="缓存在应用中的架构"></a>缓存在应用中的架构</h2><p><img src="/2019/02/18/redis/struct.jpg" alt="struct"></p>
<h2 id="缓存中间件"><a href="#缓存中间件" class="headerlink" title="缓存中间件"></a>缓存中间件</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><ul>
<li>支持简单数据类型</li>
<li>不支持数据持久化存储</li>
<li>不支持主从</li>
<li>不支持分片</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul>
<li>数据类型丰富</li>
<li>支持数据持久化存储</li>
<li>支持主从</li>
<li>支持分片</li>
</ul>
<h2 id="为什么Redis速度快"><a href="#为什么Redis速度快" class="headerlink" title="为什么Redis速度快"></a>为什么Redis速度快</h2><ul>
<li>完全基于内存，不受限存储器io</li>
<li>数据结构简单，数据操作简单</li>
<li>单线程处理高并发，多核可启动多实例</li>
<li>多路IO复用模型，非阻塞IO</li>
</ul>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><h3 id="FD"><a href="#FD" class="headerlink" title="FD"></a>FD</h3><ul>
<li>File Descriptor，文件描述符</li>
</ul>
<p>一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射</p>
<h3 id="传统的阻塞IO模型"><a href="#传统的阻塞IO模型" class="headerlink" title="传统的阻塞IO模型"></a>传统的阻塞IO模型</h3><p><img src="/2019/02/18/redis/iomodel.jpg" alt="iomodel"></p>
<h3 id="多路IO复用模型"><a href="#多路IO复用模型" class="headerlink" title="多路IO复用模型"></a>多路IO复用模型</h3><ul>
<li>Selector负责监听文件描述符，不堵塞程序</li>
</ul>
<p><img src="/2019/02/18/redis/selector.jpg" alt="selector"></p>
<h3 id="IO多路复用函数"><a href="#IO多路复用函数" class="headerlink" title="IO多路复用函数"></a>IO多路复用函数</h3><ul>
<li><p>epoll/kqueue/evport/select</p>
</li>
<li><p>根据环境选择</p>
</li>
<li>优先选择O（1）函数</li>
<li>保底选择O（n）函数select（扫描全部监听符）</li>
<li>基于react设计模式监听IO</li>
</ul>
<p>文件事件处理器使用多路IO复用模块，同时监听多个FD，当read，close，write等事件发生，回调FD绑定的事件处理器，实现单线程对多个FD的监控。</p>
<h2 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h2><ul>
<li>String：二进制安全，512MB，可以包含任何数据（jpg等）</li>
<li>Hash：String元素组成的字典，适合存储对象</li>
</ul>
<pre><code class="sql">hmset rex name &quot;rex&quot; age 23 title &quot;student&quot;
hget rex age
26
hset rex title &quot;researcher&quot;
</code></pre>
<ul>
<li>List：列表，按照String元素插入顺序排序</li>
</ul>
<pre><code class="sql">lpush mylist aaa
lpush mylist bbb
lpush mylist ccc
lrange mylist 0 10
ccc
bbb
aaa
</code></pre>
<ul>
<li>Set：String元素组成的无序集合，通过Hash实现，不允许重复</li>
</ul>
<pre><code class="sql">sadd myset 111
1
sadd myset 222
1
sadd myset 111
0
</code></pre>
<ul>
<li>Sorted Set：通过分数来为集合中的成员从小到大排序</li>
</ul>
<p><img src="/2019/02/18/redis/zset.jpg" alt="zset"></p>
<ul>
<li>HyperLogLog（计数），Geo（地理位置信息）</li>
</ul>
<h2 id="找出固定前缀的Key"><a href="#找出固定前缀的Key" class="headerlink" title="找出固定前缀的Key"></a>找出固定前缀的Key</h2><ul>
<li>keys [pattern]：查找所有符合给定模式的key</li>
</ul>
<blockquote>
<p>keys k1*</p>
</blockquote>
<p>返回数据量大的话，内存消耗大</p>
<ul>
<li>scan cursor [pattern] [count]</li>
</ul>
<p>基于游标的迭代器，需要基于上一次游标，延续之前的迭代过程</p>
<p>以0作为游标开始新一次的迭代，知道命令返回游标0完成一次遍历</p>
<p>一次返回数量不可控</p>
<p><img src="/2019/02/18/redis/scan.png" alt="scan"></p>
<h2 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h2><ul>
<li>互斥性（任意时刻只有一个客户端获取锁）</li>
<li>安全性（只能被持有者开锁）</li>
<li>死锁</li>
<li>容错（部分节点down掉依旧可以获取锁）</li>
</ul>
<blockquote>
<p>setnx key value</p>
</blockquote>
<p>如果key不存在，创建并赋值O(1)，success：1，failure：0</p>
<blockquote>
<p>expire key seconds</p>
</blockquote>
<p>设置key生存时间，过期会被删除</p>
<p>简单的分布式锁：</p>
<p><img src="/2019/02/18/redis/lock.jpg" alt="lock"></p>
<p>缺点：不符合原子性</p>
<blockquote>
<p>set [key] [value] [seconds] [milliseconds] [NX|XX]</p>
</blockquote>
<ul>
<li>NX：键不存在时操作</li>
<li>XX：键存在时操作</li>
<li>success：ok，failure：nil</li>
</ul>
<h2 id="大量key同时过期"><a href="#大量key同时过期" class="headerlink" title="大量key同时过期"></a>大量key同时过期</h2><ul>
<li>清理大量key耗时造成卡顿</li>
<li>解决：设置过期时间时，增加随机值</li>
</ul>
<h2 id="实现异步队列"><a href="#实现异步队列" class="headerlink" title="实现异步队列"></a>实现异步队列</h2><h3 id="使用List作为队列"><a href="#使用List作为队列" class="headerlink" title="使用List作为队列"></a>使用List作为队列</h3><ul>
<li><p>RPUSH生产消息，LPOP消费消息</p>
</li>
<li><p>缺点：没有等待队列有值</p>
</li>
<li><p>解决：应用层引入sleep机制</p>
</li>
</ul>
<h3 id="blpop-key-timeout"><a href="#blpop-key-timeout" class="headerlink" title="blpop [key] [timeout]"></a>blpop [key] [timeout]</h3><ul>
<li><p>优点：替代sleep机制</p>
</li>
<li><p>缺点：只能提供一个消费者消费</p>
</li>
</ul>
<h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h3><ul>
<li>主题订阅者模式</li>
<li>pub发送消息，sub接收消息</li>
<li>sub可以订阅任意数量的频道</li>
</ul>
<p><img src="/2019/02/18/redis/sp.jpg" alt="sp"></p>
<blockquote>
<p>subscribe [topic] </p>
<p>publish [topic] [message]</p>
</blockquote>
<p>pub/sub发布无状态，无法保证可达，下线后无法收到</p>
<p>需要消息队列技术栈解决</p>
<h2 id="Redis如何做持久化"><a href="#Redis如何做持久化" class="headerlink" title="Redis如何做持久化"></a>Redis如何做持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><ul>
<li>快照持久化：保存某个时间点的全部数据快照</li>
</ul>
<p>redis.conf</p>
<p><img src="/2019/02/18/redis/rdb.jpg" alt="rdb"></p>
<p>900s 内写入1次就存储</p>
<p>60s 内写入10000次就存储</p>
<p>增加 save “”即可禁用 </p>
<p><img src="/2019/02/18/redis/conf1.jpg" alt="conf1"></p>
<p>yes：备份进程出错，主进程停止写入操作</p>
<p>保护持久化数据一致性</p>
<p><img src="/2019/02/18/redis/conf2.jpg" alt="conf2"></p>
<p>将RDB数据压缩后再保存，会占用系统资源</p>
<p>文件存储在src/dump.rdb文件中（二进制文件）</p>
<p>保存某时刻的快照方法：</p>
<ul>
<li>save：阻塞Redis服务器进程，知道RDB文件创建完毕</li>
<li>bgsave：fork一个子进程创建RDB文件，不阻塞服务器进程</li>
</ul>
<p>可用lastsave指令查看是否成功</p>
<p><img src="/2019/02/18/redis/bgsave.png" alt="bgsave"></p>
<p>fork创建进程，将所有资源复制给子进程，效率低下，linux进行了更改copy-on-write</p>
<p><img src="/2019/02/18/redis/copyonwrite.jpg" alt="copyonwrite"></p>
<p>缺点：</p>
<ul>
<li>内存数据全部同步，数据量大影响性能（慢IO）</li>
<li>可能因为Redis挂掉丢失当前到最近一次快照而数据</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ul>
<li>保存写状态</li>
<li>记录除了查询以外的所有变更数据库状态的指令</li>
<li>以append形式追加保存到AOF文件中</li>
</ul>
<p>默认关闭</p>
<p>redis.conf</p>
<p><img src="/2019/02/18/redis/aof.jpg" alt="aof"></p>
<p>保存策略</p>
<p><img src="/2019/02/18/redis/aof2.jpg" alt="aof2"></p>
<p>每秒/总是/从不</p>
<ul>
<li>日志重写解决AOF文件大小逐渐增大问题</li>
</ul>
<p>1、调用fork()，创建子进程</p>
<p>2、子进程把新的AOF写到一个临时文件，不依赖原来的AOF文件</p>
<p>3、主进程持续将新的变动同时写道内存和原来的AOF</p>
<p>4、完成重写，发送信号给主进程，并将buffer重定向到新AOF</p>
<p>5、使用新AOF替换旧AOF</p>
<p>可手动触发</p>
<h3 id="RDB-amp-AOF共存情况下的数据恢复"><a href="#RDB-amp-AOF共存情况下的数据恢复" class="headerlink" title="RDB&amp;AOF共存情况下的数据恢复"></a>RDB&amp;AOF共存情况下的数据恢复</h3><ul>
<li>优先加载AOF</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>RDB：全量数据快照，文件小，恢复快</li>
<li>RDB：无法保存最近一次快照后的数据</li>
<li>AOF：本质是日志，可读性高，适合保存增量数据，数据不易丢失</li>
<li>AOF：文件体积大，恢复时间长</li>
</ul>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><ul>
<li>默认使用</li>
<li>先RDB备份，再AOF记录增量数据</li>
</ul>
<h2 id="Pipeline-amp-主从同步"><a href="#Pipeline-amp-主从同步" class="headerlink" title="Pipeline &amp; 主从同步"></a>Pipeline &amp; 主从同步</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><ul>
<li>Redis基于请求/响应模型，单个请求处理需要一一应答</li>
<li>Pipeline批量执行指令，节省多次IO往返时间</li>
<li>有需要顺序依赖的指令需要分批发送</li>
</ul>
<h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p><img src="/2019/02/18/redis/ms.jpg" alt="ms"></p>
<p>master：写操作          slave：读操作</p>
<ul>
<li>全同步过程</li>
</ul>
<p>1、salve发送sync到master</p>
<p>2、master启动后台进程，将redis中的数据快照保存到文件</p>
<p>3、master将保存数据快照期间受到的写命令缓存</p>
<p>4、master完成写文件操作后，将该文件发送给slave</p>
<p>5、slave使用心得AOF文件替换旧的</p>
<ul>
<li>增量同步过程</li>
</ul>
<p>1、master收到指令，判断是否需要传播到slave</p>
<p>2、将操作记录追加到AOF文件</p>
<p>3、将操作传播到其他slave：对齐master，往相应缓存里写入指令</p>
<p>4、将缓存的数据发送给slave</p>
<p>主从模式缺少高可用性，master挂掉不能服务</p>
<ul>
<li>Redis Sentinel</li>
</ul>
<p>集群管理工具</p>
<p>1、监控：检查主从服务器是否运行正常</p>
<p>2、提醒：通过API向管理员或者其他应用发送故障信息</p>
<p>3、自动故障迁移：主从切换，s变为m</p>
<h3 id="tip：Gossip流言协议"><a href="#tip：Gossip流言协议" class="headerlink" title="tip：Gossip流言协议"></a>tip：Gossip流言协议</h3><ul>
<li>混乱中寻求一致</li>
<li>每个节点都随即与对方通信，最终所有节点状态相同</li>
<li>种子节点每秒随机向其他节点发送节点列表和需要传播的信息</li>
<li>新加入的节点会被知晓</li>
<li>不保证信息一定会传递到到所有节点，但会趋于一致</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><ul>
<li>数据分片：划分数据分散到多个节点</li>
<li>无中心</li>
<li>普通hash算法不利于节点数量改变（key/node取模）</li>
</ul>
<h3 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h3><ul>
<li>对2^32取模，组成虚拟圆环</li>
</ul>
<p><img src="/2019/02/18/redis/rediscluster.jpg" alt="rediscluster"></p>
<ul>
<li><p>宕机后只影响之间的一部分数据（增加同理）</p>
</li>
<li><p>hash环倾斜问题（节点分布不均匀）</p>
</li>
</ul>
<p><img src="/2019/02/18/redis/hash.jpg" alt="hash"></p>
<p>解决：引入虚拟节点，虚拟节点均匀分布，再重映射</p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Study Note</title>
    <url>/2019/06/19/redisdeep/</url>
    <content><![CDATA[<h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><ul>
<li>开源</li>
<li>基于key-value的存储服务系统</li>
<li>多种数据结构</li>
<li>高性能、功能丰富</li>
</ul>
<p>拥有五种数据结构：</p>
<p><img src="/2019/06/19/redisdeep/r0.jpg" alt="r0"></p>
<p>Redis的典型特性：</p>
<ul>
<li>速度快： 10w OPS</li>
<li>持久化</li>
<li>多种数据结构</li>
<li>支持多种语言</li>
<li>使用简单，单线程</li>
<li>主从复制</li>
</ul>
<p>额外的数据结构：</p>
<ul>
<li>Bitmaps：位图</li>
<li>Htperloglog：超小内存唯一值计数</li>
<li>GEO：地理信息位置</li>
</ul>
<p>支持额外功能：</p>
<ul>
<li>Lua脚本</li>
<li>发布订阅</li>
<li>事务</li>
<li>pipeline</li>
</ul>
<p>典型场景：</p>
<ul>
<li>缓存</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r1.jpg" alt="r1"></p>
<ul>
<li>计数器</li>
<li>消息队列</li>
<li>排行榜</li>
<li>社交网络</li>
<li>实时系统</li>
</ul>
<p><strong>常用配置</strong></p>
<p>daemonize，是否守护进程启动</p>
<p>port，端口，默认6379</p>
<p>logfile，redis日志</p>
<p>dir，工作目录</p>
<h1 id="常用特性"><a href="#常用特性" class="headerlink" title="常用特性"></a>常用特性</h1><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ul>
<li>keys 计算所有的键</li>
</ul>
<blockquote>
<p>docker exec -it redis redis-cli</p>
</blockquote>
<p><img src="/2019/06/19/redisdeep/r2.jpg" alt="r2"></p>
<p>批量插入mset key1 value1 k2 v2 k3 v3</p>
<p><img src="/2019/06/19/redisdeep/r3.jpg" alt="r3"></p>
<p>通配符查找</p>
<p><img src="/2019/06/19/redisdeep/r4.jpg" alt="r4"></p>
<p><img src="/2019/06/19/redisdeep/r5.jpg" alt="r5"></p>
<p>keys命令为o(n)命令，所以生产中尽量不使用，开销大</p>
<ul>
<li>dbsize 数据库大小</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r6.jpg" alt="r6"></p>
<p><img src="/2019/06/19/redisdeep/r7.jpg" alt="r7"></p>
<p>sadd 增加集合，只有一个key</p>
<p>内置计数器，不会遍历表，开销很小o(1)</p>
<ul>
<li>exists key判断键是否存在</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r8.jpg" alt="r8"></p>
<p>o(1)复杂，开销小</p>
<ul>
<li>del keys 删除key</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r9.jpg" alt="r9"></p>
<ul>
<li>expire key seconds 设置key过期时间</li>
</ul>
<p>过期指令：expire、ttl、persist</p>
<p>expire，设置过期时间</p>
<p>ttl，查询过期时间</p>
<p>persist，去掉过期时间</p>
<p><img src="/2019/06/19/redisdeep/r10.jpg" alt="r10"></p>
<ul>
<li>type key 查看key数据类型</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r11.jpg" alt="r11"></p>
<p>type类型：string、hash、list、set、zset、none</p>
<p>各个命令时间复杂度</p>
<p><img src="/2019/06/19/redisdeep/r12.jpg" alt="r12"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="/2019/06/19/redisdeep/r13.jpg" alt="r13"></p>
<p>一些压缩编码可以节省空间</p>
<p><strong>RedisObject</strong></p>
<p><img src="/2019/06/19/redisdeep/r14.jpg" alt="r14"></p>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>单线程高速的原因：</p>
<ul>
<li>纯内存IO</li>
<li>非阻塞IO（NIO）</li>
<li>避免了线程切换和竞态消耗</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r15.jpg" alt="r15"></p>
<p>带来的问题：【拒绝慢命令】</p>
<p>keys, flushall, flushdb, slow lua script, mutil/exec, operate big value(collection)</p>
<p>部分操作会fork其他线程：</p>
<p>fysnc file descriptor</p>
<p>close file descriptor</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>所有key都是string，string value 至大512mb，可以存储json，xml等，整数和位图也由字符串实现</p>
<p>incr</p>
<p>incr key，自增操作+1，如果不存在，get回1、o(1)</p>
<p>decr key，自减，若不存在get回-1、o(1)</p>
<p>incrby key k，自增k，若不存在get回k、o(1)</p>
<p>decrby key k，自减k，若不存在get回-k、o(1)</p>
<p><img src="/2019/06/19/redisdeep/r16.jpg" alt="r16"></p>
<p>因为redis是单线程，所以不存在并发问题</p>
<p><strong>情景</strong></p>
<ul>
<li><p>网站访问统计</p>
<p>incr userid:pageview</p>
</li>
<li><p>缓存mysql（eg.video）</p>
</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r1.jpg" alt="r1"></p>
<p><img src="/2019/06/19/redisdeep/r17.png" alt="r17"></p>
<ul>
<li><p>实现分布式ID生成器</p>
<p>incr id，利用redis单线程</p>
</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r18.jpg" alt="r18"></p>
<p>set</p>
<p>set key value、无论是否存在，都设置、o(1)</p>
<p>setnx key value、如果不存在，则设置、o(1)</p>
<p>set key value xx，如果存在才设置、o(1)</p>
<p><img src="/2019/06/19/redisdeep/r19.jpg" alt="r19"></p>
<p>适合实现分布式锁</p>
<p>mset</p>
<p>批量设置、获取，原子操作</p>
<p>mset key1 value1 key2 value2 key3 value3 key4 value4, o(n)</p>
<p>mget key1 key2 key3 key4, o(n)</p>
<p>比起n次get操作，减少网络延迟等问题</p>
<p><img src="/2019/06/19/redisdeep/r20.jpg" alt="r20"></p>
<p><img src="/2019/06/19/redisdeep/r21.jpg" alt="r21"></p>
<p>others</p>
<p>getset key newvalue ，设置新值并返回旧值，o(1)</p>
<p>append key value，将value追加到旧的value，o(1)</p>
<p>strlen key，返回字符串value长度（不兼容中文），o(1)</p>
<p><img src="/2019/06/19/redisdeep/r22.jpg" alt="r22"></p>
<p>incrbyfloat key 3.5，增加浮点数，o(1)</p>
<p>getrange key start end，获取指定下标字符，o(1)</p>
<p>setrange key index value，设置指定下标的值，o(1)</p>
<p><img src="/2019/06/19/redisdeep/r23.jpg" alt="r23"></p>
<p><img src="/2019/06/19/redisdeep/r24.jpg" alt="r24"></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p><img src="/2019/06/19/redisdeep/r25.jpg" alt="r25"></p>
<p><img src="/2019/06/19/redisdeep/r26.jpg" alt="r26"></p>
<p>hget、hset、hdel</p>
<p>hget key field, o(1)</p>
<p>hset key field value, o(1)</p>
<p>hdel key field, o(1)</p>
<p><img src="/2019/06/19/redisdeep/r27.jpg" alt="r27"></p>
<p>hexists, o(1)，判断属性是否存在</p>
<p>hlen, o(1), 返回属性数量</p>
<p>hmget、hmset</p>
<p><img src="/2019/06/19/redisdeep/r28.jpg" alt="r28"></p>
<p>统计流量：</p>
<p>hincrby user:1:info pageview count</p>
<p>缓存视频信息：</p>
<p><img src="/2019/06/19/redisdeep/r29.jpg" alt="r29"></p>
<p><img src="/2019/06/19/redisdeep/r30.jpg" alt="r30"></p>
<p>谨慎使用o(n)</p>
<p>hash与string对比</p>
<p><img src="/2019/06/19/redisdeep/r31.jpg" alt="r31"></p>
<p>对象的实现方法</p>
<p>使用json string格式保存，但是修改需要重新序列化</p>
<p><img src="/2019/06/19/redisdeep/r32.jpg" alt="r32"></p>
<p>使用多个string储存，但是结构分离</p>
<p><img src="/2019/06/19/redisdeep/r33.jpg" alt="r33"></p>
<p>使用hash保存，随时修改</p>
<p><img src="/2019/06/19/redisdeep/r34.jpg" alt="r34"></p>
<p><img src="/2019/06/19/redisdeep/r35.jpg" alt="r35"></p>
<p>其他指令</p>
<p><img src="/2019/06/19/redisdeep/r36.jpg" alt="r36"></p>
<p>指令复杂度对比</p>
<p><img src="/2019/06/19/redisdeep/r37.jpg" alt="r37"></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>数据结构：有序、可以重复</p>
<p><img src="/2019/06/19/redisdeep/r38.jpg" alt="r38"></p>
<p><img src="/2019/06/19/redisdeep/r39.jpg" alt="r39"></p>
<p><img src="/2019/06/19/redisdeep/r40.jpg" alt="r40"></p>
<p>lpush相反</p>
<p><img src="/2019/06/19/redisdeep/r41.jpg" alt="r41"></p>
<p><img src="/2019/06/19/redisdeep/r42.jpg" alt="r42"></p>
<p>lpop相反</p>
<p><img src="/2019/06/19/redisdeep/r43.jpg" alt="r43"></p>
<p><img src="/2019/06/19/redisdeep/r44.jpg" alt="r44"></p>
<p><img src="/2019/06/19/redisdeep/r45.jpg" alt="r45"></p>
<p><img src="/2019/06/19/redisdeep/r46.jpg" alt="r46"></p>
<p><img src="/2019/06/19/redisdeep/r47.jpg" alt="r47"></p>
<p><img src="/2019/06/19/redisdeep/r48.jpg" alt="r48"></p>
<p>可以用list实现timeline列表，eg.好友动态</p>
<p>其他指令</p>
<p><img src="/2019/06/19/redisdeep/r49.jpg" alt="r49"></p>
<p><img src="/2019/06/19/redisdeep/r50.jpg" alt="r50"></p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序，不重复</p>
<p><img src="/2019/06/19/redisdeep/r51.jpg" alt="r51"></p>
<p><img src="/2019/06/19/redisdeep/r52.jpg" alt="r52"></p>
<p><img src="/2019/06/19/redisdeep/r53.jpg" alt="r53"></p>
<p>pop后set不再有该元素，rand后元素依旧在集合之中</p>
<p>smembers可能会造成阻塞，谨慎使用</p>
<p>可以实现抽奖、点赞等情景、标签等</p>
<p><img src="/2019/06/19/redisdeep/r54.jpg" alt="r54"></p>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>有序集合、不可重复</p>
<p><img src="/2019/06/19/redisdeep/r55.jpg" alt="r55"></p>
<p><img src="/2019/06/19/redisdeep/r56.jpg" alt="r56"></p>
<p><img src="/2019/06/19/redisdeep/r57.jpg" alt="r57"></p>
<p><img src="/2019/06/19/redisdeep/r58.jpg" alt="r58"></p>
<p><img src="/2019/06/19/redisdeep/r59.jpg" alt="r59"></p>
<p>传负数表示减少</p>
<p><img src="/2019/06/19/redisdeep/r60.jpg" alt="r60"></p>
<p><img src="/2019/06/19/redisdeep/r61.jpg" alt="r61"></p>
<p>n，zset中元素的个数，m，排名段内元素的个数（按照排名）</p>
<p><img src="/2019/06/19/redisdeep/r62.jpg" alt="r62"></p>
<p>n，zset中元素的个数，m，分数段内元素的个数（按照分数）</p>
<p><img src="/2019/06/19/redisdeep/r63.jpg" alt="r63"></p>
<p><img src="/2019/06/19/redisdeep/r64.jpg" alt="r64"></p>
<p><img src="/2019/06/19/redisdeep/r65.jpg" alt="r65"></p>
<p>使用情景：排行榜</p>
<p><img src="/2019/06/19/redisdeep/r66.jpg" alt="r66"></p>
<h1 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>Jedis是redis-cli（shell）的java版本</p>
<p><img src="/2019/06/19/redisdeep/r67.jpg" alt="r67"></p>
<p><img src="/2019/06/19/redisdeep/r68.jpg" alt="r68"></p>
<p><img src="/2019/06/19/redisdeep/r69.jpg" alt="r69"></p>
<p>Jedis直连，基于tcp连接</p>
<p><img src="/2019/06/19/redisdeep/r70.jpg" alt="r70"></p>
<p>Jedis连接池，节省了部分new开销</p>
<p><img src="/2019/06/19/redisdeep/r71.jpg" alt="r71"></p>
<p><img src="/2019/06/19/redisdeep/r72.jpg" alt="r72"></p>
<p><img src="/2019/06/19/redisdeep/r73.jpg" alt="r73"></p>
<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p><img src="/2019/06/19/redisdeep/r74.jpg" alt="r74"></p>
<p>redigo的使用：<br><img src="/2019/06/19/redisdeep/r75.jpg" alt="r75"></p>
<p><img src="/2019/06/19/redisdeep/r76.jpg" alt="r76"></p>
<h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>生命周期：</p>
<p><img src="/2019/06/19/redisdeep/r77.jpg" alt="r77"></p>
<p>如果慢查询，会进入一个先入先出的固定长度队列</p>
<p><img src="/2019/06/19/redisdeep/r78.jpg" alt="r78"></p>
<p><img src="/2019/06/19/redisdeep/r79.jpg" alt="r79"></p>
<p>配置方法</p>
<p><img src="/2019/06/19/redisdeep/r80.jpg" alt="r80"></p>
<p>常用指令</p>
<p><img src="/2019/06/19/redisdeep/r81.jpg" alt="r81"></p>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>重复命令的网络开销</p>
<p><img src="/2019/06/19/redisdeep/r82.jpg" alt="r82"></p>
<p>pipeline实现一次网络开销</p>
<p>jadis的实现举例</p>
<p><img src="/2019/06/19/redisdeep/r83.jpg" alt="r83"></p>
<p><img src="/2019/06/19/redisdeep/r84.jpg" alt="r84"></p>
<p>与m操作的区别？</p>
<p>m操作的原子的，pipeline不是原子的</p>
<p>应当注意每次pipeline的数据量，可以合理拆分</p>
<p>pipeline只能作用在一个redis节点</p>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p><img src="/2019/06/19/redisdeep/r85.jpg" alt="r85"></p>
<pre><code class="java">publish channel message
subscribe [channel]   // one or more
unsubscribe [channel]   // one or more
psubscribe [channel pattern]
punsubscribe [channel pattern]
pubsub channels // list the channel at least one subscriber
pubsub numsub [channel] //list the subscriber number

</code></pre>
<p>实现消息队列</p>
<p><img src="/2019/06/19/redisdeep/r86.jpg" alt="r86"></p>
<p>消息只会传达一个消费者</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>直接操作位</p>
<p><img src="/2019/06/19/redisdeep/r87.jpg" alt="r87"></p>
<p>getbit、setbit key offset</p>
<p>bitcount key [start end] 获取全部位为1的个数</p>
<p><img src="/2019/06/19/redisdeep/r88.jpg" alt="r88"></p>
<p>BITPOS key bit [start] [end]</p>
<p>返回字符串里面第一个被设置为1或者0的bit位。</p>
<p>返回一个位置，把字符串当做一个从左到右的字节数组，第一个符合条件的在位置0，其次在位置8，等等。</p>
<p>位图可以有效节省空间</p>
<h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><p>极小空间完成独立数量统计，本质为string</p>
<p><img src="/2019/06/19/redisdeep/r89.jpg" alt="r89"></p>
<p><img src="/2019/06/19/redisdeep/r90.jpg" alt="r90"></p>
<p>可以极大的减少空间开支，但是有错误率0.81%</p>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>Redis3.2增加</p>
<p>存储经纬度，计算两地距离等</p>
<p>geo key longitude latitude membername</p>
<p>geopos key member [member…]  //get info</p>
<p>geodist key member1 member2 [unit]  //calculate the distance </p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>将内存的临时数据保存在硬盘中（异步）</p>
<p>快照：mysql dump， redis rdb</p>
<p>日志：mysql binlog，redis aof</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><img src="/2019/06/19/redisdeep/r91.jpg" alt="r91"></p>
<p>触发机制：</p>
<ul>
<li>save（同步）</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r92.jpg" alt="r92"></p>
<p>但是可能造成阻塞</p>
<p>文件策略</p>
<p>如果存在老的快照，则会创建新的快照以替换</p>
<p>复杂度为o(n)</p>
<ul>
<li>bgsave（异步）</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r93.jpg" alt="r93"></p>
<p><img src="/2019/06/19/redisdeep/r94.jpg" alt="r94"></p>
<ul>
<li>自动</li>
</ul>
<p>常用配置，任意一条满足都会执行</p>
<p><img src="/2019/06/19/redisdeep/r95.jpg" alt="r95"></p>
<p>不可忽略的触发机制：</p>
<ul>
<li>全量复制（主从复制）</li>
<li>debug reload</li>
<li>shutdown</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>RDB耗时，耗性能（内存dump）</p>
<p>RDB不可控，可能因为宕机丢失</p>
<p>AOF基本可以实现实时恢复</p>
<p>三种策略：</p>
<ul>
<li>always</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r96.jpg" alt="r96"></p>
<ul>
<li>everysec(default)</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r97.jpg" alt="r97"></p>
<ul>
<li>no</li>
</ul>
<p><img src="/2019/06/19/redisdeep/r98.jpg" alt="r98"></p>
<p><img src="/2019/06/19/redisdeep/r99.jpg" alt="r99"></p>
<p>AOF文件会很巨大，所以需要重写策略，从而减少磁盘占用，并且增加恢复速度</p>
<p><img src="/2019/06/19/redisdeep/r100.jpg" alt="r100"></p>
<p>可以使用bgrewriteaof命令显式要求重写</p>
<p><img src="/2019/06/19/redisdeep/r101.jpg" alt="r101"></p>
<p>可以在配置文件中设置aof文件尺寸和增长率，同时满足时触发重写</p>
<p><img src="/2019/06/19/redisdeep/r102.jpg" alt="r102"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/2019/07/08/reduxnote/</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Redux是一个数据层框架，方便组件之间的传值</p>
<p><img src="/2019/07/08/reduxnote/r0.jpg" alt="r0"></p>
<p>Store为公共存储区域，所有组件会自动感知到Store的变化</p>
<p>Redux = Reducer + Flux</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/2019/07/08/reduxnote/r1.jpg" alt="r1"></p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>纯函数：固定输入，一定有固定输出（例如不允许date（）函数等，以及Ajax请求），</p>
<p>并且无其他副作用（对参数不进行修改，深拷贝）</p>
<p><img src="/2019/07/08/reduxnote/r6.jpg" alt="r6"></p>
<h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><p><img src="/2019/07/08/reduxnote/r7.jpg" alt="r7"></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="Antd"><a href="#Antd" class="headerlink" title="Antd"></a>Antd</h2><p>Antd为一个样式表，提供更好看的UI</p>
<blockquote>
<p>yarn add antd</p>
</blockquote>
<blockquote>
<p>import ‘antd/dist/antd.css’;</p>
</blockquote>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><blockquote>
<p>yarn add redux</p>
</blockquote>
<p>创建store文件夹，index.js文件</p>
<pre><code class="jsx">import { createStore } from &#39;redux&#39;;
import reducer from &#39;./reducer&#39;;

const store = createStore(reducer);

export default store;
</code></pre>
<p>reducer相当于笔记本，返回state</p>
<p>state表示store中的数据，可以设置为default</p>
<p>reducer.js</p>
<pre><code class="jsx">const defaultState = {
    inputValue: &#39;&#39;,
    list: []
}

// reducer 可以接受state，但是绝不能修改state

export default (state = defaultState, action) =&gt; {
    return state;
}
</code></pre>
<p>使用store时，在相应的component中引入store</p>
<blockquote>
<p>import store from ‘./store/‘</p>
<p>this.state = store.getState()</p>
</blockquote>
<h2 id="Redux调试"><a href="#Redux调试" class="headerlink" title="Redux调试"></a>Redux调试</h2><p>下载工具reduxdev，并在store参数中加入</p>
<pre><code class="jsx">const store = createStore(
    reducer, 
    window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()
);
</code></pre>
<h1 id="Action-amp-Reducer"><a href="#Action-amp-Reducer" class="headerlink" title="Action &amp; Reducer"></a>Action &amp; Reducer</h1><p>改变store中的数据，使用action</p>
<p>在component对应函数中，创建action</p>
<p>并将此action回传给store，通过dispatch</p>
<p><img src="/2019/07/08/reduxnote/r2.jpg" alt="r2"></p>
<p><img src="/2019/07/08/reduxnote/r1.jpg" alt="r1"></p>
<p>store会将当前值和action传给reducer，并结合进行操作，返回新的值</p>
<p><img src="/2019/07/08/reduxnote/r3.jpg" alt="r3"></p>
<p>深拷贝后return new state，并在store中做更新</p>
<p>在对应组件中做更新，只要store中的数据发生了改变，则执行对应函数</p>
<p><img src="/2019/07/08/reduxnote/r4.jpg" alt="r4"></p>
<p>在函数中刷新组件state，触发render</p>
<p><img src="/2019/07/08/reduxnote/r5.jpg" alt="r5"></p>
<p>reducer.js</p>
<pre><code class="jsx">import { INIT_LIST_ACTION, CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM } from &#39;./actionTypes&#39;

const defaultState = {
    inputValue: &#39;&#39;,
    list: []
}

// reducer 可以接受state，但是绝不能修改state
// 纯函数指的是，给定固定的输入，就一定会有固定的输出，而且不会有任何副作用
export default (state = defaultState, action) =&gt; {

    if (action.type === CHANGE_INPUT_VALUE) {
        const newState = JSON.parse(JSON.stringify(state));
        newState.inputValue = action.value;
        return newState;
    }

    if (action.type === INIT_LIST_ACTION) {
        const newState = JSON.parse(JSON.stringify(state));
        newState.list = action.data;
        return newState;
    }

    if (action.type === ADD_TODO_ITEM) {
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.push(newState.inputValue);
        newState.inputValue = &#39;&#39;;
        return newState;
    }
    if (action.type === DELETE_TODO_ITEM) {
        const newState = JSON.parse(JSON.stringify(state));
        newState.list.splice(action.index, 1);
        return newState;
    }
    return state;
}
</code></pre>
<h1 id="ActionType"><a href="#ActionType" class="headerlink" title="ActionType"></a>ActionType</h1><p>actionType.js</p>
<pre><code class="jsx">export const CHANGE_INPUT_VALUE = &#39;change_input_value&#39;;
export const ADD_TODO_ITEM = &#39;add_todo_item&#39;;
export const DELETE_TODO_ITEM = &#39;delete_todo_item&#39;;
export const INIT_LIST_ACTION = &#39;init_list_action&#39;;
</code></pre>
<blockquote>
<p>import { getInputChangeAction, getAddItemAction, getDeleteItemAction, initListAction } from ‘./store/actionCreators’</p>
</blockquote>
<p>component和reducer中引入</p>
<p>并替换action中的type</p>
<h1 id="actionCreator"><a href="#actionCreator" class="headerlink" title="actionCreator"></a>actionCreator</h1><p>避免直接定义action，使用creator统一创建，方便管理</p>
<p>actionCreator.js</p>
<pre><code class="jsx">import { CHANGE_INPUT_VALUE, ADD_TODO_ITEM, DELETE_TODO_ITEM, INIT_LIST_ACTION } from &#39;./actionTypes&#39;;

export const getInputChangeAction = (value) =&gt; ({
    type: CHANGE_INPUT_VALUE,
    value
});

export const getAddItemAction = () =&gt; ({
    type: ADD_TODO_ITEM
});

export const getDeleteItemAction = (index) =&gt; ({
    type: DELETE_TODO_ITEM,
    index
});

export const initListAction = (data) =&gt; ({
    type: INIT_LIST_ACTION,
    data
});
</code></pre>
<p>在component中引入</p>
<blockquote>
<p>import { getInputChangeAction, getAddItemAction, getDeleteItemAction, initListAction } from ‘./store/actionCreators’</p>
</blockquote>
<pre><code class="jsx">handleInputChange(e) {
        const action = getInputChangeAction(e.target.value);
        store.dispatch(action);
    }

    handleStoreChange() {
        this.setState(store.getState());
    }

    handleBtnClick() {
        const action = getAddItemAction();
        store.dispatch(action);
    }

    handleItemDelete(index) {
        const action = getDeleteItemAction(index);
        store.dispatch(action);
    }
</code></pre>
<h1 id="UI与容器组件"><a href="#UI与容器组件" class="headerlink" title="UI与容器组件"></a>UI与容器组件</h1><p>将渲染与逻辑区分，UI组件负责渲染，容器组件负责逻辑</p>
<p>UI.js</p>
<pre><code class="jsx">import React, { Component } from &#39;react&#39;;
import { Input, Button, List } from &#39;antd&#39;;

class TodoListUI extends Component{
   render() {
    return (
        &lt;div style={{marginTop: '10px', marginLeft: '10px'}}&gt;
            &lt;div&gt;
                &lt;Input 
                    value={this.props.inputValue} 
                    placeholder=&#39;todo info&#39; 
                    style={{width: '300px', marginRight: '10px'}}
                    onChange={this.props.handleInputChange}
                /&gt;
                &lt;Button type=&quot;primary&quot; onClick={this.props.handleBtnClick}&gt;提交&lt;/Button&gt;
            &lt;/div&gt;
            &lt;List
                style={{marginTop: '10px', width: '300px'}}
          bordered
          dataSource={this.props.list}
          renderItem={(item, index) =&gt; (&lt;List.Item onClick={(index) =&gt;         {this.props.handleItemDelete(index)}}&gt;{item}&lt;/List.Item&gt;)}
        /&gt;
        &lt;/div&gt;
    )
  } 
}
export default TodoListUI;
</code></pre>
<p>list.js</p>
<pre><code class="jsx">import React, { Component } from &#39;react&#39;;
import &#39;antd/dist/antd.css&#39;;
import store from &#39;./store&#39;;
import { getInputChangeAction, getAddItemAction, getDeleteItemAction, initListAction } from &#39;./store/actionCreators&#39;
import TodoListUI from &#39;./TodoListUI&#39;;
import axios from &#39;axios&#39;;

class TodoList extends Component {

    constructor(props) {
        super(props);
        this.state = store.getState();
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleStoreChange = this.handleStoreChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        this.handleItemDelete = this.handleItemDelete.bind(this)
        store.subscribe(this.handleStoreChange);
    }

    render() {
        return (
            &lt;TodoListUI 
                inputValue={this.state.inputValue}
                list={this.state.list}
                handleInputChange={this.handleInputChange}
                handleBtnClick={this.handleBtnClick}
                handleItemDelete={this.handleItemDelete}
            /&gt;
        )
    }

    componentDidMount() {
        axios.get(&#39;/list.json&#39;).then((res) =&gt; {
            const data = res.data;
            const action = initListAction(data);
            store.dispatch(action);
        })
    }

    handleInputChange(e) {
        const action = getInputChangeAction(e.target.value);
        store.dispatch(action);
    }

    handleStoreChange() {
        this.setState(store.getState());
    }

    handleBtnClick() {
        const action = getAddItemAction();
        store.dispatch(action);
    }

    handleItemDelete(index) {
        const action = getDeleteItemAction(index);
        store.dispatch(action);
    }

}

export default TodoList;
</code></pre>
<h1 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h1><p>只有render函数的组件（相当于是一个函数），常为UI组件</p>
<p>把render return 改为一个函数,将this.props改为props</p>
<pre><code class="jsx">import React, { Component } from &#39;react&#39;;
import { Input, Button, List } from &#39;antd&#39;;

const TodoListUI = (props)=&gt; {
    return (
        &lt;div style={{marginTop: '10px', marginLeft: '10px'}}&gt;
            &lt;div&gt;
                &lt;Input 
                    value={props.inputValue} 
                    placeholder=&#39;todo info&#39; 
                    style={{width: '300px', marginRight: '10px'}}
                    onChange={props.handleInputChange}
                /&gt;
                &lt;Button type=&quot;primary&quot; onClick={props.handleBtnClick}&gt;提交&lt;/Button&gt;
            &lt;/div&gt;
            &lt;List
                style={{marginTop: '10px', width: '300px'}}
          bordered
          dataSource={props.list}
          renderItem={(item, index) =&gt; (&lt;List.Item onClick={(index) =&gt; {props.handleItemDelete(index)}}&gt;{item}&lt;/List.Item&gt;)}
        /&gt;
        &lt;/div&gt;
    )
}

export default TodoListUI;
</code></pre>
<p>无需执行生命周期，无状态组件效率更高</p>
<h1 id="Redux中异步请求数据"><a href="#Redux中异步请求数据" class="headerlink" title="Redux中异步请求数据"></a>Redux中异步请求数据</h1><pre><code class="jsx">componentDidMount() {
        axios.get(&#39;/list.json&#39;).then((res) =&gt; {
            const data = res.data;
            const action = initListAction(data);
            store.dispatch(action);
        })
    }
</code></pre>
<p>actionCreator.js</p>
<pre><code class="jsx">export const initListAction = (data) =&gt; ({
    type: INIT_LIST_ACTION,
    data
});
</code></pre>
<h1 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h1><p>引入provider</p>
<p><img src="/2019/07/08/reduxnote/r8.jpg" alt="r8"></p>
<p>provider将store提供给了内部的所有组件（todolist）</p>
<p>在todolist中引入connect和store，并且连接</p>
<p><img src="/2019/07/08/reduxnote/r9.jpg" alt="r9"></p>
<p><img src="/2019/07/08/reduxnote/r10.jpg" alt="r10"></p>
<p>传入两个参数，实现prop.function调用</p>
<blockquote>
<p>this.props.changeInputValue</p>
</blockquote>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>SET-Architecture</title>
    <url>/2019/06/09/setstruct/</url>
    <content><![CDATA[<p><img src="/2019/06/09/setstruct/title.jpeg" alt="title"></p>
<h1 id="SET架构演进"><a href="#SET架构演进" class="headerlink" title="SET架构演进"></a>SET架构演进</h1><h2 id="传统架构问题"><a href="#传统架构问题" class="headerlink" title="传统架构问题"></a>传统架构问题</h2><p><strong>容灾</strong></p>
<ul>
<li>核心业务挂掉，影响全网用户</li>
<li>数据库主库挂掉，无法切换和恢复</li>
</ul>
<p><strong>资源扩展</strong></p>
<ul>
<li>单个IDC无法满足，扩展IDC，存在跨机房时延</li>
<li>单点数据库主库，连接数有限，无法支持持续扩展</li>
</ul>
<p><strong>大集群拆分</strong></p>
<ul>
<li>集群规模扩大后会带来相应问题</li>
</ul>
<h2 id="同城双活"><a href="#同城双活" class="headerlink" title="同城双活"></a>同城双活</h2><ul>
<li>业务上双活，分别承担部分流量</li>
<li>存储上主从架构，会发生跨机房写</li>
<li>数据中心故障后，切换流量</li>
</ul>
<h2 id="两地三中心"><a href="#两地三中心" class="headerlink" title="两地三中心"></a>两地三中心</h2><ul>
<li>在同城双活基础上，异地部署灾备数据中心</li>
</ul>
<p><img src="/2019/06/09/setstruct/s1.jpg" alt="s1"></p>
<h2 id="SET化"><a href="#SET化" class="headerlink" title="SET化"></a>SET化</h2><ul>
<li>解决业务扩展、容灾等需求</li>
<li>形成通用解决方案，方便各业务线接入</li>
</ul>
<h1 id="SET架构策略"><a href="#SET架构策略" class="headerlink" title="SET架构策略"></a>SET架构策略</h1><p><img src="/2019/06/09/setstruct/s2.jpg" alt="s2"></p>
<p>与微服务的区别：纵向切割，用户操作路线在一个机房内完成</p>
<h2 id="流量路由"><a href="#流量路由" class="headerlink" title="流量路由"></a>流量路由</h2><ul>
<li>按照特殊key进行路由（userid等），判断请求该路由到中心还是单元集群</li>
</ul>
<h2 id="中心集群"><a href="#中心集群" class="headerlink" title="中心集群"></a>中心集群</h2><ul>
<li>未经过单元化改造的服务，不在核心交易链路，称为中心集群</li>
</ul>
<h2 id="单元化集群"><a href="#单元化集群" class="headerlink" title="单元化集群"></a>单元化集群</h2><ul>
<li>每个单元化集群只负责本单元内的流量处理，以实现流量拆分和故障隔离</li>
<li>每个单元化集群前期只存储本单元产生的数据，后续会进行双向数据同步，实现容灾切换需求</li>
</ul>
<p><strong>中间件</strong></p>
<ul>
<li><p>RPC</p>
<p>SET服务，SET内调用</p>
<p>非SET服务，沿用现有路由逻辑</p>
</li>
<li><p>KV</p>
<p>支持分SET数据生产和查询</p>
</li>
<li><p>MQ</p>
<p>支持分SET消息生产和消费</p>
</li>
</ul>
<p><strong>数据同步</strong></p>
<ul>
<li>全局数据部署在中心集群，其他单元化集群同步到本单元内</li>
</ul>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>异地容灾</li>
<li>高效本地服务，流量可以路由到最近的SET</li>
<li>集装箱式扩展，实现一键部署</li>
</ul>
<p><img src="/2019/06/09/setstruct/s3.jpg" alt="s3"></p>
<p>可以跨SET调用，灵活容灾</p>
<p><img src="/2019/06/09/setstruct/s4.jpg" alt="s4"></p>
<h1 id="SET架构原则"><a href="#SET架构原则" class="headerlink" title="SET架构原则"></a>SET架构原则</h1><ul>
<li>业务面透明</li>
<li>切分规则按需定制，优先最大维度切分(例如位置信息)</li>
<li>部署规范原则，单个SET尽量不跨地域，或过大集群</li>
</ul>
<h1 id="RabbitMQ的SET化实现"><a href="#RabbitMQ的SET化实现" class="headerlink" title="RabbitMQ的SET化实现"></a>RabbitMQ的SET化实现</h1><p>双活实现</p>
<p><img src="/2019/06/09/setstruct/s5.jpg" alt="s5"></p>
<p>插件设置成功</p>
<p><img src="/2019/06/09/setstruct/s6.jpg" alt="s6"></p>
<p>add upstream</p>
<p><img src="/2019/06/09/setstruct/s7.jpg" alt="s7"></p>
<p><img src="/2019/06/09/setstruct/s8.jpg" alt="s8"></p>
<p>add policy</p>
<p><img src="/2019/06/09/setstruct/s9.jpg" alt="s9"></p>
<p><img src="/2019/06/09/setstruct/s10.jpg" alt="s10"></p>
<p><img src="/2019/06/09/setstruct/s11.jpg" alt="s11"></p>
<p>于另外一个节点</p>
<p><img src="/2019/06/09/setstruct/s12.jpg" alt="s12"></p>
<p><img src="/2019/06/09/setstruct/s13.jpg" alt="s13"></p>
<p>从而实现数据同步</p>
<p>如果需要本地消费，再加一个新的队列</p>
<p><img src="/2019/06/09/setstruct/s14.jpg" alt="s14"></p>
<p>添加路由关系</p>
<p><img src="/2019/06/09/setstruct/s15.jpg" alt="s15"></p>
<p><img src="/2019/06/09/setstruct/s16.jpg" alt="s16"></p>
<p><img src="/2019/06/09/setstruct/s17.jpg" alt="s17"></p>
<p><img src="/2019/06/09/setstruct/s18.jpg" alt="s18"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>Sorting Algorithm</title>
    <url>/2019/05/03/sort/</url>
    <content><![CDATA[<p><img src="/2019/05/03/sort/o.jpg" alt="o"></p>
<h1 id="Select-Sort"><a href="#Select-Sort" class="headerlink" title="Select Sort"></a>Select Sort</h1><pre><code class="java">public class SelectionSort {
    private SelectionSort(){}
    public static void sort(int[] arr){
        int n = arr.length;
        for( int i = 0 ; i &lt; n ; i ++ ){
            // 寻找[i, n)区间里的最小值的索引
            int minIndex = i;
            for( int j = i + 1 ; j &lt; n ; j ++ )
                if( arr[j] &lt; arr[minIndex] )
                    minIndex = j;
            swap( arr , i , minIndex);
        }
    }
    private static void swap(int[] arr, int i, int j) {
        int t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
    public static void main(String[] args) {
        int[] arr = {10,9,8,7,6,5,4,3,2,1};
        SelectionSort.sort(arr);
        for( int i = 0 ; i &lt; arr.length ; i ++ ){
            System.out.print(arr[i]);
            System.out.print(&#39; &#39;);
        }
        System.out.println();
    }
}
</code></pre>
<h1 id="Insert-Sort"><a href="#Insert-Sort" class="headerlink" title="Insert Sort"></a>Insert Sort</h1><ul>
<li>内层循环可能不需要执行满，因为比选择排序快（可提前终止内层循环，最快速度高）</li>
</ul>
<pre><code class="java">import java.util.*;
public class InsertionSort{
    private InsertionSort(){}
    public static void sort(Comparable[] arr){
        int n = arr.length;
        for (int i = 0; i &lt; n; i++) {
            // 寻找元素arr[i]合适的插入位置
            // 写法1
//            for( int j = i ; j &gt; 0 ; j -- )
//                if( arr[j].compareTo( arr[j-1] ) &lt; 0 )
//                    swap( arr, j , j-1 );
//                else
//                    break;

            // 写法2
//            for( int j = i; j &gt; 0 &amp;&amp; arr[j].compareTo(arr[j-1]) &lt; 0 ; j--)
//                swap(arr, j, j-1);

            // 写法3
            // 减少swap赋值操作
            Comparable e = arr[i];
            int j = i;
            for( ; j &gt; 0 &amp;&amp; arr[j-1].compareTo(e) &gt; 0 ; j--)
                arr[j] = arr[j-1];
            arr[j] = e;
        }
    }
    private static void swap(Object[] arr, int i, int j) {
        Object t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}
</code></pre>
<h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge-Sort"></a>Merge-Sort</h1><pre><code class="java">import java.util.*;
// 优化的Merge Sort算法
public class MergeSort2{

    private MergeSort2(){}

    // 将arr[l...mid]和arr[mid+1...r]两部分进行归并
    private static void merge(Comparable[] arr, int l, int mid, int r) {

        Comparable[] aux = Arrays.copyOfRange(arr, l, r+1);

        // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1
        int i = l, j = mid+1;
        for( int k = l ; k &lt;= r; k ++ ){

            if( i &gt; mid ){  // 如果左半部分元素已经全部处理完毕
                arr[k] = aux[j-l]; j ++;
            }
            else if( j &gt; r ){   // 如果右半部分元素已经全部处理完毕
                arr[k] = aux[i-l]; i ++;
            }
            else if( aux[i-l].compareTo(aux[j-l]) &lt; 0 ){  // 左半部分所指元素 &lt; 右半部分所指元素
                arr[k] = aux[i-l]; i ++;
            }
            else{  // 左半部分所指元素 &gt;= 右半部分所指元素
                arr[k] = aux[j-l]; j ++;
            }
        }
    }

    // 递归使用归并排序,对arr[l...r]的范围进行排序
    private static void sort(Comparable[] arr, int l, int r) {

        // 优化2: 对于小规模数组, 使用插入排序
        if( r - l &lt;= 15 ){
            InsertionSort.sort(arr, l, r);
            return;
        }

        int mid = (l+r)/2;
        sort(arr, l, mid);
        sort(arr, mid + 1, r);

        // 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge
        // 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失
        if( arr[mid].compareTo(arr[mid+1]) &gt; 0 )
            merge(arr, l, mid, r);
    }

    public static void sort(Comparable[] arr){

        int n = arr.length;
        sort(arr, 0, n-1);
    }
}
</code></pre>
<pre><code class="java">public class MergeSortBU{
    private MergeSortBU(){}

    // 将arr[l...mid]和arr[mid+1...r]两部分进行归并
    private static void merge(Comparable[] arr, int l, int mid, int r) {

        Comparable[] aux = Arrays.copyOfRange(arr, l, r+1);

        // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1
        int i = l, j = mid+1;
        for( int k = l ; k &lt;= r; k ++ ){

            if( i &gt; mid ){  // 如果左半部分元素已经全部处理完毕
                arr[k] = aux[j-l]; j ++;
            }
            else if( j &gt; r ){   // 如果右半部分元素已经全部处理完毕
                arr[k] = aux[i-l]; i ++;
            }
            else if( aux[i-l].compareTo(aux[j-l]) &lt; 0 ){  // 左半部分所指元素 &lt; 右半部分所指元素
                arr[k] = aux[i-l]; i ++;
            }
            else{  // 左半部分所指元素 &gt;= 右半部分所指元素
                arr[k] = aux[j-l]; j ++;
            }
        }
    }

    public static void sort(Comparable[] arr){

        int n = arr.length;

        // Merge Sort Bottom Up 无优化版本
//        for (int sz = 1; sz &lt; n; sz *= 2)
//            for (int i = 0; i &lt; n - sz; i += sz+sz)
//                // 对 arr[i...i+sz-1] 和 arr[i+sz...i+2*sz-1] 进行归并
//                merge(arr, i, i+sz-1, Math.min(i+sz+sz-1,n-1));

        // Merge Sort Bottom Up 优化
        // 对于小数组, 使用插入排序优化
        for( int i = 0 ; i &lt; n ; i += 16 )
            InsertionSort.sort(arr, i, Math.min(i+15, n-1) );

        for( int sz = 16; sz &lt; n ; sz += sz )
            for( int i = 0 ; i &lt; n - sz ; i += sz+sz )
                // 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge
                if( arr[i+sz-1].compareTo(arr[i+sz]) &gt; 0 )
                    merge(arr, i, i+sz-1, Math.min(i+sz+sz-1,n-1) );
    }
}
</code></pre>
<h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick-Sort"></a>Quick-Sort</h1><p><img src="/2019/05/03/sort/quick.jpg" alt="quick"></p>
<p>本质是不平均的归并，递归树不平衡，高度可能很高，最差退化为n^2，即为有序时</p>
<p>或者随机产生标杆</p>
<p><img src="/2019/05/03/sort/parti.jpg" alt="parti"></p>
<pre><code class="java">public class QuickSort {

    // 我们的算法类不允许产生任何实例
    private QuickSort(){}

    // 对arr[l...r]部分进行partition操作
    // 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]
    private static int partition(Comparable[] arr, int l, int r){

        Comparable v = arr[l];

        int j = l; // arr[l+1...j] &lt; v ; arr[j+1...i) &gt; v
        for( int i = l + 1 ; i &lt;= r ; i ++ )
            if( arr[i].compareTo(v) &lt; 0 ){
                j ++;
                swap(arr, j, i);
            }

        swap(arr, l, j);

        return j;
    }

    // 递归使用快速排序,对arr[l...r]的范围进行排序
    private static void sort(Comparable[] arr, int l, int r){

        if( l &gt;= r )
            return;

        int p = partition(arr, l, r);
        sort(arr, l, p-1 );
        sort(arr, p+1, r);
    }

    public static void sort(Comparable[] arr){

        int n = arr.length;
        sort(arr, 0, n-1);
    }

    private static void swap(Object[] arr, int i, int j) {
        Object t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}
</code></pre>
<p>双路快排</p>
<p><img src="/2019/05/03/sort/parti2.jpg" alt="parti2"></p>
<pre><code class="java">public class QuickSort2Ways {

    private QuickSort2Ways(){}

    // 双路快速排序的partition
    // 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]
    private static int partition(Comparable[] arr, int l, int r){

        // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
        swap( arr, l , (int)(Math.random()*(r-l+1))+l );

        Comparable v = arr[l];

        // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v
        int i = l+1, j = r;
        while( true ){
            // 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0
            while( i &lt;= r &amp;&amp; arr[i].compareTo(v) &lt; 0 )
                i ++;

            // 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0
            while( j &gt;= l+1 &amp;&amp; arr[j].compareTo(v) &gt; 0 )
                j --;
            if( i &gt; j )
                break;

            swap( arr, i, j );
            i ++;
            j --;
        }

        swap(arr, l, j);

        return j;
    }

    // 递归使用快速排序,对arr[l...r]的范围进行排序
    private static void sort(Comparable[] arr, int l, int r){

        // 对于小规模数组, 使用插入排序
        if( r - l &lt;= 15 ){
            InsertionSort.sort(arr, l, r);
            return;
        }

        int p = partition(arr, l, r);
        sort(arr, l, p-1 );
        sort(arr, p+1, r);
    }

    public static void sort(Comparable[] arr){

        int n = arr.length;
        sort(arr, 0, n-1);
    }

    private static void swap(Object[] arr, int i, int j) {
        Object t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}
</code></pre>
<p>应对大量重复值，使用三路排序</p>
<p><img src="/2019/05/03/sort/quick3.jpg" alt="quick3"></p>
<p><img src="/2019/05/03/sort/finish.jpg" alt="finish"></p>
<p>碰头后，l,lt交换位置</p>
<pre><code class="java">public class QuickSort3Ways {

    private QuickSort3Ways(){}

    // 递归使用快速排序,对arr[l...r]的范围进行排序
    private static void sort(Comparable[] arr, int l, int r){

        // 对于小规模数组, 使用插入排序
        if( r - l &lt;= 15 ){
            InsertionSort.sort(arr, l, r);
            return;
        }

        // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
        swap( arr, l, (int)(Math.random()*(r-l+1)) + l );

        Comparable v = arr[l];

        int lt = l;     // arr[l+1...lt] &lt; v
        int gt = r + 1; // arr[gt...r] &gt; v
        int i = l+1;    // arr[lt+1...i) == v
        while( i &lt; gt ){
            if( arr[i].compareTo(v) &lt; 0 ){
                swap( arr, i, lt+1);
                i ++;
                lt ++;
            }
            else if( arr[i].compareTo(v) &gt; 0 ){
                swap( arr, i, gt-1);
                gt --;
            }
            else{ // arr[i] == v
                i ++;
            }
        }

        swap( arr, l, lt );

        sort(arr, l, lt-1);
        sort(arr, gt, r);
    }

    public static void sort(Comparable[] arr){

        int n = arr.length;
        sort(arr, 0, n-1);
    }

    private static void swap(Object[] arr, int i, int j) {
        Object t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}
</code></pre>
<p>其他排序动图演示：</p>
<p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2019/02/02/spring/</url>
    <content><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><ul>
<li>上层建筑依赖下层</li>
</ul>
<p><img src="/2019/02/02/spring/dependency.jpg" alt="dependency"></p>
<ul>
<li>依赖注入实现控制反转：由下层决定上层，到上层控制下层</li>
</ul>
<p><img src="/2019/02/02/spring/ioc.jpg" alt="ioc"></p>
<p>大量new工作即为控制反转容器的工作（右框）</p>
<p><img src="/2019/02/02/spring/struct.jpg" alt="struct"></p>
<p><img src="/2019/02/02/spring/container.jpg" alt="container"></p>
<p>容器的优势：</p>
<ul>
<li>避免大量的new工作</li>
<li>创建实例不需要了解其中的细节</li>
</ul>
<p><img src="/2019/02/02/spring/process.jpg" alt="process"></p>
<p>对使用者隐藏了内部细节</p>
<h1 id="装配"><a href="#装配" class="headerlink" title="装配"></a>装配</h1><p>spring中，configuration定义bean后，在ApplicationContext ctx.getBean(.class)手动装配</p>
<p>springboot中采取@component实现，@Autowired</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><ul>
<li>面向切面</li>
<li>不同的问题交给不同的部分解决</li>
<li>切面是通用化代码模块</li>
<li>业户功能代码和切片代码分开后，系统高内聚低耦合</li>
<li>切面最终被整合到业务中</li>
</ul>
<p><img src="/2019/02/02/spring/aop.jpg" alt="aop"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark Final Note</title>
    <url>/2019/05/04/sparknote/</url>
    <content><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p><strong>Goal of Apache Spark</strong>：<br>To design a programming model that supports a much wider class of applications than MapReduce, while retaining the properties of MapReduce (fault tolerance, data locality, scalability).</p>
<p>Offers over 80 operators – an alternative to replace MapReduce.<br>• Spark core is written in Scala.<br>• Languages binding : Scala, Java, SQL, Python (PySpark) , R (SparkR).<br>• RDD: in-memory cache for very fast iterative queries à Up to 100x faster than MapReduce.<br>• Run on a standalone cluster, YARN, Mesos, Kubernetes (containers) </p>
<ul>
<li>Spark SQL: DataFrames-based structured and semistructured data processing, SQL language support</li>
<li>Spark Streaming: streaming analytics (Datasets)<br>– Support Kafka, Flume, Twitter, Kinesis, or TCP Sockets.</li>
<li>Spark GraphX : graph processing (e.g., PageRank)</li>
<li>Spark MLlib: machine learning</li>
</ul>
<h2 id="Cluster-Manager-Types"><a href="#Cluster-Manager-Types" class="headerlink" title="Cluster Manager Types"></a>Cluster Manager Types</h2><ul>
<li><p>Standalone cluster<br>– a simple cluster manager included with Spark that makes it easy to set up a cluster. “Without Hadoop”</p>
</li>
<li><p>YARN cluster </p>
<p>– the resource manager in Hadoop 2.X.<br>– richer resource scheduling capabilities (You learnt it already)<br>– /opt/spark/bin/spark-submit –master yarn</p>
</li>
<li><p>Mesos cluster </p>
<p>– Mesos is a scalable and fault-tolerant “distributed systems kernel” written in C++.</p>
</li>
<li><p>Kubernetes (Spark 2.3+)<br>– Kubernetes, an open-source system for automating deployment, scaling, and management of containerized applications.<br>– /opt/spark/bin/spark-submit –master k8s</p>
</li>
</ul>
<p><img src="/2019/05/04/sparknote/s1.jpg" alt="s1"></p>
<p><img src="/2019/05/04/sparknote/s1.jpg" alt="s1"></p>
<p><img src="/2019/05/04/sparknote/s2.png" alt="s2"></p>
<h2 id="Weakness-of-MapReduce"><a href="#Weakness-of-MapReduce" class="headerlink" title="Weakness of MapReduce:"></a>Weakness of MapReduce:</h2><p>– “Many problems do not lend themselves to the twostep process of map and reduce”</p>
<p>• MapReduce awkward for big data workloads:<br>– Iterative applications that need to run the same Mapper and Reducer multiple times (e.g., machine learning, graph algorithms).<br>– Interactive applications: Web applications for interactive queries (SQL), interactive data analysis (integrating with machine learning).<br>– Streaming applications: infinitive data stream, need to maintain aggregate state over time.</p>
<p><img src="/2019/05/04/sparknote/s3.jpg" alt="s3"></p>
<p>Weakness of MapReduce<br>• Support for Batch Processing only<br>• No streaming data processing to perform near realtime analysis. E.g., clickstream data analysis, real-time remote monitoring, recommendation system.<br>• Not efficient for in interactive querying of large datasets.</p>
<p><img src="/2019/05/04/sparknote/s4.jpg" alt="s4"></p>
<p><img src="/2019/05/04/sparknote/s5.jpg" alt="s5"></p>
<p><img src="/2019/05/04/sparknote/s6.jpg" alt="s6"></p>
<h1 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h1><p><img src="/2019/05/04/sparknote/s7.png" alt="s7"></p>
<p>RDD: a distributed data structure !!<br>– RDDs are divided into smaller chunks called partitions.<br>– Partitions of an RDD is distributed across all the nodes in the cluster.<br>– Two types of operations that you can perform on an RDD: Transformations and Actions<br>– RDDs are immutable (i.e., can’t be modified once created)</p>
<p>When you can modify an RDD with a transformation, the transformation returns you a new RDD whereas the original RDD remains the same.</p>
<p><strong>Transformation</strong> applies some function on an RDD and creates a new RDD, it does not modify the RDD that you apply the function on</p>
<p><strong>Action</strong> is used to either save result to some location (e.g., HDFS) or to display it via the driver program</p>
<p><img src="/2019/05/04/sparknote/s8.jpg" alt="s8"></p>
<p><img src="/2019/05/04/sparknote/s9.png" alt="s9"></p>
<p><img src="/2019/05/04/sparknote/s10.png" alt="s10"></p>
<p><img src="/2019/05/04/sparknote/s11.png" alt="s11"></p>
<h2 id="Types-of-Transformations"><a href="#Types-of-Transformations" class="headerlink" title="Types of Transformations"></a>Types of Transformations</h2><p><img src="/2019/05/04/sparknote/s12.jpg" alt="s12"></p>
<p><img src="/2019/05/04/sparknote/s13.jpg" alt="s13"></p>
<p><img src="/2019/05/04/sparknote/s14.png" alt="s14"></p>
<p><img src="/2019/05/04/sparknote/s15.png" alt="s15"></p>
<h2 id="Spark-are-lazy"><a href="#Spark-are-lazy" class="headerlink" title="Spark are lazy"></a>Spark are lazy</h2><p>“All transformations in Spark are lazy”:<br>• Spark doesn’t compute anything until it gets to the first “action” operation (e.g. reduce or collect), at which point it will recursively compute all the RDDs.</p>
<p>Advantages:<br>• More efficient: transformations get bundled together and only run on demand, gaining opportunities of optimization.</p>
<p><img src="/2019/05/04/sparknote/s16.jpg" alt="s16"></p>
<p><img src="/2019/05/04/sparknote/s17.png" alt="s17"></p>
<h2 id="RDD-Internal"><a href="#RDD-Internal" class="headerlink" title="RDD Internal"></a>RDD Internal</h2><p>Five main properties:<br>– An RDD contains list of partitions<br>– function to compute (map, flatmap, ..)<br>– list of [parent RDD, type (wide/narrow)]<br>– Optionally, a partitioning scheme (e.g.,hash-partitioned)<br>– Optionally, a computation placement hint<br>a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)</p>
<h3 id="RDD-Partitions"><a href="#RDD-Partitions" class="headerlink" title="RDD Partitions"></a>RDD Partitions</h3><p>By default, a partition is created for each HDFS block, with size = 64MB (or 128MB). Note: size changes after the transform operation.<br>• To increase the number of partitions:<br>– rdd = sc.textFile(“hdfs://… /file.txt”, 400)  Meaning split file.txt into 400 partitions.<br>• Note: compressed files are ‘non-splittable‘ Each ZIP file will be processed by a single mapper.</p>
<h3 id="RDD-In-memory-Cache"><a href="#RDD-In-memory-Cache" class="headerlink" title="RDD In-memory Cache"></a>RDD In-memory Cache</h3><p>RDD can be cached in RAM for fast access &amp; reuse<br>Key reason why Spark can achieve up to 100x faster than MapReduce</p>
<p><img src="/2019/05/04/sparknote/s18.png" alt="s18"></p>
<p>In some cases, Spark may not have sufficient memory to cache the entire RDD. Only use cache() if the evaluated RDD will be used more than once .</p>
<p><strong>Notes on RDD In-memory Cache</strong><br>• Note 1: “Cached is just a hint, not a guarantee”.<br>– If there is not enough space in memory, a partition from the least recently used (LRU) RDD is evicted.<br>• Note 2: An RDD that hasn’t been cached is not stored anywhere; once consumed, it is garbage-collected.<br>• Note 3: Cache commands indicate that Spark needs to keep these RDD’s in memory. This will not cause the RDD to be instantly be cached. Instead it will be cached the next time it is loaded into memory</p>
<p><strong>RDD Persistence: rdd.persist()</strong></p>
<p>RDDs by default is recomputed each time an action is run on them.<br>RDD Persistence:save the intermediate result, so that we can reuse it if required. It reduces the computation overhead !</p>
<p><img src="/2019/05/04/sparknote/s19.jpg" alt="s19"></p>
<p><img src="/2019/05/04/sparknote/s20.png" alt="s20"></p>
<p><img src="/2019/05/04/sparknote/s21.png" alt="s21"></p>
<p><strong>Which Storage Level to Choose?</strong><br>• If your RDDs fit comfortably with the default storage level (MEMORY_ONLY), leave them that way (most CPU-efficient)<br>• If not, try using MEMORY_ONLY_SER and selecting a fast serialization library to make the objects much more space-efficient, but still reasonably fast to access.<br>• Don’t spill to disk unless the functions that computed your datasets are expensive, or they filter a large amount of the data (easily run out of RAM). Otherwise, recomputing a partition is about as fast as reading it from disk.<br>• Use the replicated storage levels if you want fast fault recovery.<br>• All the storage levels provide full fault tolerance by re-computing lost data, but the replicated ones let you continue running tasks on the RDD without waiting to re-compute a lost partition.</p>
<h1 id="Key-elements-of-a-Spark-cluster"><a href="#Key-elements-of-a-Spark-cluster" class="headerlink" title="Key elements of a Spark cluster"></a>Key elements of a Spark cluster</h1><ul>
<li><p>Spark Driver: “the main() function of an application”<br>– creates SparkContext to schedule jobs execution and negotiate with cluster manager</p>
</li>
<li><p>Cluster Manager: manages the resources of a cluster<br>– YARN, Mesos, Spark Standalone (run in FIFO order)</p>
</li>
<li><p>Workers (slave nodes)<br>– Any node that can run application code in the cluster</p>
</li>
<li><p>Executors<br>– A process launched on a worker node, running tasks scheduled by driver. Each executor is a JVM instance. You can have multiple executors in a single node</p>
</li>
<li><p>Deployment mode: cluster mode (driver runs on worker hosts) and client mode (driver is out of the cluster) .</p>
</li>
</ul>
<h2 id="Spark-Execution"><a href="#Spark-Execution" class="headerlink" title="Spark Execution"></a>Spark Execution</h2><p><img src="/2019/05/04/sparknote/s22.png" alt="s22"></p>
<p><img src="/2019/05/04/sparknote/s23.jpg" alt="s23"></p>
<p><img src="/2019/05/04/sparknote/s24.jpg" alt="s24"></p>
<p><img src="/2019/05/04/sparknote/s25.png" alt="s25"></p>
<p><img src="/2019/05/04/sparknote/s26.jpg" alt="s26"></p>
<p>Note: Spark hosts multiple tasks within the same container for lower overhead of JVM.<br>– In Spark, tasks are just threads in the same JVM.<br>– If you set spark.executor.cores &gt; 1, your executor will have multiple parallel threads<br>– Different from MapReduce which schedules a container (i.e., starts a JVM) for EACH map/reduce task High overhead as JVM has to startup and initialize certain data structures before it can begin running tasks.</p>
<p><img src="/2019/05/04/sparknote/s27.jpg" alt="s27"></p>
<p><img src="/2019/05/04/sparknote/s28.png" alt="s28"></p>
<h2 id="Spark-Memory-Management"><a href="#Spark-Memory-Management" class="headerlink" title="Spark Memory Management"></a>Spark Memory Management</h2><p><img src="/2019/05/04/sparknote/s29.jpg" alt="s29"></p>
<p>spark.executor.memory (Default: 1g) impacts the amount of data Spark can cache, as well as the maximum sizes of the shuffle data structures used for grouping, aggregations, and joins!</p>
<p><img src="/2019/05/04/sparknote/s30.jpg" alt="s30"></p>
<p><img src="/2019/05/04/sparknote/s31.jpg" alt="s31"></p>
<h2 id="Spark-Driver-amp-Spark-Context"><a href="#Spark-Driver-amp-Spark-Context" class="headerlink" title="Spark Driver &amp; Spark Context"></a>Spark Driver &amp; Spark Context</h2><p>• Spark Driver: Major Components<br>• Spark Context<br>– SparkContext object tells Spark how to access a cluster<br>• DAG Scheduler<br>– Computes a DAG of stages for each job and submits them to TaskScheduler + Determines preferred locations for tasks<br>• Task Scheduler<br>– sending tasks to the cluster, running them, retrying if there are failures, and mitigating stragglers<br>• Scheduler Backend<br>– allows plugging in YARN, Mesos, Standalone, ..<br>• Block Manager @ Executor<br>– provides interfaces for putting and retrieving blocks both locally and remotely into various stores (memory, disk, and off-heap)</p>
<p><img src="/2019/05/04/sparknote/s32.jpg" alt="s32"></p>
<p><img src="/2019/05/04/sparknote/s33.jpg" alt="s33"></p>
<p><img src="/2019/05/04/sparknote/s34.png" alt="s34"></p>
<p><img src="/2019/05/04/sparknote/s35.jpg" alt="s35"></p>
<p><strong>DAG Scheduler does three things:</strong></p>
<p>– (1) Computes an execution DAG for a job.<br>• keeps track of which RDDs and stage outputs are materialized, and finds a minimal schedule to run jobs</p>
<p>– (2) Determines the preferred locations to run each task on based on the current cache status.<br>• DAGScheduler tracks which RDDs are cached (or persisted) to avoid “recomputing” them</p>
<p>– (3) Handles failures due to shuffle output files being lost (old stages may need to be resubmitted).<br>• DAGScheduler need to track what ShuffleMapStages have already produced output files.</p>
<p><img src="/2019/05/04/sparknote/s36.jpg" alt="s36"></p>
<p><img src="/2019/05/04/sparknote/s37.jpg" alt="s37"></p>
<h1 id="Spark-Execution-Flow"><a href="#Spark-Execution-Flow" class="headerlink" title="Spark Execution Flow"></a>Spark Execution Flow</h1><p><img src="/2019/05/04/sparknote/C:/Rex\document\study\note\exam\spark\s38.jpg" alt="s38"></p>
<p><img src="/2019/05/04/sparknote/s39.jpg" alt="s39"></p>
<p><img src="/2019/05/04/sparknote/s40.jpg" alt="s40"></p>
<p><img src="/2019/05/04/sparknote/s41.png" alt="s41"></p>
<p>Re-compute only the lost partitions of an RDD.<br>– Narrow dependency: only depends on a few partitions that need to be recomputed.<br>– Wide dependency: might require to recompute an entire RDD</p>
<p>Checkpoint write data to storage (HDFS) so that the task can be recovered.<br>– We can specify where the data is saved to (on HDFS)<br>• E.g., sc.setCheckpointDir(“/tmp/spark/checkpoint”)<br>– RDD should be cached before checkpoint, so that data will be saved in memory while saving to storage</p>
<p>What kind of RDD needs checkpoint ?<br>– the computation takes a long time<br>– the computing chain is too long<br>– depends too many RDDs<br>– (Actually, saving the output of ShuffleMapTask on local disk is also checkpoint, but it is just for data output of partition.)<br>– do a rdd.cache() before rdd.checkpoint()</p>
<p><img src="/2019/05/04/sparknote/s42.jpg" alt="s42"></p>
<p><img src="/2019/05/04/sparknote/s43.png" alt="s43"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Yarn</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Springcloud Basic</title>
    <url>/2019/05/25/springcloud/</url>
    <content><![CDATA[<h1 id="架构演变"><a href="#架构演变" class="headerlink" title="架构演变"></a>架构演变</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><img src="/2019/05/25/springcloud/single.jpg" alt="single"></p>
<ul>
<li>容易测试，没有外部依赖</li>
<li>容易运行</li>
<li>开发效率低</li>
<li>维护困难</li>
<li>部署不灵活，整体部署</li>
<li>稳定性不高</li>
<li>拓展性不够</li>
</ul>
<h2 id="基于Ajax前后端分离"><a href="#基于Ajax前后端分离" class="headerlink" title="基于Ajax前后端分离"></a>基于Ajax前后端分离</h2><p><img src="/2019/05/25/springcloud/ajax.jpg" alt="ajax"></p>
<p><img src="/2019/05/25/springcloud/ajax2.jpg" alt="ajax2"></p>
<h2 id="分布式系统与集群"><a href="#分布式系统与集群" class="headerlink" title="分布式系统与集群"></a>分布式系统与集群</h2><ul>
<li>分布式：不同工种</li>
<li>集群：同一工种</li>
</ul>
<h2 id="简单的微服务架构"><a href="#简单的微服务架构" class="headerlink" title="简单的微服务架构"></a>简单的微服务架构</h2><p><img src="/2019/05/25/springcloud/micro.jpg" alt="micro"></p>
<h1 id="微服务的架构和组件"><a href="#微服务的架构和组件" class="headerlink" title="微服务的架构和组件"></a>微服务的架构和组件</h1><h2 id="服务注册发现"><a href="#服务注册发现" class="headerlink" title="服务注册发现"></a>服务注册发现</h2><ul>
<li>服务提供方的注册</li>
<li>服务调用方的发现</li>
</ul>
<h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><ul>
<li>将服务暴露给外部</li>
<li>屏蔽后台服务细节</li>
<li>路由功能</li>
<li>限流、容错</li>
</ul>
<h2 id="后端通用服务（中间层服务）"><a href="#后端通用服务（中间层服务）" class="headerlink" title="后端通用服务（中间层服务）"></a>后端通用服务（中间层服务）</h2><h2 id="前端服务（边缘服务）"><a href="#前端服务（边缘服务）" class="headerlink" title="前端服务（边缘服务）"></a>前端服务（边缘服务）</h2><ul>
<li>将后端服务聚合裁剪，从而暴露给外部</li>
<li>聚合：多个API聚合为一个</li>
<li>裁剪：将信息减少返回</li>
</ul>
<h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><ul>
<li><p>Eureka Server</p>
<p>注册中心</p>
</li>
<li><p>Eureka Client</p>
<p>服务注册</p>
</li>
</ul>
<p>心跳检测、健康检查、负载均衡</p>
<h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><p>记录应用的信息和状态</p>
<p>建立Eureka项目并配置</p>
<p>注意@EnableEurekaServer</p>
<pre><code class="yml">eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
    register-with-eureka: false
  server:
    enable-self-preservation: false
spring:
  application:
    name: eureka
server:
  port: 8761
</code></pre>
<p><img src="/2019/05/25/springcloud/eureka.jpg" alt="eureka"></p>
<p>使用maven后台启动</p>
<p>mvn clean package</p>
<p>java -jar </p>
<h2 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h2><p>注意@EnableDiscoveryClient</p>
<p>配置</p>
<pre><code class="yml">eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
#   instance:
#     hostname: clientName
spring:
  application:
    name: client
</code></pre>
<p>hostname可以diy此处的链接</p>
<p><img src="/2019/05/25/springcloud/diyurl.jpg" alt="diyurl"></p>
<h2 id="Eureka高可用"><a href="#Eureka高可用" class="headerlink" title="Eureka高可用"></a>Eureka高可用</h2><p>使两个Eureka互相注册</p>
<p><img src="/2019/05/25/springcloud/eu2.jpg" alt="eu2"></p>
<p>同时启动两个eureka在两个端口</p>
<p><img src="/2019/05/25/springcloud/eu3.jpg" alt="eu3"></p>
<p>使这两个交叉相互注册</p>
<p>两个eureka信息同步（client只需要注册一个）</p>
<p>为保险起见，应该在client中配置多个eureka注册</p>
<p><img src="/2019/05/25/springcloud/eu4.jpg" alt="eu4"></p>
<pre><code class="yml">eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/,http://localhost:8761/eureka/
#    instance:
#      hostname: clientName
spring:
  application:
    name: client
</code></pre>
<p>结构：eureka两两注册，client注册所有eureka</p>
<p><img src="/2019/05/25/springcloud/eu5.jpg" alt="eu5"></p>
<h2 id="分布式系统中服务发现的作用"><a href="#分布式系统中服务发现的作用" class="headerlink" title="分布式系统中服务发现的作用"></a>分布式系统中服务发现的作用</h2><p>避免了动态配置和配置过多问题</p>
<p>注册中心是分布式系统中最重要的部分</p>
<p><img src="/2019/05/25/springcloud/eu6.jpg" alt="eu6"></p>
<ul>
<li><p>客户端发现</p>
<p>A来挑选B从而完成服务或者负载均衡</p>
<p>客户可以知道所有可用的服务地址</p>
<p>Eureka</p>
</li>
<li><p>服务端发现</p>
<p>代理替代A来挑选B，完成服务与负载均衡</p>
<p>使得服务对A不可见</p>
<p>Nginx</p>
<p>Zookeeper</p>
<p>K8S</p>
</li>
</ul>
<p>微服务支持异构（不同语言、数据库），通过轻通讯（http&amp;RPC）</p>
<h1 id="服务的拆分"><a href="#服务的拆分" class="headerlink" title="服务的拆分"></a>服务的拆分</h1><h2 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h2><p>交付结构与沟通结构一致</p>
<h2 id="扩展立方模型"><a href="#扩展立方模型" class="headerlink" title="扩展立方模型"></a>扩展立方模型</h2><p><img src="/2019/05/25/springcloud/fu1.jpg" alt="fu1"></p>
<ul>
<li><p>拆功能</p>
<p>单一职责（松耦合，高内聚）</p>
<p>关注点分离：按职责、通用性、粒度级别</p>
</li>
<li><p>服务与数据</p>
<p>优先考虑业务服务，再考虑数据</p>
<p>无状态服务</p>
</li>
</ul>
<h1 id="应用间通信"><a href="#应用间通信" class="headerlink" title="应用间通信"></a>应用间通信</h1><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul>
<li>Dubbo</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li><p>Springcloud</p>
<p>1、RestTemplate</p>
<p>2、Feign</p>
</li>
</ul>
<p>RestTemplate三种方式</p>
<p><img src="/2019/05/25/springcloud/tran.jpg" alt="tran"></p>
<p>第三种，使用注解</p>
<p><img src="/2019/05/25/springcloud/tran1.jpg" alt="tran1"></p>
<p><img src="/2019/05/25/springcloud/tran2.jpg" alt="tran2"></p>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>客户端负载均衡器@LoadBalanced注解</p>
<ul>
<li>服务发现</li>
<li>服务选择规则</li>
<li>服务监听</li>
</ul>
<p>主要组件：ServerList、IRule、ServerListFilter</p>
<p>默认轮询规则，可以在yml文件中设置具体规则</p>
<pre><code class="yml">serviceName: 
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
</code></pre>
<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>声明式Rest客户端（伪RPC）本质是个http客户端</p>
<p>接口+注解方式</p>
<ul>
<li><p>加入Feign组件</p>
</li>
<li><p>@EnableFeignClients</p>
</li>
<li><p>创建接口</p>
</li>
</ul>
<p>调用远程服务</p>
<p><img src="/2019/05/25/springcloud/tran3.jpg" alt="tran3"></p>
<p>service端</p>
<p><img src="/2019/05/25/springcloud/tran4.jpg" alt="tran4"></p>
<h2 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h2><p>逐步将必要的同步过程改为异步（后面详解）</p>
<p>安装rabbitmq</p>
<blockquote>
<p>docker run -d –hostname my-rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management</p>
</blockquote>
<h1 id="统一配置中心"><a href="#统一配置中心" class="headerlink" title="统一配置中心"></a>统一配置中心</h1><p>普通配置不方便维护、存在安全隐患、需要重启等问题</p>
<h2 id="Config-Server"><a href="#Config-Server" class="headerlink" title="Config Server"></a>Config Server</h2><p><img src="/2019/05/25/springcloud/conf1.jpg" alt="conf1"></p>
<p>将参数放在远程git上并配置</p>
<p><img src="/2019/05/25/springcloud/conf3.jpg" alt="conf3"></p>
<p><img src="/2019/05/25/springcloud/conf5.jpg" alt="conf5"></p>
<p>basedir配置本地路径</p>
<p>路由规则：</p>
<p><img src="/2019/05/25/springcloud/conf2.jpg" alt="conf2"></p>
<h2 id="Config-Client"><a href="#Config-Client" class="headerlink" title="Config Client"></a>Config Client</h2><p>创建bootstrap.yml配置文件</p>
<p><img src="/2019/05/25/springcloud/conf4.jpg" alt="conf4"></p>
<p>拿到相应配置</p>
<p><img src="/2019/05/25/springcloud/conf6.jpg" alt="conf6"></p>
<p>加载config-test.yml时，也会同时加载config.yml（如果存在），并合并两份配置，所以可以把通用配置存于config.yml</p>
<h2 id="配置中心的高可用"><a href="#配置中心的高可用" class="headerlink" title="配置中心的高可用"></a>配置中心的高可用</h2><p>多起几个配置中心，配置中心本身就是一个微服务</p>
<p><img src="/2019/05/25/springcloud/conf7.jpg" alt="conf7"></p>
<h2 id="自动刷新配置"><a href="#自动刷新配置" class="headerlink" title="自动刷新配置"></a>自动刷新配置</h2><p><img src="/2019/05/25/springcloud/conf8.jpg" alt="conf8"></p>
<p>引入依赖</p>
<pre><code class="xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
            &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><img src="/2019/05/25/springcloud/conf9.jpg" alt="conf9"></p>
<p>使config server和client连通mq</p>
<p><img src="/2019/05/25/springcloud/conf10.jpg" alt="conf10"></p>
<p>需要在config server中暴露接口</p>
<pre><code class="yml">management: 
  endpoints: 
    web:
      expose: &quot;*&quot;
</code></pre>
<p><img src="/2019/05/25/springcloud/conf11.jpg" alt="conf11"></p>
<p>更改controller注解，刷新配置</p>
<p>做到git实时刷新</p>
<p><img src="/2019/05/25/springcloud/conf12.jpg" alt="conf12"></p>
<p>设置git WebHooks</p>
<p><img src="/2019/05/25/springcloud/conf13.jpg" alt="conf13"></p>
<h1 id="消息与异步"><a href="#消息与异步" class="headerlink" title="消息与异步"></a>消息与异步</h1><ul>
<li><p>异步</p>
<p>客户端请求不会阻塞进程</p>
<p>服务端的响应是非及时的</p>
</li>
</ul>
<p>异步的常见形式：通知、请求/异步响应、消息</p>
<p>MQ常解决的问题：异步处理、流量削峰、日志处理（Kafka）、应用解耦</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><pre><code class="yml">spring:
  application:
    name: config
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
</code></pre>
<p>接受MQ消息</p>
<p><img src="/2019/05/25/springcloud/conf14.jpg" alt="conf14"></p>
<p>发送MQ，test</p>
<p><img src="/2019/05/25/springcloud/conf15.jpg" alt="conf15"></p>
<p>绑定queue和exchange</p>
<p><img src="/2019/05/25/springcloud/conf16.jpg" alt="conf16"></p>
<p>根据routing key转发到不同终端</p>
<h2 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h2><p>对消息中间件进一步封装、做到中间件不可见（只适用rabbitmq、Kafka）</p>
<p><img src="/2019/05/25/springcloud/conf17.jpg" alt="conf17"></p>
<pre><code class="xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>定义接口</p>
<p><img src="/2019/05/25/springcloud/conf18.jpg" alt="conf18"></p>
<p>实现接收端</p>
<p><img src="/2019/05/25/springcloud/conf19.jpg" alt="conf19"></p>
<p>定义发送端</p>
<p><img src="/2019/05/25/springcloud/conf20.jpg" alt="conf20"></p>
<p>多实例发送消息到mq，会多次接受，因而需要使用分组</p>
<pre><code class="yml">spring:
  cloud:
    stream: 
      bindings:
        myMessage:
          group: groupname
</code></pre>
<p>同组队列将合并</p>
<p>在MQ面板，反序列化对象为json方便查看</p>
<pre><code class="yml">spring:
  cloud:
    stream: 
      bindings:
        myMessage:
          group: groupname
          content-type: application/json
</code></pre>
<p>接受消息后再返回信息</p>
<p><img src="/2019/05/25/springcloud/conf21.jpg" alt="conf21"></p>
<h1 id="服务网关与Zuul"><a href="#服务网关与Zuul" class="headerlink" title="服务网关与Zuul"></a>服务网关与Zuul</h1><p>网关同一入口</p>
<p><img src="/2019/05/25/springcloud/zuul1.jpg" alt="zuul1"></p>
<ul>
<li>稳定性、高可用</li>
<li>安全性</li>
<li>性能、并发性</li>
<li>扩展性</li>
</ul>
<p>常见的网关方案</p>
<ul>
<li>Nginx + Lua</li>
<li>Kong</li>
<li>Tyk</li>
<li>Spring Cloud Zuul</li>
</ul>
<p>Zuul特点</p>
<p>Zuul=路由+过滤器</p>
<p>四种过滤器API</p>
<ul>
<li>前置（Pre）</li>
<li>后置（Post）</li>
<li>路由（Route）</li>
<li>错误（Error）</li>
</ul>
<p><img src="/2019/05/25/springcloud/zuul2.jpg" alt="zuul2"></p>
<p><img src="/2019/05/25/springcloud/zuul3.jpg" alt="zuul3"></p>
<h2 id="Zuul的使用"><a href="#Zuul的使用" class="headerlink" title="Zuul的使用"></a>Zuul的使用</h2><p>1、导入依赖</p>
<p>2、添加enable注释@EnableZuulProxy</p>
<p>3、修改配置文件</p>
<p>通过路由得到对应服务</p>
<p>localhost:9000/service-name/list</p>
<p>添加规则路由</p>
<p><img src="/2019/05/25/springcloud/zuul.jpg" alt="zuul"></p>
<p>修改安全策略，查看路由详情</p>
<p><img src="/2019/05/25/springcloud/zuul4.jpg" alt="zuul4"></p>
<p><img src="/2019/05/25/springcloud/zuul5.jpg" alt="zuul5"></p>
<p>或者简洁写法</p>
<p><img src="/2019/05/25/springcloud/zuul6.jpg" alt="zuul6"></p>
<p>可以添加忽视路由</p>
<pre><code class="yml">ignored-patterns:
  - /**/ignore/list
</code></pre>
<p>zuul会默认过滤cookie，加入敏感头过滤，设置为空</p>
<pre><code class="yml">zuul:
  routes: 
    myProduct:
      sensitiveHeaders:
</code></pre>
<h2 id="动态配置路由"><a href="#动态配置路由" class="headerlink" title="动态配置路由"></a>动态配置路由</h2><p><img src="/2019/05/25/springcloud/zuul7.jpg" alt="zuul7"></p>
<p>在github webhook激活动态配置</p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>部署多台Zuul避免单点故障</p>
<p>直接作为微服务注册在Eureka Server上</p>
<p>与Nginx混搭</p>
<h2 id="Pre-amp-Post过滤器"><a href="#Pre-amp-Post过滤器" class="headerlink" title="Pre&amp;Post过滤器"></a>Pre&amp;Post过滤器</h2><p>Zuul在各个Service之前进行统一校验，避免多服务重复校验</p>
<p><img src="/2019/05/25/springcloud/zuul8.png" alt="zuul8"></p>
<ul>
<li><p>prefilter</p>
<p>设置必须包含token认证</p>
</li>
</ul>
<pre><code class="java">@Component
public class TokenFilter extends ZuulFilter {
    @Override
    public String filterType() {
        return PRE_TYPE;
    }

    @Override
    public int filterOrder() {
        return PRE_DECORATION_FILTER_ORDER - 1;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() throws ZuulException {
        RequestContext requestContext = RequestContext.getCurrentContext();
        HttpServletRequest request = requestContext.getRequest();

        String token = request.getParameter(&quot;token&quot;);
        if(StringUtils.isEmpty(token)){
            requestContext.setSendZuulResponse(false);
            requestContext.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);
        }
        return null;
    }
}
</code></pre>
<p>请求生命周期</p>
<p><img src="/2019/05/25/springcloud/zuul9.jpg" alt="zuul9"></p>
<p>pre-&gt;routing-&gt;post</p>
<ul>
<li>postfilter</li>
</ul>
<pre><code class="java">@Component
public class AddResponseHeaderFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return POST_TYPE;
    }

    @Override
    public int filterOrder() {
        return SEND_RESPONSE_FILTER_ORDER - 1;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        RequestContext requestContext = new RequestContext();
        HttpServletResponse response = requestContext.getResponse();
        response.setHeader(&quot;X=Foo&quot;, UUID.randomUUID().toString());
        return null;
    }
}
</code></pre>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>请求被转发前调用</p>
<p>令牌桶算法</p>
<p><img src="/2019/05/25/springcloud/zuul10.jpg" alt="zuul10"></p>
<pre><code class="java">@Component
public class RateFilter extends ZuulFilter {
    // 100 allowed per second
    private static final RateLimiter RATE_LIMITER = RateLimiter.create(100);


    @Override
    public String filterType() {
        return PRE_TYPE;
    }

    @Override
    public int filterOrder() {
        return SERVLET_DETECTION_FILTER_ORDER - 1;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        // check if it has allowed
        if (!RATE_LIMITER.tryAcquire()){
            throw new RateLimitException();
        }
        return null;
    }
}
</code></pre>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul>
<li>在被调用的类或方法上增加@CrossOrigin注解</li>
<li>在Zuul里增加CorsFilter过滤器</li>
</ul>
<p><img src="/2019/05/25/springcloud/zuul12.jpg" alt="zuul12"></p>
<h1 id="服务容错与Hystrix"><a href="#服务容错与Hystrix" class="headerlink" title="服务容错与Hystrix"></a>服务容错与Hystrix</h1><h2 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h2><p>由于调用失败重复重试、导致整个系统不可用</p>
<p><img src="/2019/05/25/springcloud/zuul13.jpg" alt="zuul13"></p>
<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>优先核心服务、非核心服务不可用或弱可用</p>
<p>通过HystrixCommand注解指定</p>
<p>fallbackMethod函数中（回退函数）具体实现降级逻辑</p>
<p>引入依赖</p>
<p><img src="/2019/05/25/springcloud/zuul14.jpg" alt="zuul14"></p>
<p>添加注解@EnableCircuitBreaker</p>
<p><img src="/2019/05/25/springcloud/zuul15.jpg" alt="zuul15"></p>
<p>服务出错后执行回滚函数，如果出现异常，同样回滚，因而可以自己定制回滚情况</p>
<p><img src="/2019/05/25/springcloud/zuul16.jpg" alt="zuul16"></p>
<p>从而实现统一降级</p>
<p>如果访问时间过长会自动触发降级，因而可以配置超时时间</p>
<p><img src="/2019/05/25/springcloud/zuul17.jpg" alt="zuul17"></p>
<pre><code class="java">@HystrixCommand(commandProperties = {
            @HystrixProperty(name = &quot;default_executionTimeoutInMilliseconds&quot;,value = &quot;3000&quot;)
    })
</code></pre>
<p>或者写在yml配置文件中</p>
<p><img src="/2019/05/25/springcloud/zuul20.jpg" alt="zuul20"></p>
<h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p><img src="/2019/05/25/springcloud/zuul18.jpg" alt="zuul18"></p>
<p><img src="/2019/05/25/springcloud/zuul19.jpg" alt="zuul19"></p>
<p>时间窗口、最小请求数、断路阈值百分比</p>
<p>Feign与Hystrix结合</p>
<p>Feign中集成了Hystrix，需要配置可用</p>
<pre><code class="yml">feign:
  hystrix: 
    enabled: true
</code></pre>
<p><img src="/2019/05/25/springcloud/zuul21.jpg" alt="zuul21"></p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>@EnableHystrixDashboard</p>
<p>引入依赖</p>
<p><img src="/2019/05/25/springcloud/zuul22.jpg" alt="zuul22"></p>
<p><img src="/2019/05/25/springcloud/zuul23.jpg" alt="zuul23"></p>
<pre><code class="yml">management:
  context-path: /
</code></pre>
<p><img src="/2019/05/25/springcloud/zuul24.jpg" alt="zuul24"></p>
<h1 id="服务追踪"><a href="#服务追踪" class="headerlink" title="服务追踪"></a>服务追踪</h1><h2 id="Sleuth链路监控"><a href="#Sleuth链路监控" class="headerlink" title="Sleuth链路监控"></a>Sleuth链路监控</h2><p>引入依赖</p>
<p><img src="/2019/05/25/springcloud/sl1.jpg" alt="sl1"></p>
<p>配置日志级别</p>
<pre><code class="yml">logging:
  level:
    org.springframework.cloud.netflix.feign: debug
</code></pre>
<p>执行后，查看日志</p>
<p><img src="/2019/05/25/springcloud/sl2.jpg" alt="sl2"></p>
<h2 id="opentrace标准"><a href="#opentrace标准" class="headerlink" title="opentrace标准"></a>opentrace标准</h2><p>划分为四种事件类型</p>
<p><img src="/2019/05/25/springcloud/sl3.jpg" alt="sl3"></p>
<h2 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h2><p><img src="/2019/05/25/springcloud/sl4.jpg" alt="sl4"></p>
<p><img src="/2019/05/25/springcloud/sl5.jpg" alt="sl5"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Synchronized</title>
    <url>/2019/02/25/synchronized/</url>
    <content><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><ul>
<li>存在共享数据</li>
<li>存在多条线程共同操作这些共享数据</li>
</ul>
<p><strong>同一时刻必须只有一个线程操作共享数据，其他线程必须等其处理完之后，再进行操作</strong></p>
<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><ul>
<li>互斥性：同一时间只能有一个线程持有某个对象锁，从而实现多线程协调，从而同一时间只有一个线程对需要同步的代码块进行访问。</li>
<li>可见性：获得锁时获得<strong>最新</strong>共享变量的值</li>
</ul>
<h2 id="对象锁与类锁"><a href="#对象锁与类锁" class="headerlink" title="对象锁与类锁"></a>对象锁与类锁</h2><ul>
<li><p>获取对象锁的两种用法</p>
<p>1、同步代码块：synchronized(this)</p>
<p>2、同步非静态方法：synchronized method</p>
</li>
<li><p>获取类锁的两种方法</p>
<p>1、同步代码块：synchronized(.class)</p>
<p>2、同步静态方法：synchronized static method</p>
</li>
</ul>
<pre><code class="java">package com.interview.javabasic.thread;

import java.text.SimpleDateFormat;
import java.util.Date;

public class SyncThread implements Runnable {

    @Override
    public void run() {
        String threadName = Thread.currentThread().getName();
        if (threadName.startsWith(&quot;A&quot;)) {
            async();
        } else if (threadName.startsWith(&quot;B&quot;)) {
            syncObjectBlock1();
        } else if (threadName.startsWith(&quot;C&quot;)) {
            syncObjectMethod1();
        } else if (threadName.startsWith(&quot;D&quot;)) {
            syncClassBlock1();
        } else if (threadName.startsWith(&quot;E&quot;)) {
            syncClassMethod1();
        }

    }

    /**
     * 异步方法
     */
    private void async() {
        try {
            System.out.println(Thread.currentThread().getName() + &quot;_Async_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot;_Async_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * 方法中有 synchronized(this|object) {} 同步代码块
     */
    private void syncObjectBlock1() {
        System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectBlock1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
        synchronized (this) {
            try {
                System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectBlock1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectBlock1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * synchronized 修饰非静态方法
     */
    private synchronized void syncObjectMethod1() {
        System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectMethod1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
        try {
            System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectMethod1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot;_SyncObjectMethod1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void syncClassBlock1() {
        System.out.println(Thread.currentThread().getName() + &quot;_SyncClassBlock1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
        synchronized (SyncThread.class) {
            try {
                System.out.println(Thread.currentThread().getName() + &quot;_SyncClassBlock1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName() + &quot;_SyncClassBlock1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private synchronized static void syncClassMethod1() {
        System.out.println(Thread.currentThread().getName() + &quot;_SyncClassMethod1: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
        try {
            System.out.println(Thread.currentThread().getName() + &quot;_SyncClassMethod1_Start: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot;_SyncClassMethod1_End: &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code class="java">package com.interview.javabasic.thread;

public class SyncDemo {
    public static void main(String... args) {
        SyncThread syncThread = new SyncThread();
        Thread A_thread1 = new Thread(syncThread, &quot;A_thread1&quot;);
        Thread A_thread2 = new Thread(syncThread, &quot;A_thread2&quot;);
        Thread B_thread1 = new Thread(syncThread, &quot;B_thread1&quot;);
        Thread B_thread2 = new Thread(syncThread, &quot;B_thread2&quot;);
        Thread C_thread1 = new Thread(syncThread, &quot;C_thread1&quot;);
        Thread C_thread2 = new Thread(syncThread, &quot;C_thread2&quot;);
        Thread D_thread1 = new Thread(syncThread, &quot;D_thread1&quot;);
        Thread D_thread2 = new Thread(syncThread, &quot;D_thread2&quot;);
        Thread E_thread1 = new Thread(syncThread, &quot;E_thread1&quot;);
        Thread E_thread2 = new Thread(syncThread, &quot;E_thread2&quot;);
        A_thread1.start();
        A_thread2.start();
        B_thread1.start();
        B_thread2.start();
        C_thread1.start();
        C_thread2.start();
        D_thread1.start();
        D_thread2.start();
        E_thread1.start();
        E_thread2.start();
    }
}
</code></pre>
<p><img src="/2019/02/25/synchronized/lock1.jpg" alt="lock1"></p>
<p><img src="/2019/02/25/synchronized/lock2.jpg" alt="lock2"></p>
<p>如果改为Thread A_thread1 = new Thread(new syncThread, “A_thread1”);</p>
<p>将全部异步。</p>
<p><img src="/2019/02/25/synchronized/sum.jpg" alt="sum"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Visualization Final Note</title>
    <url>/2019/05/03/visual/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The communication of information using graphical representation.</p>
<h2 id="Why-Visualization-is-Important"><a href="#Why-Visualization-is-Important" class="headerlink" title="Why Visualization is Important?"></a>Why Visualization is Important?</h2><p>• provides an ability to comprehend huge amounts of data<br>• allows the perception of emergent properties that were not anticipated (new insight)<br>• often reveals problems with the data itself quickly (anomalies)<br>• facilitates understanding of both large-scale and small-scale features of the data<br>• facilitates hypothesis formation</p>
<h2 id="What-Should-a-Good-Visualization-Achieve"><a href="#What-Should-a-Good-Visualization-Achieve" class="headerlink" title="What Should a Good Visualization Achieve?"></a>What Should a Good Visualization Achieve?</h2><p>• Show the data<br>• Induce the viewer to focus on the substance rather than the methodology, graphic design, the technology of graphic production, etc.<br>• Avoid distorting the data<br>• Present many numbers in a small space<br>• Encourage the eye to compare different pieces of data<br>• Reveal the data at several levels of detail, from a broad overview to the fine structure<br>• Serve a reasonably clear purpose: description, exploration, tabulation, or decoration</p>
<ul>
<li><p>Computer graphics </p>
<p>– Digital synthesis and manipulation of visual contents (geometry/imaging/rendering/animation) </p>
<p>– Visual realism is one of the primary goals – Big impact in animation/movies/video game</p>
</li>
<li><p>Visualization </p>
<p>– Applies computer graphics techniques to generate visual display of data </p>
<p>– Emphasizes on effective communication of information</p>
</li>
</ul>
<h1 id="Perception-amp-Color"><a href="#Perception-amp-Color" class="headerlink" title="Perception &amp; Color"></a>Perception &amp; Color</h1><h2 id="Perception"><a href="#Perception" class="headerlink" title="Perception"></a>Perception</h2><p>Perception is the process by which we interpret the world around us, forming a mental representation of the environment.<br>• Processing of our sensory information<br>– Recognizing (being aware of)<br>– Organizing (gathering and storing)<br>– Interpreting (binding to knowledge)</p>
<h3 id="Preattentive-Processing"><a href="#Preattentive-Processing" class="headerlink" title="Preattentive Processing"></a>Preattentive Processing</h3><p>The automatic mechanisms that operate prior to the action of attention<br>• Uncontrolled perception<br>• The fast ability to detect features, usually at a rate faster than 10 msec per item<br>• Time taken to find the target is independent of the number of distracting nontargets<br>• Allows detecting features in parallel</p>
<p><img src="/2019/05/03/visual/pre.jpg" alt="pre"></p>
<p><img src="/2019/05/03/visual/pre2.jpg" alt="pre2"></p>
<p><img src="/2019/05/03/visual/pre3.jpg" alt="pre3"></p>
<h3 id="Effective-Use-of-Conjunctions"><a href="#Effective-Use-of-Conjunctions" class="headerlink" title="Effective Use of Conjunctions"></a>Effective Use of Conjunctions</h3><p><img src="/2019/05/03/visual/conjunction.jpg" alt="conjunction"></p>
<p><img src="/2019/05/03/visual/reverse.jpg" alt="reverse"></p>
<h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><p>Primary Colors<br>• Red, Green, Blue<br>– liquid crystal, CRT displays<br>• Red, Yellow, Blue<br>– paint<br>• Cyan, Magenta, Yellow<br>– color printing<br>• Orange, Green, Violet<br>– color photography</p>
<p>Cones<br>– active at normal light levels<br>– color vision involves cone only<br>Rods<br>– sensitive at low light levels<br>– not sensitive to color<br>– responsible for our dark-adapted vision<br>– low influence on color perception</p>
<p>There is an uneven distribution of cones and rods in the retina</p>
<p><img src="/2019/05/03/visual/cone.jpg" alt="cone"></p>
<h2 id="Lightness-Scales"><a href="#Lightness-Scales" class="headerlink" title="Lightness Scales"></a>Lightness Scales</h2><ul>
<li><p>Lightness / Brightness </p>
<p>– (qualitative) perceived reflectance of a surface</p>
</li>
<li><p>Luminance </p>
<p>– (quantitative) measured amount of light energy weighted by the spectral sensitivity function of the human eye</p>
</li>
</ul>
<p><img src="/2019/05/03/visual/light.jpg" alt="light"></p>
<h2 id="Temporal-Geospatial-amp-Multivariate-Data"><a href="#Temporal-Geospatial-amp-Multivariate-Data" class="headerlink" title="Temporal, Geospatial &amp; Multivariate Data"></a>Temporal, Geospatial &amp; Multivariate Data</h2><h2 id="Some-Basic-Plots"><a href="#Some-Basic-Plots" class="headerlink" title="Some Basic Plots"></a>Some Basic Plots</h2><h3 id="Bar-Charts-Histograms"><a href="#Bar-Charts-Histograms" class="headerlink" title="Bar Charts / Histograms"></a>Bar Charts / Histograms</h3><p>To show distribution of values of a single variable<br>• Values are divided into bins<br>• A bar plot is used so that the height of each bar indicates the number of objects in each bin<br>• Shape of histogram depends on the number of bins</p>
<p><img src="/2019/05/03/visual/bin.jpg" alt="bin"></p>
<h3 id="Box-Plots"><a href="#Box-Plots" class="headerlink" title="Box Plots"></a>Box Plots</h3><p>To show quantitative distribution of 1D data</p>
<p><img src="/2019/05/03/visual/box.jpg" alt="box"></p>
<p><img src="/2019/05/03/visual/box1.jpg" alt="box1"></p>
<h3 id="2D-Bar-Charts"><a href="#2D-Bar-Charts" class="headerlink" title="2D Bar Charts"></a>2D Bar Charts</h3><p>To show the joint distribution of the values of two variables</p>
<p>3D effect not good in showing the exact values, but the correlation can be seen clearly</p>
<p><img src="/2019/05/03/visual/2d.jpg" alt="2d"></p>
<h3 id="Line-Graphs"><a href="#Line-Graphs" class="headerlink" title="Line Graphs"></a>Line Graphs</h3><p><img src="/2019/05/03/visual/line.jpg" alt="line"></p>
<h3 id="Scatter-Plots"><a href="#Scatter-Plots" class="headerlink" title="Scatter Plots"></a>Scatter Plots</h3><p><img src="/2019/05/03/visual/scater.png" alt="scater"></p>
<p>Useful to have arrays (a matrix) of scatter plots can compactly summarize the relationships of pairs of attributes</p>
<h3 id="Contour-Plots"><a href="#Contour-Plots" class="headerlink" title="Contour Plots"></a>Contour Plots</h3><p>To show continuous attributes measured on a spatial grid<br>Partition the space into regions of similar values;<br>boundaries of regions are contour lines called iso-value lines, or isolines.</p>
<p><img src="/2019/05/03/visual/contour.jpg" alt="contour"></p>
<h2 id="Temporal-Data"><a href="#Temporal-Data" class="headerlink" title="Temporal Data"></a>Temporal Data</h2><p>Set of values that change over time</p>
<p>Common requirements:<br>– Able to compare many time series simultaneously<br>– Able to use different visualizations in combination</p>
<p><img src="/2019/05/03/visual/index.jpg" alt="index"></p>
<p><img src="/2019/05/03/visual/stack.jpg" alt="stack"></p>
<p>Stack area charts on top of each other<br>• Useful for showing summation of time-series values (aggregation)<br>• Limitation:<br>– negative numbers not supported<br>– difficult to interpret trends accurately<br>– meaningless for some kind of data (e.g., temperatures)</p>
<p><img src="/2019/05/03/visual/horizon.png" alt="horizon"></p>
<p>To divide the area plot into horizontal bands and layer them over each others.<br>• Useful for increasing the data density (i.e. save space) without sacrificing resolution.<br>• Limitation: Not intuitive and takes time to learn</p>
<p><img src="/2019/05/03/visual/spiral.jpg" alt="spiral"></p>
<h2 id="Geospatial-Data"><a href="#Geospatial-Data" class="headerlink" title="Geospatial Data"></a>Geospatial Data</h2><p>Data refers to a specific location in the world.<br>– e.g., population, health data, traffic, etc.<br>• Visualization techniques used intensively in geographic information systems (GIS), cartography.<br>• Issues:<br>– Geographical aggregation<br>• Recall the London Cholera Case<br>– Map projection</p>
<h3 id="Map-Projections"><a href="#Map-Projections" class="headerlink" title="Map Projections"></a>Map Projections</h3><ul>
<li><p>A mapping from a position on Earth (spherical surface) to a position on screen (a flat plane)</p>
</li>
<li><p>From longitude+latitude pair (l,j) to screen coordinates (x,y)</p>
</li>
</ul>
<p>All map projections must have distortions</p>
<p>Projection methods differ by spatial properties that they preserve<br>– Conformal (preserves local angle and thus shape; not area-preserving)<br>– Equal area (preserves area; shape can change)<br>– Equidistance (preserves distance from a specific point or line)</p>
<p><img src="/2019/05/03/visual/p1.jpg" alt="p1"></p>
<p><img src="/2019/05/03/visual/p2.jpg" alt="p2"></p>
<p><img src="/2019/05/03/visual/p3.jpg" alt="p3"></p>
<p><img src="/2019/05/03/visual/p4.jpg" alt="p4"></p>
<p><img src="/2019/05/03/visual/p5.jpg" alt="p5"></p>
<p><img src="/2019/05/03/visual/p6.jpg" alt="p6"></p>
<p><img src="/2019/05/03/visual/p7.jpg" alt="p7"></p>
<p><img src="/2019/05/03/visual/p8.jpg" alt="p8"></p>
<p><img src="/2019/05/03/visual/p9.jpg" alt="p9"></p>
<p><img src="/2019/05/03/visual/p10.jpg" alt="p10"></p>
<p><img src="/2019/05/03/visual/p11.jpg" alt="p11"></p>
<h2 id="Multivariate-Data"><a href="#Multivariate-Data" class="headerlink" title="Multivariate Data"></a>Multivariate Data</h2><p><img src="/2019/05/03/visual/p12.jpg" alt="p12"></p>
<p><img src="/2019/05/03/visual/p13.jpg" alt="p13"></p>
<p><img src="/2019/05/03/visual/p14.jpg" alt="p14"></p>
<p><img src="/2019/05/03/visual/p15.jpg" alt="p15"></p>
<p><img src="/2019/05/03/visual/p16.jpg" alt="p16"></p>
<h3 id="Dimension-Reduction"><a href="#Dimension-Reduction" class="headerlink" title="Dimension Reduction"></a>Dimension Reduction</h3><p>• To remove some of the dimensions out from the display to avoid cluttering<br>• Examples: Principle Component Analysis (PCA), Multidimensional Scaling (MDS), Self Organizing Maps (SOM)<br>• Issue: Resulting dimensions are not the original ones, not intuitive to users</p>
<p><img src="/2019/05/03/visual/p17.jpg" alt="p17"></p>
<h3 id="Dimension-Ordering"><a href="#Dimension-Ordering" class="headerlink" title="Dimension Ordering"></a>Dimension Ordering</h3><p>• Crucial for the effectiveness of many visualization techniques<br>• Relationship among adjacent dimensions are easier to detect than relationship among those positioned far apart, e.g., Parallel Coordinates, Heat Maps<br>• Use for attribute mapping to highlight important dimensions, e.g., Chernoff face,<br>• An NP-complete problem equivalent to the Travelling Salesman Problem (TSP)<br>• Use approximation to compute ordering or by manual ordering (interaction needed)</p>
<h2 id="Volume-Data"><a href="#Volume-Data" class="headerlink" title="Volume Data"></a>Volume Data</h2><p>A volume data is essentially a trivariate scalar function<br>A scalar value is defined at every (x, y, z) in the volume domain: v = f(x, y, z)<br>If we have a discrete sampling of the 3D domain, we obtain a voxel (volume element) representation</p>
<h1 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h1><h2 id="Graphs"><a href="#Graphs" class="headerlink" title="Graphs"></a>Graphs</h2><p><img src="/2019/05/03/visual/t1.jpg" alt="t1"></p>
<p><img src="/2019/05/03/visual/t2.jpg" alt="t2"></p>
<p><img src="/2019/05/03/visual/t3.jpg" alt="t3"></p>
<p><img src="/2019/05/03/visual/t4.jpg" alt="t4"></p>
<p><img src="/2019/05/03/visual/t5.jpg" alt="t5"></p>
<h3 id="Graph-Drawing"><a href="#Graph-Drawing" class="headerlink" title="Graph Drawing"></a>Graph Drawing</h3><p>Requirements<br>• Drawing conventions<br>– Rules specific to certain applications / professions<br>• Aesthetics<br>– Readability, layout<br>• Constraints</p>
<p><img src="/2019/05/03/visual/t6.jpg" alt="t6"></p>
<p><img src="/2019/05/03/visual/t7.jpg" alt="t7"></p>
<p><img src="/2019/05/03/visual/t8.jpg" alt="t8"></p>
<p>Key issues<br>• Graph size<br>– need filtering, clustering?<br>• Predictability<br>– similar drawing for the same graph every time?<br>• Time complexity<br>– Is real-time interaction possible?</p>
<h2 id="Trees-1"><a href="#Trees-1" class="headerlink" title="Trees"></a>Trees</h2><p>A tree is a directed acyclic graph:<br>– Exactly one unique vertex called the root with no parents<br>– Every vertex except the root has a parent<br>– There is a path from the root to each vertex<br>• Trees are good for representing:<br>– Hierarchies (file systems, web sites, organization charts)<br>– Branching Processes (family lineage, evolution)<br>– Decision processes (search trees, game trees, decision trees)</p>
<h3 id="Layouts"><a href="#Layouts" class="headerlink" title="Layouts"></a>Layouts</h3><ul>
<li><p>Indentation<br>– Tree depth is encoded by indentation</p>
</li>
<li><p>Node-Link Diagrams<br>– Nodes connected by lines/curves</p>
</li>
<li><p>Layered Diagrams<br>– Hierarchical structure represented by layering, adjacency or alignment</p>
</li>
<li><p>Enclosure/Containment Diagrams<br>– Hierarchical structure represented by enclosure</p>
</li>
</ul>
<p>In general, tree layout can be done efficiently in O(n) or O(n log n) time</p>
<p><img src="/2019/05/03/visual/t9.jpg" alt="t9"></p>
<p><img src="/2019/05/03/visual/t10.jpg" alt="t10"></p>
<p><img src="/2019/05/03/visual/t11.jpg" alt="t11"></p>
<p><img src="/2019/05/03/visual/t12.jpg" alt="t12"></p>
<p><img src="/2019/05/03/visual/t13.jpg" alt="t13"></p>
<p><img src="/2019/05/03/visual/t14.jpg" alt="t14"></p>
<p><img src="/2019/05/03/visual/t15.jpg" alt="t15"></p>
<p><img src="/2019/05/03/visual/t16.jpg" alt="t16"></p>
<p><img src="/2019/05/03/visual/t17.jpg" alt="t17"></p>
<p><img src="/2019/05/03/visual/t18.jpg" alt="t18"></p>
<p><img src="/2019/05/03/visual/t19.jpg" alt="t19"></p>
<p><img src="/2019/05/03/visual/t20.jpg" alt="t20"></p>
<p><img src="/2019/05/03/visual/t21.jpg" alt="t21"></p>
<p><img src="/2019/05/03/visual/t22.jpg" alt="t22"></p>
<p><img src="/2019/05/03/visual/t23.jpg" alt="t23"></p>
<p><img src="/2019/05/03/visual/t24.jpg" alt="t24"></p>
<p><img src="/2019/05/03/visual/t25.jpg" alt="t25"></p>
<p>Problems:<br>– Change in dataset causes dramatic discontinuous change<br>– Orders not preserved (Solution: Ordered Treemaps)</p>
<p><img src="/2019/05/03/visual/t26.jpg" alt="t26"></p>
<p><img src="/2019/05/03/visual/t27.jpg" alt="t27"></p>
<p>Problems:<br>– Computation involves an iterative process, which can be inefficient</p>
<h1 id="Networks"><a href="#Networks" class="headerlink" title="Networks"></a>Networks</h1><h3 id="Graph-Drawing-1"><a href="#Graph-Drawing-1" class="headerlink" title="Graph Drawing"></a>Graph Drawing</h3><p>• Direct calculation based on graph structure<br>– Spanning tree<br>– Adjacency matrix layout<br>• Optimization-based<br>– Optimizing the graph aesthetic constraints<br>– Force-directed layout</p>
<p><img src="/2019/05/03/visual/n1.jpg" alt="n1"></p>
<p>Spanning Tree can be obtained by<br>– Breadth-First Search (BFS) / Depth-First Search (DFS)<br>– Min/max spanning tree</p>
<p><img src="/2019/05/03/visual/n2.jpg" alt="n2"></p>
<p>Severe edge crossings and cluttering</p>
<p><img src="/2019/05/03/visual/n3.jpg" alt="n3"></p>
<p><img src="/2019/05/03/visual/n4.jpg" alt="n4"></p>
<p><img src="/2019/05/03/visual/n5.jpg" alt="n5"></p>
<p><img src="/2019/05/03/visual/n6.jpg" alt="n6"></p>
<h3 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h3><p>• Structure-based clustering<br>– Use only structural information of a graph<br>• Content-based clustering<br>– Use semantic data associated with graph elements<br>– Application specific</p>
<p><img src="/2019/05/03/visual/n7.jpg" alt="n7"></p>
<p><img src="/2019/05/03/visual/n8.jpg" alt="n8"></p>
<p><img src="/2019/05/03/visual/n9.jpg" alt="n9"></p>
<p><img src="/2019/05/03/visual/n10.jpg" alt="n10"></p>
<p><img src="/2019/05/03/visual/n11.jpg" alt="n11"></p>
<p><img src="/2019/05/03/visual/n12.jpg" alt="n12"></p>
<p><img src="/2019/05/03/visual/n13.jpg" alt="n13"></p>
<p><img src="/2019/05/03/visual/n14.jpg" alt="n14"></p>
<p><img src="/2019/05/03/visual/n16.jpg" alt="n16"></p>
<p>Measures the importance of a person in passing information within a network</p>
<p><img src="/2019/05/03/visual/n15.jpg" alt="n15"></p>
<p>Measures how close a person is to the others</p>
<p><img src="/2019/05/03/visual/n17.jpg" alt="n17"></p>
<p><img src="/2019/05/03/visual/n18.jpg" alt="n18"></p>
<p>Measures how well a person’s friends are connected to each other</p>
<p><img src="/2019/05/03/visual/n19.jpg" alt="n19"></p>
<p><img src="/2019/05/03/visual/n20.jpg" alt="n20"></p>
<p><img src="/2019/05/03/visual/n21.jpg" alt="n21"></p>
<p><img src="/2019/05/03/visual/n22.jpg" alt="n22"></p>
<p><img src="/2019/05/03/visual/n23.jpg" alt="n23"></p>
<h1 id="Text-amp-Document"><a href="#Text-amp-Document" class="headerlink" title="Text &amp; Document"></a>Text &amp; Document</h1><h2 id="Text-Analytics"><a href="#Text-Analytics" class="headerlink" title="Text Analytics"></a>Text Analytics</h2><ul>
<li><p>Text Summarization</p>
<p>To generate a precise summary of a given large amount of text information</p>
</li>
<li><p>Opinion Mining (aka Sentiment Analysis)</p>
<p>To extract and quantify affections (feelings) and subjective information from a given large amount of textual information</p>
</li>
<li><p>Steps further:<br>– How do the reviews on your products compare with your  competitors’?<br>– Any correlations between the blogger sentiments and movie box office?</p>
</li>
</ul>
<h2 id="Levels-of-Text-Representations"><a href="#Levels-of-Text-Representations" class="headerlink" title="Levels of Text Representations"></a>Levels of Text Representations</h2><ul>
<li><p>Lexical level</p>
<p>To group a string of characters into tokens, which is the basic unit of text to be analyzed and is application dependent</p>
</li>
<li><p>Syntactic level</p>
<p>To parse the purpose of tokens</p>
</li>
<li><p>Semantic level</p>
<p>To extract meaning of the syntactic structures of the full text</p>
</li>
</ul>
<p><img src="/2019/05/03/visual/tx1.jpg" alt="tx1"></p>
<p><img src="/2019/05/03/visual/tx2.jpg" alt="tx2"></p>
<p><img src="/2019/05/03/visual/tx3.jpg" alt="tx3"></p>
<p><img src="/2019/05/03/visual/tx4.jpg" alt="tx4"></p>
<p><img src="/2019/05/03/visual/tx5.jpg" alt="tx5"></p>
<p><img src="/2019/05/03/visual/tx6.jpg" alt="tx6"></p>
<p><img src="/2019/05/03/visual/tx7.jpg" alt="tx7"></p>
<p><img src="/2019/05/03/visual/tx8.jpg" alt="tx8"></p>
<p><img src="/2019/05/03/visual/tx9.jpg" alt="tx9"></p>
<p><img src="/2019/05/03/visual/tx10.jpg" alt="tx10"></p>
<p><img src="/2019/05/03/visual/tx11.jpg" alt="tx11"></p>
<h1 id="Interaction"><a href="#Interaction" class="headerlink" title="Interaction"></a>Interaction</h1><p>Interaction is useful for integrating human in the data exploration process and applying its perceptual abilities</p>
<ul>
<li>Interaction:<br>– Allows the user to interact with the visualization and dynamically change the visualizations according to the exploration objectives (as compared to static visualization on paper)<br>– Enables relating and combining multiple independent visualizations</li>
<li><p>Distortion:<br>– Allows focusing on details while preserving an overview of the data<br>– Shows portions of the data with a high level of detail, while others are shown in a lower level of detail</p>
</li>
<li><p>overview+detail: spatial separation</p>
</li>
<li>zooming: temporal separation</li>
<li>focus+context: seamless focus in context</li>
<li>linking and brushing: integrate data in different views</li>
</ul>
<p><img src="/2019/05/03/visual/i1.jpg" alt="i1"></p>
<p><img src="/2019/05/03/visual/i2.jpg" alt="i2"></p>
<p><img src="/2019/05/03/visual/i3.jpg" alt="i3"></p>
<p><img src="/2019/05/03/visual/i4.jpg" alt="i4"></p>
<p><img src="/2019/05/03/visual/i5.jpg" alt="i5"></p>
<p><img src="/2019/05/03/visual/i6.jpg" alt="i6"></p>
<p><strong>Problems of Distortion</strong></p>
<p>• Not suitable if spatial judgment is needed<br>• Difficult for target acquisition<br>– Items are displayed away from screen location</p>
<p><img src="/2019/05/03/visual/i7.jpg" alt="i7"></p>
<p><img src="/2019/05/03/visual/i8.jpg" alt="i8"></p>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
  </entry>
  <entry>
    <title>SpringAMQP &amp; RabbitMQ</title>
    <url>/2019/06/07/springamqp/</url>
    <content><![CDATA[<p><img src="/2019/06/07/springamqp/am1.jpg" alt="am1"></p>
<h1 id="Spring整合"><a href="#Spring整合" class="headerlink" title="Spring整合"></a>Spring整合</h1><h2 id="RabbitAdmin"><a href="#RabbitAdmin" class="headerlink" title="RabbitAdmin"></a>RabbitAdmin</h2><p>可在spring中直接注入，方便操作rabbitmq</p>
<p><img src="/2019/06/07/springamqp/am2.jpg" alt="am2"></p>
<p>前提：autoStartup必须为true，否择spring容器不加载rabbitadmin类</p>
<p>本质是获取spring容器中exchange，binding，routingkey，queue的@Bean声明</p>
<p>之后调用RabbitTemplate的execute方法执行一系列（声明，修改，删除）的rabbitmq基本操作</p>
<p>1、添加依赖</p>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
            &lt;version&gt;3.6.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;    
</code></pre>
<p>2、创建config类</p>
<pre><code class="java">@Configuration
@ComponentScan({&quot;com.bfxy.spring.*&quot;})
public class RabbitMQConfig {

    @Bean
    public ConnectionFactory connectionFactory(){
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
        connectionFactory.setAddresses(&quot;192.168.11.76:5672&quot;);
        connectionFactory.setUsername(&quot;guest&quot;);
        connectionFactory.setPassword(&quot;guest&quot;);
        connectionFactory.setVirtualHost(&quot;/&quot;);
        return connectionFactory;
    }

    @Bean
    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) {
        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);
        rabbitAdmin.setAutoStartup(true);
        return rabbitAdmin;
    }
}
</code></pre>
<p>3、测试使用</p>
<pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class ApplicationTests {

    @Test
    public void contextLoads() {
    }

    @Autowired
    private RabbitAdmin rabbitAdmin;

    @Test
    public void testAdmin() throws Exception {
        rabbitAdmin.declareExchange(new DirectExchange(&quot;test.direct&quot;, false, false));

        rabbitAdmin.declareExchange(new TopicExchange(&quot;test.topic&quot;, false, false));

        rabbitAdmin.declareExchange(new FanoutExchange(&quot;test.fanout&quot;, false, false));

        rabbitAdmin.declareQueue(new Queue(&quot;test.direct.queue&quot;, false));

        rabbitAdmin.declareQueue(new Queue(&quot;test.topic.queue&quot;, false));

        rabbitAdmin.declareQueue(new Queue(&quot;test.fanout.queue&quot;, false));

        rabbitAdmin.declareBinding(new Binding(&quot;test.direct.queue&quot;,
                Binding.DestinationType.QUEUE,
                &quot;test.direct&quot;, &quot;direct&quot;, new HashMap&lt;&gt;()));

        rabbitAdmin.declareBinding(
                BindingBuilder
                .bind(new Queue(&quot;test.topic.queue&quot;, false))        //直接创建队列
                .to(new TopicExchange(&quot;test.topic&quot;, false, false))    //直接创建交换机 建立关联关系
                .with(&quot;user.#&quot;));    //指定路由Key


        rabbitAdmin.declareBinding(
                BindingBuilder
                .bind(new Queue(&quot;test.fanout.queue&quot;, false))        
                .to(new FanoutExchange(&quot;test.fanout&quot;, false, false)));

        //清空队列数据
        rabbitAdmin.purgeQueue(&quot;test.topic.queue&quot;, false);
    }
</code></pre>
<h2 id="SpringAMQP声明"><a href="#SpringAMQP声明" class="headerlink" title="SpringAMQP声明"></a>SpringAMQP声明</h2><p>原始rabbitmq api声明：</p>
<p><img src="/2019/06/07/springamqp/am4.jpg" alt="am4"></p>
<p>SpringAMQP采用@Bean方式声明</p>
<pre><code class="java">@Configuration
@ComponentScan({&quot;com.bfxy.spring.*&quot;})
public class RabbitMQConfig {

    @Bean
    public ConnectionFactory connectionFactory(){
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
        connectionFactory.setAddresses(&quot;192.168.11.76:5672&quot;);
        connectionFactory.setUsername(&quot;guest&quot;);
        connectionFactory.setPassword(&quot;guest&quot;);
        connectionFactory.setVirtualHost(&quot;/&quot;);
        return connectionFactory;
    }

    @Bean
    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) {
        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);
        rabbitAdmin.setAutoStartup(true);
        return rabbitAdmin;
    }

    /**  
     * 针对消费者配置  
     * 1. 设置交换机类型  
     * 2. 将队列绑定到交换机  
        FanoutExchange: 将消息分发到所有的绑定队列，无routingkey的概念  
        HeadersExchange ：通过添加属性key-value匹配  
        DirectExchange:按照routingkey分发到指定队列  
        TopicExchange:多关键字匹配  
     */  
    @Bean  
    public TopicExchange exchange001() {  
        return new TopicExchange(&quot;topic001&quot;, true, false);  
    }  

    @Bean  
    public Queue queue001() {  
        return new Queue(&quot;queue001&quot;, true); //队列持久  
    }  

    @Bean  
    public Binding binding001() {  
        return BindingBuilder.bind(queue001()).to(exchange001()).with(&quot;spring.*&quot;);  
    }  

    @Bean  
    public TopicExchange exchange002() {  
        return new TopicExchange(&quot;topic002&quot;, true, false);  
    }  

    @Bean  
    public Queue queue002() {  
        return new Queue(&quot;queue002&quot;, true); //队列持久  
    }

    @Bean  
    public Binding binding002() {  
        return BindingBuilder.bind(queue002()).to(exchange002()).with(&quot;rabbit.*&quot;);  
    } 

    @Bean  
    public Queue queue003() {  
        return new Queue(&quot;queue003&quot;, true); //队列持久  
    }

    @Bean  
    public Binding binding003() {  
        return BindingBuilder.bind(queue003()).to(exchange001()).with(&quot;mq.*&quot;);  
    } 

    @Bean  
    public Queue queue_image() {  
        return new Queue(&quot;image_queue&quot;, true); //队列持久  
    }

    @Bean  
    public Queue queue_pdf() {  
        return new Queue(&quot;pdf_queue&quot;, true); //队列持久  
    }
</code></pre>
<h2 id="RabbitTemplate"><a href="#RabbitTemplate" class="headerlink" title="RabbitTemplate"></a>RabbitTemplate</h2><p>发送消息的关键类，注入到spring容器中直接使用</p>
<p>包括了可靠性投递消息、回调监听消息ConfirmCallback()、返回值确认接口ReturnCallback()</p>
<p>在config里注入</p>
<pre><code class="java">@Configuration
@ComponentScan({&quot;com.bfxy.spring.*&quot;})
public class RabbitMQConfig {

    @Bean
    public ConnectionFactory connectionFactory(){
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
        connectionFactory.setAddresses(&quot;192.168.11.76:5672&quot;);
        connectionFactory.setUsername(&quot;guest&quot;);
        connectionFactory.setPassword(&quot;guest&quot;);
        connectionFactory.setVirtualHost(&quot;/&quot;);
        return connectionFactory;
    }

    @Bean
    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) {
        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);
        rabbitAdmin.setAutoStartup(true);
        return rabbitAdmin;
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        return rabbitTemplate;
    }
</code></pre>
<p>调用template方法</p>
<pre><code class="java">    @Autowired
    private RabbitTemplate rabbitTemplate;


    @Test
    public void testSendMessage() throws Exception {
        //1 创建消息
        MessageProperties messageProperties = new MessageProperties();
        messageProperties.getHeaders().put(&quot;desc&quot;, &quot;信息描述..&quot;);
        messageProperties.getHeaders().put(&quot;type&quot;, &quot;自定义消息类型..&quot;);
        Message message = new Message(&quot;Hello RabbitMQ&quot;.getBytes(), messageProperties);

        rabbitTemplate.convertAndSend(&quot;topic001&quot;, &quot;spring.amqp&quot;, message, new MessagePostProcessor() {
            @Override
            public Message postProcessMessage(Message message) throws AmqpException {
                System.err.println(&quot;------添加额外的设置---------&quot;);
                message.getMessageProperties().getHeaders().put(&quot;desc&quot;, &quot;额外修改的信息描述&quot;);
                message.getMessageProperties().getHeaders().put(&quot;attr&quot;, &quot;额外新加的属性&quot;);
                return message;
            }
        });
    }
</code></pre>
<p>直接发送消息，不做配置</p>
<pre><code class="java">@Test
    public void testSendMessage2() throws Exception {
        //1 创建消息
        MessageProperties messageProperties = new MessageProperties();
        messageProperties.setContentType(&quot;text/plain&quot;);
        Message message = new Message(&quot;mq 消息1234&quot;.getBytes(), messageProperties);

        rabbitTemplate.send(&quot;topic001&quot;, &quot;spring.abc&quot;, message);

        rabbitTemplate.convertAndSend(&quot;topic001&quot;, &quot;spring.amqp&quot;, &quot;hello object message send!&quot;);
        rabbitTemplate.convertAndSend(&quot;topic002&quot;, &quot;rabbit.abc&quot;, &quot;hello object message send!&quot;);
    }
</code></pre>
<h2 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h2><p>监听队列的强大类，可以动态设置</p>
<ul>
<li>设置事务及其特性</li>
<li>设置消费者数量、批量消费等</li>
<li>设置消息确认、自动确认、是否重回队列、异常捕获handler等</li>
<li>设置消费者标签生成、独占模式消费者属性</li>
<li>设置具体的监听器、消息转换器</li>
</ul>
<p>config中注入</p>
<pre><code class="java">@Bean
    public SimpleMessageListenerContainer messageContainer(ConnectionFactory connectionFactory) {

        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);
        container.setQueues(queue001(), queue002(), queue003(), queue_image(), queue_pdf());
        container.setConcurrentConsumers(1);
        container.setMaxConcurrentConsumers(5);
        container.setDefaultRequeueRejected(false);
        container.setAcknowledgeMode(AcknowledgeMode.AUTO);
        container.setExposeListenerChannel(true);
        container.setConsumerTagStrategy(new ConsumerTagStrategy() {
            @Override
            public String createConsumerTag(String queue) {
                return queue + &quot;_&quot; + UUID.randomUUID().toString();
            }
        });

        container.setMessageListener(new ChannelAwareMessageListener() {
            @Override
            public void onMessage(Message message, Channel channel) throws Exception {
                String msg = new String(message.getBody());
                System.err.println(&quot;----------消费者: &quot; + msg);
            }
        });
        return container;
    }
</code></pre>
<p><img src="/2019/06/07/springamqp/am5.jpg" alt="am5"></p>
<p><img src="/2019/06/07/springamqp/mq6.jpg" alt="mq6"></p>
<h2 id="MessageListenerAdapter"><a href="#MessageListenerAdapter" class="headerlink" title="MessageListenerAdapter"></a>MessageListenerAdapter</h2><p>config中注入</p>
<pre><code class="java">@Bean
    public SimpleMessageListenerContainer messageContainer(ConnectionFactory connectionFactory) {

        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);
        container.setQueues(queue001(), queue002(), queue003(), queue_image(), queue_pdf());
        container.setConcurrentConsumers(1);
        container.setMaxConcurrentConsumers(5);
        container.setDefaultRequeueRejected(false);
        container.setAcknowledgeMode(AcknowledgeMode.AUTO);
        container.setExposeListenerChannel(true);
        container.setConsumerTagStrategy(new ConsumerTagStrategy() {
            @Override
            public String createConsumerTag(String queue) {
                return queue + &quot;_&quot; + UUID.randomUUID().toString();
            }
        });
        /**
        container.setMessageListener(new ChannelAwareMessageListener() {
            @Override
            public void onMessage(Message message, Channel channel) throws Exception {
                String msg = new String(message.getBody());
                System.err.println(&quot;----------消费者: &quot; + msg);
            }
        });
        */

        // 1 适配器方式. 默认是有自己的方法名字的：handleMessage
            // 可以自己指定一个方法的名字: consumeMessage
            // 也可以添加一个转换器: 从字节数组转换为String
        MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());
        adapter.setDefaultListenerMethod(&quot;consumeMessage&quot;);
        adapter.setMessageConverter(new TextMessageConverter());
        container.setMessageListener(adapter);

        return container;
    }
</code></pre>
<p>创建自己的适配器</p>
<pre><code class="java">import java.io.File;
import java.util.Map;
public class MessageDelegate {

    public void handleMessage(byte[] messageBody) {
        System.err.println(&quot;默认方法, 消息内容:&quot; + new String(messageBody));
    }

    /**

    public void consumeMessage(byte[] messageBody) {
        System.err.println(&quot;字节数组方法, 消息内容:&quot; + new String(messageBody));
    }

    public void consumeMessage(String messageBody) {
        System.err.println(&quot;字符串方法, 消息内容:&quot; + messageBody);
    }
    */
}
</code></pre>
<p>convert类</p>
<pre><code class="java">import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageProperties;
import org.springframework.amqp.support.converter.MessageConversionException;
import org.springframework.amqp.support.converter.MessageConverter;

public class TextMessageConverter implements MessageConverter {

    @Override
    public Message toMessage(Object object, MessageProperties messageProperties) throws MessageConversionException {
        return new Message(object.toString().getBytes(), messageProperties);
    }

    @Override
    public Object fromMessage(Message message) throws MessageConversionException {
        String contentType = message.getMessageProperties().getContentType();
        if(null != contentType &amp;&amp; contentType.contains(&quot;text&quot;)) {
            return new String(message.getBody());
        }
        return message.getBody();
    }
}
</code></pre>
<p>发送消息</p>
<pre><code class="java">@Test
    public void testSendMessage4Text() throws Exception {
        //1 创建消息
        MessageProperties messageProperties = new MessageProperties();
        messageProperties.setContentType(&quot;text/plain&quot;);
        Message message = new Message(&quot;mq 消息1234&quot;.getBytes(), messageProperties);

        rabbitTemplate.send(&quot;topic001&quot;, &quot;spring.abc&quot;, message);
        rabbitTemplate.send(&quot;topic002&quot;, &quot;rabbit.abc&quot;, message);
    }
</code></pre>
<p>队列名称和方法名称一一匹配</p>
<pre><code class="java">/**
     2 适配器方式: 我们的队列名称 和 方法名称 也可以进行一一的匹配
         */
        MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());
        adapter.setMessageConverter(new TextMessageConverter());
        Map&lt;String, String&gt; queueOrTagToMethodName = new HashMap&lt;&gt;();
        queueOrTagToMethodName.put(&quot;queue001&quot;, &quot;method1&quot;);
        queueOrTagToMethodName.put(&quot;queue002&quot;, &quot;method2&quot;);
        adapter.setQueueOrTagToMethodName(queueOrTagToMethodName);
        container.setMessageListener(adapter);        

</code></pre>
<p>MessageDelegate</p>
<pre><code class="java">import java.io.File;
import java.util.Map;
public class MessageDelegate {

    public void handleMessage(byte[] messageBody) {
        System.err.println(&quot;默认方法, 消息内容:&quot; + new String(messageBody));
    }

    public void method1(String messageBody) {
        System.err.println(&quot;method1 收到消息内容:&quot; + new String(messageBody));
    }

    public void method2(String messageBody) {
        System.err.println(&quot;method2 收到消息内容:&quot; + new String(messageBody));
    }
}
</code></pre>
<h2 id="MessageConverter"><a href="#MessageConverter" class="headerlink" title="MessageConverter"></a>MessageConverter</h2><p>正常消息为二进制传输，如果需要转换，则使用转换器</p>
<p>创建转换器，重写方法</p>
<p>ImageMessageConverter</p>
<pre><code class="java">import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.UUID;

import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageProperties;
import org.springframework.amqp.support.converter.MessageConversionException;
import org.springframework.amqp.support.converter.MessageConverter;

public class ImageMessageConverter implements MessageConverter {

    @Override
    public Message toMessage(Object object, MessageProperties messageProperties) throws MessageConversionException {
        throw new MessageConversionException(&quot; convert error ! &quot;);
    }

    @Override
    public Object fromMessage(Message message) throws MessageConversionException {
        System.err.println(&quot;-----------Image MessageConverter----------&quot;);

        Object _extName = message.getMessageProperties().getHeaders().get(&quot;extName&quot;);
        String extName = _extName == null ? &quot;png&quot; : _extName.toString();

        byte[] body = message.getBody();
        String fileName = UUID.randomUUID().toString();
        String path = &quot;d:/010_test/&quot; + fileName + &quot;.&quot; + extName;
        File f = new File(path);
        try {
            Files.copy(new ByteArrayInputStream(body), f.toPath());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return f;
    }
}
</code></pre>
<p>PDFMessageConverter</p>
<pre><code class="java">import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.UUID;

import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageProperties;
import org.springframework.amqp.support.converter.MessageConversionException;
import org.springframework.amqp.support.converter.MessageConverter;

public class PDFMessageConverter implements MessageConverter {

    @Override
    public Message toMessage(Object object, MessageProperties messageProperties) throws MessageConversionException {
        throw new MessageConversionException(&quot; convert error ! &quot;);
    }

    @Override
    public Object fromMessage(Message message) throws MessageConversionException {
        System.err.println(&quot;-----------PDF MessageConverter----------&quot;);

        byte[] body = message.getBody();
        String fileName = UUID.randomUUID().toString();
        String path = &quot;d:/010_test/&quot; + fileName + &quot;.pdf&quot;;
        File f = new File(path);
        try {
            Files.copy(new ByteArrayInputStream(body), f.toPath());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return f;
    }

}
</code></pre>
<p>创建两个实体类</p>
<pre><code class="java">package com.bfxy.spring.entity;

public class Order {

    private String id;

    private String name;

    private String content;

    public Order() {
    }

    public Order(String id, String name, String content) {
        this.id = id;
        this.name = name;
        this.content = content;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

}
</code></pre>
<pre><code class="java">package com.bfxy.spring.entity;

public class Packaged {

    private String id;

    private String name;

    private String description;

    public Packaged() {
    }

    public Packaged(String id, String name, String description) {
        this.id = id;
        this.name = name;
        this.description = description;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

}
</code></pre>
<p>config中，使用转换器</p>
<pre><code class="java">@Bean
    public SimpleMessageListenerContainer messageContainer(ConnectionFactory connectionFactory) {

        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);
        container.setQueues(queue001(), queue002(), queue003(), queue_image(), queue_pdf());
        container.setConcurrentConsumers(1);
        container.setMaxConcurrentConsumers(5);
        container.setDefaultRequeueRejected(false);
        container.setAcknowledgeMode(AcknowledgeMode.AUTO);
        container.setExposeListenerChannel(true);
        container.setConsumerTagStrategy(new ConsumerTagStrategy() {
            @Override
            public String createConsumerTag(String queue) {
                return queue + &quot;_&quot; + UUID.randomUUID().toString();
            }
        });
        /**
         * 1 适配器方式. 默认是有自己的方法名字的：handleMessage
            // 可以自己指定一个方法的名字: consumeMessage
            // 也可以添加一个转换器: 从字节数组转换为String
        MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());
        adapter.setDefaultListenerMethod(&quot;consumeMessage&quot;);
        adapter.setMessageConverter(new TextMessageConverter());
        container.setMessageListener(adapter);
        */

        /**
         * 2 适配器方式: 我们的队列名称 和 方法名称 也可以进行一一的匹配
         * 
        MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());
        adapter.setMessageConverter(new TextMessageConverter());
        Map&lt;String, String&gt; queueOrTagToMethodName = new HashMap&lt;&gt;();
        queueOrTagToMethodName.put(&quot;queue001&quot;, &quot;method1&quot;);
        queueOrTagToMethodName.put(&quot;queue002&quot;, &quot;method2&quot;);
        adapter.setQueueOrTagToMethodName(queueOrTagToMethodName);
        container.setMessageListener(adapter);        
        */

        // 1.1 支持json格式的转换器
        /**
        MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());
        adapter.setDefaultListenerMethod(&quot;consumeMessage&quot;);

        Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();
        adapter.setMessageConverter(jackson2JsonMessageConverter);

        container.setMessageListener(adapter);
        */



        // 1.2 DefaultJackson2JavaTypeMapper &amp; Jackson2JsonMessageConverter 支持java对象转换
        /**
        MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());
        adapter.setDefaultListenerMethod(&quot;consumeMessage&quot;);

        Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();

        DefaultJackson2JavaTypeMapper javaTypeMapper = new DefaultJackson2JavaTypeMapper();
        jackson2JsonMessageConverter.setJavaTypeMapper(javaTypeMapper);

        adapter.setMessageConverter(jackson2JsonMessageConverter);
        container.setMessageListener(adapter);
        */


        //1.3 DefaultJackson2JavaTypeMapper &amp; Jackson2JsonMessageConverter 支持java对象多映射转换
        /**
        MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());
        adapter.setDefaultListenerMethod(&quot;consumeMessage&quot;);
        Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();
        DefaultJackson2JavaTypeMapper javaTypeMapper = new DefaultJackson2JavaTypeMapper();

        Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = new HashMap&lt;String, Class&lt;?&gt;&gt;();
        idClassMapping.put(&quot;order&quot;, com.bfxy.spring.entity.Order.class);
        idClassMapping.put(&quot;packaged&quot;, com.bfxy.spring.entity.Packaged.class);

        javaTypeMapper.setIdClassMapping(idClassMapping);

        jackson2JsonMessageConverter.setJavaTypeMapper(javaTypeMapper);
        adapter.setMessageConverter(jackson2JsonMessageConverter);
        container.setMessageListener(adapter);
        */

        //1.4 ext convert

        MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());
        adapter.setDefaultListenerMethod(&quot;consumeMessage&quot;);

        //全局的转换器:
        //集合多种转换器
        ContentTypeDelegatingMessageConverter convert = new ContentTypeDelegatingMessageConverter();

        TextMessageConverter textConvert = new TextMessageConverter();
        convert.addDelegate(&quot;text&quot;, textConvert);
        convert.addDelegate(&quot;html/text&quot;, textConvert);
        convert.addDelegate(&quot;xml/text&quot;, textConvert);
        convert.addDelegate(&quot;text/plain&quot;, textConvert);

        Jackson2JsonMessageConverter jsonConvert = new Jackson2JsonMessageConverter();
        convert.addDelegate(&quot;json&quot;, jsonConvert);
        convert.addDelegate(&quot;application/json&quot;, jsonConvert);

        ImageMessageConverter imageConverter = new ImageMessageConverter();
        convert.addDelegate(&quot;image/png&quot;, imageConverter);
        convert.addDelegate(&quot;image&quot;, imageConverter);

        PDFMessageConverter pdfConverter = new PDFMessageConverter();
        convert.addDelegate(&quot;application/pdf&quot;, pdfConverter);


        adapter.setMessageConverter(convert);
        container.setMessageListener(adapter);

        return container;

    }
</code></pre>
<p>MessageDelegate</p>
<pre><code class="java">public class MessageDelegate {
    public void consumeMessage(Map messageBody) {
        System.err.println(&quot;map方法, 消息内容:&quot; + messageBody);
    }


    public void consumeMessage(Order order) {
        System.err.println(&quot;order对象, 消息内容, id: &quot; + order.getId() + 
                &quot;, name: &quot; + order.getName() + 
                &quot;, content: &quot;+ order.getContent());
    }

    public void consumeMessage(Packaged pack) {
        System.err.println(&quot;package对象, 消息内容, id: &quot; + pack.getId() + 
                &quot;, name: &quot; + pack.getName() + 
                &quot;, content: &quot;+ pack.getDescription());
    }

    public void consumeMessage(File file) {
        System.err.println(&quot;文件对象 方法, 消息内容:&quot; + file.getName());
    }
}
</code></pre>
<p>测试方法</p>
<pre><code class="java">@Test
    public void testSendJsonMessage() throws Exception {

        Order order = new Order();
        order.setId(&quot;001&quot;);
        order.setName(&quot;消息订单&quot;);
        order.setContent(&quot;描述信息&quot;);
        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(order);
        System.err.println(&quot;order 4 json: &quot; + json);

        MessageProperties messageProperties = new MessageProperties();
        //这里注意一定要修改contentType为 application/json
        messageProperties.setContentType(&quot;application/json&quot;);
        Message message = new Message(json.getBytes(), messageProperties);

        rabbitTemplate.send(&quot;topic001&quot;, &quot;spring.order&quot;, message);
    }

    @Test
    public void testSendJavaMessage() throws Exception {

        Order order = new Order();
        order.setId(&quot;001&quot;);
        order.setName(&quot;订单消息&quot;);
        order.setContent(&quot;订单描述信息&quot;);
        ObjectMapper mapper = new ObjectMapper();
        String json = mapper.writeValueAsString(order);
        System.err.println(&quot;order 4 json: &quot; + json);

        MessageProperties messageProperties = new MessageProperties();
        //这里注意一定要修改contentType为 application/json
        messageProperties.setContentType(&quot;application/json&quot;);
        messageProperties.getHeaders().put(&quot;__TypeId__&quot;, &quot;com.bfxy.spring.entity.Order&quot;);
        Message message = new Message(json.getBytes(), messageProperties);

        rabbitTemplate.send(&quot;topic001&quot;, &quot;spring.order&quot;, message);
    }

    @Test
    public void testSendMappingMessage() throws Exception {

        ObjectMapper mapper = new ObjectMapper();

        Order order = new Order();
        order.setId(&quot;001&quot;);
        order.setName(&quot;订单消息&quot;);
        order.setContent(&quot;订单描述信息&quot;);

        String json1 = mapper.writeValueAsString(order);
        System.err.println(&quot;order 4 json: &quot; + json1);

        MessageProperties messageProperties1 = new MessageProperties();
        //这里注意一定要修改contentType为 application/json
        messageProperties1.setContentType(&quot;application/json&quot;);
        messageProperties1.getHeaders().put(&quot;__TypeId__&quot;, &quot;order&quot;);
        Message message1 = new Message(json1.getBytes(), messageProperties1);
        rabbitTemplate.send(&quot;topic001&quot;, &quot;spring.order&quot;, message1);

        Packaged pack = new Packaged();
        pack.setId(&quot;002&quot;);
        pack.setName(&quot;包裹消息&quot;);
        pack.setDescription(&quot;包裹描述信息&quot;);

        String json2 = mapper.writeValueAsString(pack);
        System.err.println(&quot;pack 4 json: &quot; + json2);

        MessageProperties messageProperties2 = new MessageProperties();
        //这里注意一定要修改contentType为 application/json
        messageProperties2.setContentType(&quot;application/json&quot;);
        messageProperties2.getHeaders().put(&quot;__TypeId__&quot;, &quot;packaged&quot;);
        Message message2 = new Message(json2.getBytes(), messageProperties2);
        rabbitTemplate.send(&quot;topic001&quot;, &quot;spring.pack&quot;, message2);
    }

    @Test
    public void testSendExtConverterMessage() throws Exception {
//            byte[] body = Files.readAllBytes(Paths.get(&quot;d:/002_books&quot;, &quot;picture.png&quot;));
//            MessageProperties messageProperties = new MessageProperties();
//            messageProperties.setContentType(&quot;image/png&quot;);
//            messageProperties.getHeaders().put(&quot;extName&quot;, &quot;png&quot;);
        //在header中分类
//            Message message = new Message(body, messageProperties);
//            rabbitTemplate.send(&quot;&quot;, &quot;image_queue&quot;, message);

            byte[] body = Files.readAllBytes(Paths.get(&quot;d:/002_books&quot;, &quot;mysql.pdf&quot;));
            MessageProperties messageProperties = new MessageProperties();
            messageProperties.setContentType(&quot;application/pdf&quot;);
            Message message = new Message(body, messageProperties);
            rabbitTemplate.send(&quot;&quot;, &quot;pdf_queue&quot;, message);
    }
</code></pre>
<h1 id="Springboot整合"><a href="#Springboot整合" class="headerlink" title="Springboot整合"></a>Springboot整合</h1><p><img src="/2019/06/07/springamqp/mq7.jpg" alt="mq7"></p>
<p>producer</p>
<pre><code class="java">import java.util.Map;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.core.RabbitTemplate.ConfirmCallback;
import org.springframework.amqp.rabbit.core.RabbitTemplate.ReturnCallback;
import org.springframework.amqp.rabbit.support.CorrelationData;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

import com.bfxy.springboot.entity.Order;

@Component
public class RabbitSender {

    //自动注入RabbitTemplate模板类
    @Autowired
    private RabbitTemplate rabbitTemplate;  

    //回调函数: confirm确认
    final ConfirmCallback confirmCallback = new RabbitTemplate.ConfirmCallback() {
        @Override
        public void confirm(CorrelationData correlationData, boolean ack, String cause) {
            System.err.println(&quot;correlationData: &quot; + correlationData);
            System.err.println(&quot;ack: &quot; + ack);
            if(!ack){
                System.err.println(&quot;异常处理....&quot;);
            }
        }
    };

    //回调函数: return返回
    final ReturnCallback returnCallback = new RabbitTemplate.ReturnCallback() {
        @Override
        public void returnedMessage(org.springframework.amqp.core.Message message, int replyCode, String replyText,
                String exchange, String routingKey) {
            System.err.println(&quot;return exchange: &quot; + exchange + &quot;, routingKey: &quot; 
                + routingKey + &quot;, replyCode: &quot; + replyCode + &quot;, replyText: &quot; + replyText);
        }
    };

    //发送消息方法调用: 构建Message消息
    public void send(Object message, Map&lt;String, Object&gt; properties) throws Exception {
        MessageHeaders mhs = new MessageHeaders(properties);
        Message msg = MessageBuilder.createMessage(message, mhs);
        rabbitTemplate.setConfirmCallback(confirmCallback);
        rabbitTemplate.setReturnCallback(returnCallback);
        //id + 时间戳 全局唯一 
        CorrelationData correlationData = new CorrelationData(&quot;1234567890&quot;);
        rabbitTemplate.convertAndSend(&quot;exchange-1&quot;, &quot;springboot.abc&quot;, msg, correlationData);
    }

    //发送消息方法调用: 构建自定义对象消息
    public void sendOrder(Order order) throws Exception {
        rabbitTemplate.setConfirmCallback(confirmCallback);
        rabbitTemplate.setReturnCallback(returnCallback);
        //id + 时间戳 全局唯一 
        CorrelationData correlationData = new CorrelationData(&quot;0987654321&quot;);
        rabbitTemplate.convertAndSend(&quot;exchange-2&quot;, &quot;springboot.def&quot;, order, correlationData);
    }

}

</code></pre>
<p>consumer</p>
<pre><code class="java">import java.util.Map;

import org.springframework.amqp.rabbit.annotation.Exchange;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.QueueBinding;
import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.messaging.Message;
import org.springframework.messaging.handler.annotation.Headers;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.stereotype.Component;

import com.rabbitmq.client.Channel;

@Component
public class RabbitReceiver {


    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = &quot;queue-1&quot;, 
            durable=&quot;true&quot;),
            exchange = @Exchange(value = &quot;exchange-1&quot;, 
            durable=&quot;true&quot;, 
            type= &quot;topic&quot;, 
            ignoreDeclarationExceptions = &quot;true&quot;),
            key = &quot;springboot.*&quot;
            )
    )
    @RabbitHandler
    public void onMessage(Message message, Channel channel) throws Exception {
        System.err.println(&quot;--------------------------------------&quot;);
        System.err.println(&quot;消费端Payload: &quot; + message.getPayload());
        Long deliveryTag = (Long)message.getHeaders().get(AmqpHeaders.DELIVERY_TAG);
        //手工ACK
        channel.basicAck(deliveryTag, false);
    }


    /**
     * 
     *     spring.rabbitmq.listener.order.queue.name=queue-2
        spring.rabbitmq.listener.order.queue.durable=true
        spring.rabbitmq.listener.order.exchange.name=exchange-1
        spring.rabbitmq.listener.order.exchange.durable=true
        spring.rabbitmq.listener.order.exchange.type=topic
        spring.rabbitmq.listener.order.exchange.ignoreDeclarationExceptions=true
        spring.rabbitmq.listener.order.key=springboot.*
     * @param order
     * @param channel
     * @param headers
     * @throws Exception
     */
    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = &quot;${spring.rabbitmq.listener.order.queue.name}&quot;, 
            durable=&quot;${spring.rabbitmq.listener.order.queue.durable}&quot;),
            exchange = @Exchange(value = &quot;${spring.rabbitmq.listener.order.exchange.name}&quot;, 
            durable=&quot;${spring.rabbitmq.listener.order.exchange.durable}&quot;, 
            type= &quot;${spring.rabbitmq.listener.order.exchange.type}&quot;, 
            ignoreDeclarationExceptions = &quot;${spring.rabbitmq.listener.order.exchange.ignoreDeclarationExceptions}&quot;),
            key = &quot;${spring.rabbitmq.listener.order.key}&quot;
            )
    )
    @RabbitHandler
    public void onOrderMessage(@Payload com.bfxy.springboot.entity.Order order, 
            Channel channel, 
            @Headers Map&lt;String, Object&gt; headers) throws Exception {
        System.err.println(&quot;--------------------------------------&quot;);
        System.err.println(&quot;消费端order: &quot; + order.getId());
        Long deliveryTag = (Long)headers.get(AmqpHeaders.DELIVERY_TAG);
        //手工ACK
        channel.basicAck(deliveryTag, false);
    }
}
</code></pre>
<h1 id="Springcloud-Stream整合"><a href="#Springcloud-Stream整合" class="headerlink" title="Springcloud Stream整合"></a>Springcloud Stream整合</h1><p>消息的生产和发送可以采用不同的消息中间件</p>
<p><img src="/2019/06/07/springamqp/mq8.jpg" alt="mq8"></p>
<p><img src="/2019/06/07/springamqp/mq9.jpg" alt="mq9"></p>
<ul>
<li>@Output：输出注解，用于定义发送消息接口</li>
<li>@Input：输入注解，用于定义消息的消费者接口</li>
<li>@StreamListener：用于定义监听方法的注解</li>
</ul>
<p>但是不能保证100%可靠性投递，兼容rabbitmq，Kafka</p>
<p>添加依赖</p>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;    
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;        
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
            &lt;version&gt;1.3.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>生产端</p>
<p>properties</p>
<pre><code class="properties">server.port=8001
server.servlet.context-path=/producer

spring.application.name=producer
spring.cloud.stream.bindings.output_channel.destination=exchange-3
spring.cloud.stream.bindings.output_channel.group=queue-3
spring.cloud.stream.bindings.output_channel.binder=rabbit_cluster

spring.cloud.stream.binders.rabbit_cluster.type=rabbit
spring.cloud.stream.binders.rabbit_cluster.environment.spring.rabbitmq.addresses=192.168.11.76:5672
spring.cloud.stream.binders.rabbit_cluster.environment.spring.rabbitmq.username=guest
spring.cloud.stream.binders.rabbit_cluster.environment.spring.rabbitmq.password=guest
spring.cloud.stream.binders.rabbit_cluster.environment.spring.rabbitmq.virtual-host=/
</code></pre>
<p>Barista</p>
<pre><code class="java">import org.springframework.cloud.stream.annotation.Output;
import org.springframework.messaging.MessageChannel;

/**
 * &lt;B&gt;中文类名：&lt;/B&gt;&lt;BR&gt;
 * &lt;B&gt;概要说明：&lt;/B&gt;&lt;BR&gt;
 * 这里的Barista接口是定义来作为后面类的参数，这一接口定义来通道类型和通道名称。
 * 通道名称是作为配置用，通道类型则决定了app会使用这一通道进行发送消息还是从中接收消息。
 */
public interface Barista {

    //String INPUT_CHANNEL = &quot;input_channel&quot;;  
    String OUTPUT_CHANNEL = &quot;output_channel&quot;;  

    //注解@Input声明了它是一个输入类型的通道，名字是Barista.INPUT_CHANNEL，也就是position3的input_channel。这一名字与上述配置app2的配置文件中position1应该一致，表明注入了一个名字叫做input_channel的通道，它的类型是input，订阅的主题是position2处声明的mydest这个主题  
//    @Input(Barista.INPUT_CHANNEL)  
//    SubscribableChannel loginput();  
    //注解@Output声明了它是一个输出类型的通道，名字是output_channel。这一名字与app1中通道名一致，表明注入了一个名字为output_channel的通道，类型是output，发布的主题名为mydest。  
    @Output(Barista.OUTPUT_CHANNEL)
    MessageChannel logoutput();  

//    String INPUT_BASE = &quot;queue-1&quot;;  
//    String OUTPUT_BASE = &quot;queue-1&quot;;  
//    @Input(Barista.INPUT_BASE)  
//    SubscribableChannel input1();  
//    MessageChannel output1();  

}  
</code></pre>
<p>sender</p>
<pre><code class="java">import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Service;

@EnableBinding(Barista.class)
@Service  
public class RabbitmqSender {  

    @Autowired  
    private Barista barista;  

    // 发送消息
    public String sendMessage(Object message, Map&lt;String, Object&gt; properties) throws Exception {  
        try{
            MessageHeaders mhs = new MessageHeaders(properties);
            Message msg = MessageBuilder.createMessage(message, mhs);
            boolean sendStatus = barista.logoutput().send(msg);
            System.err.println(&quot;--------------sending -------------------&quot;);
            System.out.println(&quot;发送数据：&quot; + message + &quot;,sendStatus: &quot; + sendStatus);
        }catch (Exception e){  
            System.err.println(&quot;-------------error-------------&quot;);
            e.printStackTrace();
            throw new RuntimeException(e.getMessage());

        }  
        return null;
    }  

}  
</code></pre>
<p>消费端</p>
<pre><code class="properties">server.port=8002
server.context-path=/consumer

spring.application.name=consumer
spring.cloud.stream.bindings.input_channel.destination=exchange-3
spring.cloud.stream.bindings.input_channel.group=queue-3
spring.cloud.stream.bindings.input_channel.binder=rabbit_cluster
spring.cloud.stream.bindings.input_channel.consumer.concurrency=1
spring.cloud.stream.rabbit.bindings.input_channel.consumer.requeue-rejected=false
spring.cloud.stream.rabbit.bindings.input_channel.consumer.acknowledge-mode=MANUAL
spring.cloud.stream.rabbit.bindings.input_channel.consumer.recovery-interval=3000
spring.cloud.stream.rabbit.bindings.input_channel.consumer.durable-subscription=true
spring.cloud.stream.rabbit.bindings.input_channel.consumer.max-concurrency=5

spring.cloud.stream.binders.rabbit_cluster.type=rabbit
spring.cloud.stream.binders.rabbit_cluster.environment.spring.rabbitmq.addresses=192.168.11.76:5672
spring.cloud.stream.binders.rabbit_cluster.environment.spring.rabbitmq.username=guest
spring.cloud.stream.binders.rabbit_cluster.environment.spring.rabbitmq.password=guest
spring.cloud.stream.binders.rabbit_cluster.environment.spring.rabbitmq.virtual-host=/
</code></pre>
<pre><code class="java">import org.springframework.cloud.stream.annotation.Input;
import org.springframework.messaging.SubscribableChannel;

/**
 * &lt;B&gt;中文类名：&lt;/B&gt;&lt;BR&gt;
 * &lt;B&gt;概要说明：&lt;/B&gt;&lt;BR&gt;
 * 这里的Barista接口是定义来作为后面类的参数，这一接口定义来通道类型和通道名称。
 * 通道名称是作为配置用，通道类型则决定了app会使用这一通道进行发送消息还是从中接收消息。
 * @author ashen（Alienware）
 * @since 2016年7月22日
 */

public interface Barista {

    String INPUT_CHANNEL = &quot;input_channel&quot;;  

    //注解@Input声明了它是一个输入类型的通道，名字是Barista.INPUT_CHANNEL，也就是position3的input_channel。这一名字与上述配置app2的配置文件中position1应该一致，表明注入了一个名字叫做input_channel的通道，它的类型是input，订阅的主题是position2处声明的mydest这个主题  
    @Input(Barista.INPUT_CHANNEL)  
    SubscribableChannel loginput();  


}  
</code></pre>
<pre><code class="java">import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.messaging.Message;
import org.springframework.stereotype.Service;

import com.rabbitmq.client.Channel;


@EnableBinding(Barista.class)
@Service
public class RabbitmqReceiver {  

    @StreamListener(Barista.INPUT_CHANNEL)  
    public void receiver(Message message) throws Exception {  
        Channel channel = (com.rabbitmq.client.Channel) message.getHeaders().get(AmqpHeaders.CHANNEL);
        Long deliveryTag = (Long) message.getHeaders().get(AmqpHeaders.DELIVERY_TAG);
        System.out.println(&quot;Input Stream 1 接受数据：&quot; + message);
        System.out.println(&quot;消费完毕------------&quot;);
        channel.basicAck(deliveryTag, false);
    }  
}  
</code></pre>
]]></content>
      <categories>
        <category>study note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MQ</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
